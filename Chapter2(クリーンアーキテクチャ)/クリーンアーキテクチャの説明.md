
# iOSアプリでスケールしやすいアーキテクチャを考えてみた②-設計を理解するためのクリーンアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)**設計を理解するためのクリーンアーキテクチャ編←本記事**  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への準備編として設計の概観を理解するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  
また本記事はレイヤードアーキテクチャの知識を前提としていますので、レイヤードアーキテクチャがわからない方は前の記事から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

### 記事内の用語の表記ルール 
#### アーキテクチャと設計
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの言葉の定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるもの  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっていることが多いと思うのでこの記事では上のように区別することとします。  
#### 各層の表記
記事内でアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。    
例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logic(層)と表記します。  
InfrastructureはInfraと省略して表記し、Infra層のうちデータ操作に関するものをData(層)、端末機能に関するものをDevice(層)と表現する場合があります。  


## 前回までの内容と本記事の内容
初回である前回の記事ではスケールしやすいアーキテクチャを考えるためにクリーンアーキテクチャを通して設計を理解することを最初の目的としました。  
そしてその準備としてクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャの理解を深めたのが前回までの内容です。

本記事ではいよいよクリーンアーキテクチャを学び、設計についてまとめたいと思います。

## クリーンアーキテクチャとレイヤードアーキテクチャの共通点/相違点
最初に前回学んだレイヤードアーキテクチャと今回学ぶクリーンアーキテクチャの共通点、そして相違点について整理することでクリーンアーキテクチャを理解するために必要なポイントをまとめます。   
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>


前回の記事でレイヤードアーキテクチャの特徴が**責務による層の分割と単一方向の依存関係による関心の分離**であることを述べました。  
クリーンアーキテクチャでもそれは変わりません。    
円の中の一つ一つの色が層を示していて、また円内側の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格はつかめているといえます。  
ただクリーンアーキテクチャではその詳細が異なります。  
なのでクリーンアーキテクチャを理解するためにその層の分割と依存関係の詳細を見ていきたいと思うのですが、これらを理解することはクリーンアーキテクチャが円である理由を理解することと同じです。  
そのため最初にクリーンアーキテクチャが円である理由を踏まえながら円の各層・依存関係について説明していきたいと思います。  

## Entities == Domain層 && Use Cases == Application層
最初にクリーンアーキテクチャが円である理由を見ていきますが、その前に前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所があるので説明します。    
結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層であり、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層と同じです。     
円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」です。  
前回の記事でDomainとは「事業の知識・ルール」を意味していることを書きましたが、ここからEntitiesがDomainと同じであることがわかると思います。    
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesに書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要でしょう。

以後EntitiesではDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため

クリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか？  
実はその答えはレイヤードアーキテクチャの記事ですでに書いています。  
レイヤードアーキテクチャの記事のPresentation Domain Separation(以下PDSと表記)の説明でビジネスロジックを「アプリケーションプログラムの機能的中心」と表現しましたが、まさにこれがBusiness LogicであるDomainとApplicationが円の中心にある理由です。  

### Business Logicを円の中心に置く3つの理由
その理由をもう少し具体的に示すと以下のようになります。  

1. サービスのアイディアを具体化したものがBusiness Logicのデータ・ロジックであり、Business Logicなしではアプリケーションは成立しない   
2. Business LogicはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. Business Logicは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

以下ではそれぞれの詳細について説明します。  
#### 1.ビジネスはアイディアから
Business Logicを円の中心に置く理由として3つ挙げましたが他の2つは副次的なものであり、これこそがクリーンアーキテクチャの中心にBusiness Logicを置く理由です。  
「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、プログラム化したものがDomain層であり、さらにそれをアプリケーションとして提供するために書かれたプログラムがApplication層です。  
UI層はそのサービスをユーザーへ提供する窓口として存在しInfra層はそのサービスの実現のための手段として必要であって、アプリケーションは必ずBusiness Logicから生まれます。      

#### 2.Business Logicは相対的に変更されづらい層
またそれはBusiness Logicがアプリケーションの中で相対的に変わりづらい箇所であることも意味しています。(ここでいう「変更」はアプリケーションの仕様変更や機能的に要求によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。)  
UIやInfraはBusiness Logicが変わることがなくてもUXや技術的なパフォーマンスの観点から変更することがあります。  
それに対してサービスの仕様が変更された場合はBusiness Logicは変更されますが、それに応じて必ずUIやInfraも変更を迫られることになります。  
このようにBusiness Logicはアプリケーションの機能的中心でサービスそのものであるため、Business Logicの定義が変わる場合はそれに応じて他の層も変更する必要があります。  

#### 3.外部技術に依存していない
これはどちらかというと「Business Logicが円の中心である理由」というよりも「Business Logicが他の層から切り離される理由」といった方が良いかもしれません。   
ただBusiness Logicが純粋なプログラミング言語の定義によってのみ構成されて外部技術に依存しないのは、結局そのサービスの核心であるため外部技術に依存していないという話につながりますし、この「外部技術に依存していない」という側面は円図を説明する上で重要な要素であるため理由の一つに加えました。       


### クリーンアーキテクチャは現実の開発状況をより反映させている
そしてこうしたDomainとApplicationを中心に据えたクリーンアーキテクチャはレイヤードアーキテクチャと比べてより現実を反映させた設計であると言えます。  

レイヤードアーキテクチャでは技術的な側面から依存関係を決定したため、技術的な基盤となるInfraをアプリケーションの支えとして捉え「UI->Application->Domain->Infra」という関係でした。  
それに対してクリーンアーキテクチャはアプリケーションの機能的中心であるBusiness Logicがアプリケーションを支えていると捉え、他の層がBusiness Logicに依存しています。  
クリーンアーキテクチャのこの構造は現実のアプリケーション開発の実態をより正確に捉えています。  
アプリケーションは技術的にはインフラに依存していますが、サービス的に依存しているのはビジネスロジックであり開発はビジネスロジックを起点に動きます。  
そのためビジネスロジックを中心として他の層と切り離すことで、実務で発生する要件に柔軟かつ迅速に対応することが可能になるのです。  
私たちの日々の業務でも技術的にはインフラであるインターネットに依存しつつもその活動はビジネス的な事柄に依存していますが、それと同じです。  

図  
このようにクリーンアーキテクチャは技術的には(レイヤードアーキテクチャでは)4層の中間に位置するBusiness Logicをアプリケーションの基盤と捉えたアプリケーション設計であり、それを
視覚的に示すため円の形となっています。  

## Framework & Drivers層とInterface Adapter層
クリーンアーキテクチャがなぜ円なのかについて理解できたところで、まだ説明されていないFrame & Drivers層とInterface Adapter層について説明していきます。  
### Framework & Drivers層
まずFrame & Drivers層から説明します。  

Framework&Driversの意味はFrameworksはフレームワーク、つまりiOSのUIKit等パッケージ化された外部技術、DriversはIT用語でシステムに装着する外部装置を意味しておりこの層はビジネスロジックをアプリケーションプロダクトとして完成させるために必要な外部技術群と指していると言えます。  
円を見てみるとこの層にはUI/Web/DataBase/Devices/External Interfacesとさまざまなものが表記されており、レイヤードアーキテクチャのUI、Infraそしてフレームワーク等がここに含まれています。  
ここではレイヤードアーキテクチャで異なる層であったUIとInfraが一つの層とされているわけですが、私たちは既に同様のケースを前回の記事でも見ています。  
PDS(以下)のPresentationです。  
PDSのPresentationにはUIのみならずInfraも含まれることを前回の記事で説明しましたが、クリーンアーキテクチャでも同様に同じ層として扱っているのはこの2つが以下の共通点を持っているためです。  
- 仕様の変更によってプログラムが変化しやすい
- 外部技術に依存している<sup>[*1](#footnote1)</sup>

こうした特徴を持った層に他の層が依存していると、変更による影響が依存している他の層にも広がってしまい柔軟な開発を行うことが難しくなります。  
そのためクリーンアーキテクチャではこれらの特徴を持ったUI/Infra層が他の層から依存されないように同じ最外層に置いているのです。

### クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない
これはこのあとのInterface Adapters層にも言えることですが、クリーンアーキテクチャの層がアプリケーションのディレクトリ構造になることは滅多にありません。    
Framework&Drivers層のUIとInfraは実際のアプリケーション開発では区別されることが多いですし、またInterface Adapters層でもPresenter等UI側のコンポーネントとRepository等Infra側のコンポーネントは区別されます。  
その理由はクリーンアーキテクチャの層の構成がディレクトリ構造の目的と合致していないからです。  
ディレクトリ構造ではそのディレクトリにどのような責務のプログラムが置かれているかを具体的に示す必要がありますが、クリーンアーキテクチャではよりメタ視点から層を捉えています。  
例えばFramework&Drivers層はBusinessLogicに対する外部プログラムであることを意味しているだけであり、UIやInfra等のように具体的にどのような責務を担っているのか示しているわけではありません。     
そのためアプリケーションのディレクトリ構造はレイヤードアーキテクチャの責務分割に沿って成り立っていることが多いです。    
このようなところからクリーンアーキテクチャとレイヤードアーキテクチャでは層を捉える視点の次元が異なることがわかります。  

図

### Interface Adapters層

さて、残る一つはInterface Adaptersです。  
Interface Adapterという言葉だけ聞くとなにやら難しく感じてしまうのですが、簡単にいえばこの層は内側のBusiness Logicと外側のFramework&Drivers層を繋ぐための仲介役を担う層です。  

円図ではこの層に該当するコンポーネントとしてController/Presenter/Gateway等が書かれていますが、基本的にこれらのうちControllerとPresenterがUIとビジネスロジックの、GatewayがBusiness LogicとInfraの仲介役を担っています。  
iOSMVCのControllerに当たるViewControllerもここに属し、円図でいうController/Presenterを担っています。  
図

#### MVCのControllerと円図にあるControllerは異なる
ややこしいのですが、MVCアーキテクチャの文脈でいうControllerと円図に書いてあるControllerは意味が異なります。  
私たちにとってはControllerというと画面の入出力処理を担うMVCアーキテクチャのControllerが馴染み深いと思いますが、ITにおける一般的なControllerは入力のみに関する処理装置を意味していて出力に関する意味は含まれていません。  
これはMVPのPresenterにも同じことが言えて、Presenterは一般的には出力のみに関する処理装置を指しておりMVPのPresenterは円図でいうControllerとPresenterの両方の責務を担っていることになります。  

#### Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる
このInterface Adapters層が担う層の仲介という責務はレイヤードアーキテクチャでは存在していませんでしたが、実際に開発で実践してみるとこの層の重要性に気づきます。  
層同士が連携して責務が混ざり合った箇所を一つの独立した層として捉えることで各層責務の純度が格段に上がるのです。  
  
レイヤードアーキテクチャの層はアプリケーションを機能によってわかりやすく分割していますが、それはあくまで理論上の話であって実際のアプリケーションでは各層が連携して一つのアプリケーションとして動作するため複数の層の責務が交わり境界が曖昧な処理が発生します。  
例えばDomain層ではビジネス的な事柄が関心の対象なので、永続化機構でデータを更新するためのURLやそのためのデータ形式の変換に関心を向けるべきではありません。  
ただ一方でInfra層ではデータを永続化するという汎用的な責務を担ってはいるものの、特定のURLやそれに関する処理はそのアプリケーション(ドメイン)固有なものなのでInfra層がその責務を負うのはおかしなことです。  
このようにレイヤードアーキテクチャによる層の分割を実践しようとするとその層の境界でどっちつかずな責務が発生してしまい、このような責務は妥協の末に基本的に利用する側(上の例ではDomainがInfraを利用するのでDomain層)に実装されるようになります。  

この問題を解決するためにクリーンアーキテクチャではレイヤードアーキテクチャの層が連携する責務も一つの独立した層として捉えました。  
こうすることで円の内側のビジネスロジックと外側のFramework & Drivers層に不純な責務を含める必要がなくなり、各層の責務の純度を高く保つことができます。   

図

#### RepositoryもInterface Adapters層
ちなみに円図では表記されていませんが、開発でよく耳にするRepositoryもこのInterface Adapters層に入ります。  
Marin Flower氏の定義を引用するとRepositoryはDomain層とData層の仲介役です。(引用文のdata mapping layersはData層を指しています。)  
>A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection  
>
>意訳
>RepositoryはDomainとData層の中立ちをし、インメモリなドメインオブジェクトコレクションのように振る舞います
円図でいうとGatewaysの中に含まれていると考えればよいと思います。   

#### Gatewayとは異なる層の中継役という意味
Gatewayという名前はクラス名としてはあまり聞き慣れないと思いますが、ネットワークの文脈では異なる層の中継役を担う装置を指しており、クリーンアーキテクチャでも同様の意味を持っています。    
私はInterfaceAdapter層のコンポーネント名を命名するとき、できる限り~Repository等より具体的な名前を使うようにしていますが適切な名前が見つからない時はGatewayの名前を使っています。    
Gatewayは広範囲を示す名前ではありますが、プロジェクト内で乱用されるような名前ではなくそれだけでInterface Adapter層のコンポーネントだと伝わると思うので「~Managerクラス」や「~Serviceクラス」等より責務が明確で便利な単語だと思います。  

## クリーンアーキテクチャの依存ルール
クリーンアーキテクチャでの依存は外側の層から内側の層へという方向であること、また外側の層の仕様は変わりやすく内側の層の仕様は変わりづらいことを説明しました。  
つまりクリーンアーキテクチャの依存は変更されやすい外側の層から変更されにくい内側の層へ向いており、こうすることで外側の層の変更のされやすさがアプリケーションへ影響することを最小限に抑えています。  
ただ技術的に依存しているのはInfra層のはずなのに、Infra層がビジネスロジックに依存するということはどういうことなのでしょうか？  
これについてはこの後クリーンアーキテクチャのルールを守るためのテクニックという節で説明します。  

## クリーンアーキテクチャの概要を一度整理する 
ここまででクリーンアーキテクチャの特徴に一通り触れました。  
しかしレイヤードアーキテクチャの理解を前提として話を進めたため、クリーンアーキテクチャの基本的な説明をあまりしていません。        
そのためこれまでの内容と重複する部分もありますが、ここで一度クリーンアーキテクチャの原文に沿った形でその概要を整理したいと思います。  

## クリーンアーキテクチャの特徴   
クリーンアーキテクチャの記事の冒頭では、ヘキサゴナルアーキテクチャ・オニオンアーキテクチャなどのシステムアーキテクチャを紹介しています。  
システムアーキテクチャの意味は私も正確に理解しているわけではないのですが、恐らくアプリケーションの特定の領域にこだわらずシステム全体を関心の対象としているアーキテクチャという理解で大丈夫だと思います。     
クリーンアーキテクチャ原文ではそれらシステムアーキテクチャの特徴として以下の共通点があると述べています。    

1. 関心の分離  
どのシステムアーキテクチャも関心の分離を基本として、少なくともBusiness Logicとその他の2層に分けようしている  
2. UI/WebAPI/データベース/フレームワークといった外部技術が独立している  
アプリケーションのうち変更されやすいUI/Web API/データベース/フレームワーク等のコードにどこからも依存しない  
このような外部技術は便利なものの、同時に開発時の制約も発生するためこれらに依存しないようにすることで柔軟な開発が可能になる  
3. テストしやすい  
Business Logicも特定の外部技術に依存していないためテストが容易になる  
またのちに見るように層の依存関係をclassなどの実体型で実現するのではなく、プロトコルを利用した抽象型によって実現することでビジネスロジック以外の層でもテストがやりやすい  

そしてクリーンアーキテクチャの円図はこうした特徴を視覚的にまとめたものです。  

### クリーンアーキテクチャの層は4つである必要はない
クリーンアーキテクチャはDomain/Applicatoin/Interface Adapters/Framework&Driversという4つの層からなっていると説明しましたが、原文には必要であればもっと層を増やしても構わないと書かれています。  
ただ該当箇所の小見出しには「Only Four Circles?(4つの層だけ?)」と書かれており、基本的に4つの層より多くなることはあっても4つの層より少なくなるようなことはないという考えのようです。   
私も責務の分離を目的とするなら少なくともBusiness Logic/Interface Adapters/Framework&Driversの3層は必要だと考えていますし、Business Logicも設計者が層の分割を意識してるかどうかは別としてその中で責務をしっかり分けていくと実質的にはDomain/Applicationの分離が生まれてくると思うのでこの4層を基本として、必要であればそれ以上に層を分けるというスタンスで良いと思っています。    

## クリーンアーキテクチャで守るべきルール  
クリーンアーキテクチャの特徴を保つためには開発者が守らなければいけないルールがあります。  
それは大きく言って以下3点です。  

### ルール1:円の内側の層は外側の層については知らない何も知らないし、影響も受けない
Business Logicは外側の層について何も知らなくても独立して動作できるようになっている必要があります。  
それはBusiness Logic内のDomain層とApplication層に関しても同様で、内側の層であるDomainは外側のApplicationについて知っているべきではありません。  
クリーンアーキテクチャではアプリケーションとして動作するために各層は連携しつつも可能な限り関心を分離することを目的としているため、依存して良いのは外側の層から内側の層へのみとなっています。  

#### しかしInterface&nbsp;Adapters層は例外
ただこのうちInterface Adaptersは少し例外といえます。   
既に説明した通りInterface Adaptersは内側と外側の層の中継役となる層なので直接的ではなくても外側の層の事情を知ることになるからです。  
具体的に説明すると、UI側のInterface Adapters層はUIの仕様変更によって自身の入力・出力の処理も変更することになるので直接UIを知らなくても間接的にその仕様について知っていることになりますし、Infra側のInterface Adapters層も実体型としてデータベースやWebAPIを参照していなくともメソッド名やその引数から参照先がデータベースかWebAPIか等外側の層の事情はある程度把握できます。
またデータベースからWebAPIへの移行等Infra側の機構を変更した場合には、基本的にそれに関連するInterfaceAdapters層も変更が必要になります。  
  
原文の記事でも冒頭で  
>Nothing in an inner circle can know anything at all about something in an outer circle.  
>
>意訳  
>内側の層は外側の層について全く知らないこと。  

と強調しながらも、Interface Adapter層の説明でSQLデータベースを例に出しながらInterface Adapter層で外側の層を知っていることは致し方ないことだと書いています。(ただ同時に外側の層がInterface Adapter層に与える影響は必要最低限に留めることも強調しています。)
>If the database is a SQL database, then all the SQL should be restricted to this layer, and in particular to the parts of this layer that have to do with the database.
>
>意訳  
>もしデータベースがSQLならば、SQLに関するコードはInterface Adapter層の内データベースと関与する箇所のみにとどめるべきである。  

### ルール2:層をまたぐオブジェクトはシンプルなデータ構造であること
層同士で連携してオブジェクトの受け渡しを行う際には層の責務が漏出してしまう危険性があります。  
アプリケーションとして動くためには層間の連携は避けられませんが、ある層のオブジェクトが他の層に渡されることでそのオブジェクトが属する層以外で利用されることになるからです。  
クリーンアーキテクチャではこうした状況でも関心の分離を保つために、層をまたぐオブジェクトはシンプルなデータ構造であるであるべきだとしています。    

もし層をまたぐオブジェクトが複雑な処理のメソッドを持っていた場合、またいだ先の層でもそのメソッドの呼び出しが可能であるためそのメソッドを通して複雑な処理が行われて責務が他の層へ漏出していってしまう恐れがあります。  
こうした場合受け渡し元の層からメソッドを持ったオブジェクトが受け渡し先でどのように利用されるのか想定しきれないため、開発における不確実性が高まりバグの温床となります。

図
　　
それに対してこの層をまたぐオブジェクトがメソッドを持たないデータ構造である場合は、他の層ではそのデータ操作のみ可能となるため渡す側の層はそのオブジェクトが他の層へ与える影響を制御可能です。  

このように層をまたぐオブジェクトをシンプルなデータ構造にすることによって、層の責務の漏出は必要最低限かつ予測可能なものとなり関心の分離は高い水準に保たれます。 

図

ちなみにここでいうメソッドを持ったオブジェクトとは層の責務の漏出につながるようなメソッドを持っているものを指しています。  
例えばSwiftのArrayはメソッドを持っていますが、それらのメソッドは自身の操作に関するものが中心でそこから層の責務が漏出してしまう恐れはないので層の受け渡しで利用しても問題ありません。  

他にも層を跨ぐデータについてはもう少し掘り下げたい点があるため、記事の最後に[補論](#クリーンアーキテクチャにおける層を跨ぐデータ構造がシンプルであるとは)として取り上げました。  

### ルール3:データフローは一方向
これはクリーンアーキテクチャの原文に明言されているわけではないのですが、開発時には自然と守るようにしますし、またクリーンアーキテクチャに限らず設計において重要であるためルールとして加えました。  

アプリケーションのデータフローを円図に沿ってたどっていくと、入力は円の外側のUIから起こり、その処理のため内側のBusiness Logicに入りそして再びその結果は出力先であるUIに向かうため円の外->内->外と流れていて一見すると一方向になっていないように思えます。  
しかしそれはあの円がデータフローではなく依存関係に着目して作られているからであって実際のところデータフローも一方向となっています。
それを示すのがクリーンアーキテクチャの右下の図です。(実際には依存関係も示した図なのですがここではデータフローについてのみ触れます)    

図が表しているようにデータフローはContrller->UseCase(Applciation)->Presenterとなっており、これらは円図で見ると外->内->外ではありますが実際には最初に外から内へ入る時と、そのあと内から外へ出ていく時の経路が異なるため実質的にデータのフローは一方向となっているのです。  

これはMVCのControllerやMVPのPresenter等、一つのコンポーネントが画面の入出力を担当している場合も同じです。  
これらのコンポーネントでは一つの中に入出力の責務がありながらも、実際のコード上では入力と出力の責務が交わらないように設計されていることが前提となっています。 

以下イメージ図


## ルールを守るためのテクニック
クリーンアーキテクチャについていろいろと見てきましたが、最重要ルールと言える「円の内側が外側についてなにも知らない」を守りながらアプリケーションをどう実現するのかについてまだ触れていません。    
アプリケーションは技術的にInfraに依存しているはずなので円の内から外への依存がないのは不可解なことのように思えます。  
ここではこの問題をどう解決すればよいか説明していきます。  

### 依存関係逆転の原則(Dependency&nbsp;Inversion&nbsp;Principle)
これには依存関係逆転の原則(Dependency Inversion Principle)というテクニックを利用します。    
「依存関係逆転」と聞くと難しそうに聞こえるのですが、要はあるコンポーネントに依存するとき実体型ではなく抽象型(Swiftでいうプロトコル)に依存するというだけのことです。  
なぜプロトコルに依存することで層の外側から内側の依存のみになるのかというと、実体型による依存関係では利用する側(上位)の層から利用される側(下位)の層への依存となりますが<sup>[*2](#footnote2)</sup>、プロトコルを利用した依存関係の場合はそのプロトコルは利用される側の層ではなく利用する側の層に属していると考えられるからです。  
そうすると利用するコンポーネントも利用されるコンポーネントも利用する側の層にあるプロトコル依存しているため依存方向が逆転しています。  

もう少しわかりやすく説明するために以下で簡単な例を示します。  
### 依存関係逆転の例
クラスAがクラスBを利用しているとします。  
その場合それらの依存関係はA->Bとなり利用する側のAが利用される側のBに依存しています。  
図
ここでこれらに依存関係逆転の原則を適用するためクラスBの要件を満たした「BType」というプロトコルを定義し、クラスAはBクラスを直接利用するのではなくBTypeプロトコルを利用するようにします。  
この時BTypeプロトコルはBクラスの要件を全て満たしているのでAクラスはBクラスを利用していた時と同じようにBTypeプロトコルを利用できます。  
またクラスBはBTypeプロトコルに準拠するようにします。(堅苦しいですが、Swiftではある実体型にプロトコルを適用する場合「プロトコルに準拠する」とよく表現します。)  
そうなるとクラスAはBTypeプロトコルを利用しBクラスもBTypeプロトコルに準拠するため、先程のA->Bで表していた依存関係はA->BType<-Bに変化していることがわかります。(ここではプロトコルに準拠することも一種の依存であるとします)  
そしてBTypeプロトコルは利用する側であるクラスAの層に属していると捉えられているため、先ほどは利用する側から利用される側へ(A->B)の依存であった関係がプログラミング的には利用される側から利用する側への依存に逆転したことになります。  
図
これがプロトコルを利用した依存関係の構築が「依存関係逆転」と言われている理由であり、クリーンアーキテクチャではこの原則を用いて層の内から外への依存を行わないようにします。  

### プロトコルを利用することでプログラムの変更を行いやすくなる
プロトコルを利用した依存が「依存関係の逆転」と言われているから内から外の依存はないというのはただの概念的な操作であって、レトリックにしかすぎないと思う人もいるかもしれません。  
ただここでもう一度思い返して欲しいのですが、クリーンアーキテクチャで外から内への依存のみ許している理由は以下の二つです。  
- Business Logicを外側の層から切り離す
- テストを容易にする

実体型を利用した依存関係では満たすことはできない上記の要件をプロトコルを利用することによってしっかり満たすことができるようになっています。  
Infra側ではInterface Adapters層のコンポーネントが利用するのは実体型としてのInfraクラスではなくInfraの要件を満たしたプロトコルであるため、Infraそのものに依存することはなくなり実際のInfraクラスが完成していなくともプロトコルに準拠した仮コンポーネントを使ってテスト可能になります。  
UIでも同様にデザインやUIプログラムが完成していなくともコンソールなどに出力して値が正しいか確認できます。  

### 依存の方向関係なくプロトコルは積極的に利用する
内から外への依存を行いたいときのテクニックとして依存関係逆転の原則を紹介しましたが、実際には外から内への依存でも積極的にプロトコルを利用することをオススメします。  
例えばUIのテストを行いたいときなど、出力値が正しいかどうかではなく出力値を表示するレイアウトが正しいか確認したいといった場合があります。    
こうした場合にはUIからViewModelやPreseterなどの実体型に依存することなくプロトコルに依存することで仮コンポーネントを利用してテストが可能になります。  
  
このように依存の方向関係なくプロトコルを利用した依存関係を構築するとテストが行いやすくなるため積極的に使っていくことをオススメします。  
  
他にも依存とプロトコルについてはいくつか書きたいことがあったので記事最後にSwiftのプロトコルという補論を書いています。  

### 内から外へのデータフローを実現する他の方法
円の内側が外側の仕様を知らずに処理する他の方法としてクロージャを完了時の処理(completion handler)として利用する方法等があります。
しかしcompletion handlerで内から外の依存を解決可能なのはUI等外側の層から処理の呼び出しを行う場合のみであって、Application/Domain層からInfra側への呼び出し等内から外へ処理を呼び出す場合はcompletion handlerを利用したとしてもどちらにせよプロトコルを利用する必要があります。  

コード例

## クリーンアーキテクチャにある誤解
ネット上でiOSにおけるクリーンアーキテクチャを調べると大きく2点ほど誤解されている箇所があるように思います。  
クリーンアーキテクチャの説明の最後にそれらについて説明します。    

### 1. Entityに関する誤解
  
### EntityはDomain層
ネットで調べているとEntityがData層であるというような内容の記事がありますが、クリーンアーキテクチャにおけるEntityはData層ではなくDomain層です。  
EntityをData層としてしまうとあの円図の中心はData層ということになり、ビジネスロジックを他から切り離すという目的とは異なってしまいます。        
そうなると各層の質的な連続性、クリーンアーキテクチャの主張の論理的な一貫性が失われてしまいクリーンアーキテクチャが何を意味しているのかわからなくなってしまうでしょう。      
図

恐らくEntityをData層とする主張はデータベースの文脈におけるエンティティと混同しているのだと思います。  
データベースの文脈ではエンティティはデータベース上で操作するデータのまとまりを指し、恐らくこの用法がプログラミングの世界で一番広く浸透しています。    
ただ先ほどもいった通りEntityをData層と解釈してしまうと、クリーンアーキテクチャの主張と根本的に矛盾してしまうため注意が必要です。  

### Entityはビジネスルール
Entityに関してもう一つ誤解があります。  
Entityは単純なデータ型として紹介されていることがありますが、そうではなくビジネスルールを指しておりロジックを含んでいます。  
これはクリーンアーキテクチャのEntityの定義を見ればわかります。  
>Entities encapsulate Enterprise wide business rules.   
>An entity can be an object with methods, or it can be a set of data structures and functions.  
>  
>意訳  
>エンティティは事業のビジネスルールである。  
>エンティティはメソッドをもったオブジェクト、もしくはデータ構造と関数の集まりである。  

このようにクリーンアーキテクチャにおけるEntityはロジックを含んだビジネスルールをカプセル化したものです。  

この誤解を生んでしまう原因は先ほどよりも少し複雑です。         
既にクリーンアーキテクチャのEntityがなんであるかは説明できたので詳細は省きますが、クリーンアーキテクチャにおけるEntityは先程のデータベースの文脈におけるEntityに加え、ドメイン駆動開発におけるEntityともVIPERアーキテクチャのEntityとも異なるからです。  
特にクリーンアーキテクチャをiOSの開発環境で実践しやすいように最適化したVIPERアーキテクチャのEntityとクリーンアーキテクチャのEntityで意味が異なるのは誤解しやすいなと感じます。(ちなみにVIPERの
エンティティもData層ではないことは強調されており、それはクリーンアーキテクチャのEntityと同じです。)  


### 2. Interface Adapter層の誤解
次にInterface Adapter層関しての誤解を説明します。  
### Business Logic層のデータをUI層のデータ形式へ変換するのはUI側のInterface Adapters層の責務
最初にクリーンアーキテクチャにおいてApplication層であるUseCase内でTranslatorというデータ変換用のコンポーネントを利用してUI用のデータ形式に変換するという内容の記事がいくつかありますが、これは誤りだと思います。      
既に[記事内](#Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる)でも説明しましたが、Applicationのデータ形式をUIのデータ形式に変換するのはInterface Adapters層の責務だからです。    

Interface Adapter層の役割を原文に沿いながら再度説明します。  
原文のInterface Adapter層の説明では
>The software in this layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency  
>  
>意訳
>この層(Interface Adapter)はApplication層もしくはDomain層のデータを最外層に最適な形式に変換することである。
  
とBusiness Logicのデータ形式を最外層に変換するのが役割だと述べたあとに
>Also in this layer is any other adapter necessary to convert data from some external form to the internal form used by the use cases and entities  
>
>意訳  
>またこの層(Interface Adapter)では最外層のデータを内側のApplication層やDomain層に最適な形式に変換する。　　

と最外層のデータ形式をBusiness Logicに最適な形に変換するとも書かれており、その方向にかかわらず内と外の層の間のデータ形式の変換を役割としているのがわかります。      

そしてクリーンアーキテクチャではこうした異なる層へのデータ変換はInterface Adapter層に閉じ込められているべきです。(見方によればApplication層内でDomain層のデータをApplication層データに変換しているといえますが、Application層でDomainデータを直接扱うことは許容されておりここでいう「データ変換」とは明らかに異質です。)   


もしUI層へのデータ変換の責務をApplication層であるUseCase(ここでいうTranslatoor)に置いた場合、UseCaseはUIの仕様を知らないことには定義・実装できないことになりクリーンアーキテクチャの[円の内側の層は外側の層について何も知らない](#ルール1\:円の内側の層は外側の層については知らない何も知らないし、影響も受けない)というルールを破ってしまいます。  
またその場合はUIの仕様に変更があった際にはUseCase側でも変更が必要であるため**外側の層の変更の影響を内側の層は受ける**ことにもつながります。  


#### Infra層のデータをDomain/Application層のデータ形式に変換するのはInfra側のInterface Adapters層の責務
Interface Adapters層ではInfra側でもよく見かける誤解があります。
#### Infra層でDomainオブジェクト型のデータを返すのは誤り
ここで指摘しているのはInfra層であるWebAPIクライアント等でDomainオブジェクトを扱っているケースです。  
クリーンアーキテクチャの記事でDomainオブジェクトをInfraで操作する際、Infraが直接Domain層の型でオブジェクトを出力するのを時々見かけます。  
クリーンアーキテクチャのルールでは円の外側の層が内側の層を知っていること自体は問題としていませんが、それでも必要がなければ層同士の関心は切り離されていた方が良いですし、先ほども述べた通り異なる層へのデータ変換はInterface Adapter層に閉じ込められているべきです。  
実際今回指摘しているケースではInfra層とBusinness Logic層の関心の分離が守られていないためにコードが冗長化して変更に弱い設計になってしまっています。  

ここではInfra層とBusinness Logic層が分離できていないことでどういう問題が起きてしまうのか具体例を用いて説明していきます。  
#### Infra(Data)層でBusiness Logic層のデータを出力する誤った例 
前置きとして[依存関係逆転](#依存関係逆転の原則(Dependency&nbsp;Inversion&nbsp;Principle))ではプロトコルはそれを利用する側(上位)の層に属すると説明しましたが、論旨とは関係ないためここではプロトコルもそれに準拠する(利用される)側の層に属するものとして話をします。  
またInfra(Data)層でデータ操作を行うコンポーネントをデータクライアントと表現します。

ObjectAというDomain層のオブジェクトをInfraを通して操作するためにObjectARepositoryを定義しているとします。  
今回指摘しているケースはObjectARepository内で利用するデータクライアントがObjectAを返しているような設計です。  
コードでいうと以下のようになります。(ここで同期・非同期は論旨とは関係ないので、Infraが出力するデータはシンプルに返り値で返されるようにしています。)  

Data層側のコード
```
protocol ObjectADataClientType {
   func fetch() -> ObjectA
}

class ObjectADataClient: ObjectADataClientType {

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```

Repository(Interface Adapters)層側のコード
```
protocol ObjectARepositoryType {
   func fetch() -> ObjectA
}

class ObjectADataRepository: ObjectARepositoryType {

   private let dataClient: ObjectADataClientType
   
   init(dataClient: ObjectADataClientType) {
      self.dataClient = dataClient
   }

   func fetch() -> ObjectA {
      return self.dataClient.fetch()
   }
}

```

上のコード例みてみるとInterface Adapters層のObjectARepositoryだけなく、Data層であるObjectADataClientもDomain層のObjectAを返しています。  
このようにData層がDomain層のオブジェクトを返す設計だとData層はDomain層について知らなければ定義・実装できないため、クリーンアーキテクチャの[Infra層はApplication/Domain層から独立している](#クリーンアーキテクチャの特徴)という特徴を満たせていません。  

またObjectADataClientTypeとObjectARepositoryTypeを比較すると両者ともにObjectAを取得していて機能が重複しており、リポジトリはデータクライアントのメソッドを呼び出しているだけで自身は何の処理もしていないことがわかります。      
コード例


#### Data層にDomain層の事情を持ち込むことでData層が肥大化する
そして上記ような設計がアプリケーション全体に及んだ場合、Data層が肥大化します。(そもそもDomainオブジェクトと切り離されていないデータアクセス処理の集まりをData層と言って良いのかわかりませんが、ここではそういうことで話を進めます。)  
仮にあるアプリケーションでObjectA〜Zまでの26のオブジェクトをリポジトリで操作するとします。  
その場合先ほどの設計に沿った形で開発するとObjectA〜Zの一つ一つのオブジェクトに対して、リポジトリとデータクライアントの両方でプロトコルと実体型を定義・実装しなければなりません。  
またこれらのDomainオブジェクトのどれかに仕様変更が起こった場合にも両方に対して変更を適用する必要があります。  
リポジトリが実質的に何の処理を行なっていないことを考えるとこの設計はあまりにも冗長なように感じます。  
図

もちろん対応するリポジトリとデータクライアントの出力する値は必ずしも同じではないため、実際のアプリケーションが完全に上記のような構成になるとは限りません。  
ただどちらにしてもDomainオブジェクト型毎にデータクライアントクラスを定義しているとData層はBusiness Logic層から独立できておらず、複数のデータクライアントクラス(もしくはメソッド)が必要であるのは同じです。    
この冗長さを回避するためにはInfra(Data)層をBusiness Logic層から切り離す必要があります。  

#### Infra層とBusiness Logic層を切り離した設計
Infra(Data)層をBusiness Logic層から切り離すためにはまず、Data層が出力するデータ形式は基本的にSwiftのData型(そうでなければIntやString等Swiftのプリミティブ型)である必要があります。    
そうするとData-Domain間のデータ変換の役割はリポジトリが担うようになり、冗長で無意味なコンポーネントではなくなります。  

またデータクライアントは可能な限り集約するべきです。  
ここでいう「集約」とは、例えばData層でWebAPIを利用する場合にはコンポーネントを操作対象毎に定義・実装を行うのではなく汎用的なWeb通信のインターフェースに統一することを意味しています。    
データクライアントをまとめることで操作対象毎にリポジトリとデータクライアントを定義・実装する手間がなくなります。  
以下がコード例です。(この例でも論旨とは関係ないため出力するデータは返り値で返されるものとし、またメソッドのパラメーターも正確ではありません。)

Data層側のコード
```
protocol WebAPIClientType {
   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data
}

class WebAPIClient: ObjectADataClientType {

   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data {
         // 引数で指定されたURLと通信を行いデータを取得する処理
         ...
         return 通信で取得したData
    }
}

```
- データクライアントの出力をData型にして、Data層からDomain知識を切り離す
- その上でデータクライアントコンポーネントを集約化する  

以上2点を注意することで複数のリポジトリからデータクライアントを再利用する設計になるためプログラムの冗長さがなくなりました。  
またデータクライアントを利用してどのデータを操作するのかはリポジトリが呼び出し時にパラメーターを通して指定するようになるので、データクライアント自身はDomainやApplicationオブジェクトから分離されています。  

変更後の設計を図で示すとこんな感じです。  

先ほどと比べてData層のコンポーネントの数が大きく減ったのがわかると思います。  
もちろんWebAPIとデータベースなどInfraの機構毎にプロトコルを別に定義する必要がありますが、それは各Infra機構でインターフェースが異なることを考えれば致し方ありません。    

Data層ではそのビジネスロジック固有の事情から独立するように設計しましょう。  
そうすることで関心の分離が保たれて、Data層の肥大化が避けられます。  

補足:
ちなみにデータクライアントでの出力は基本Data型と述べましたが、設計次第ではDomainやApplicationオブジェクトを出力することも可能です。  
例えば以下のようにジェネリクスを利用してリポジトリ側でデータクライアントの出力型を指定できる設計であれば、データクライアントはDomainやApplication層に関知しているわけではないため問題ありません。  

コード例

Repositoryに関してはもう少し取り上げたい内容があったため、記事の最後に補論Repositoryを書きました。    

## レイヤードアーキテクチャ+クリーンアーキテクチャ+@で設計についてまとめる
前回の記事からレイヤードアーキテクチャとクリーンアーキテクチャを通して設計というものをみてきました。  
ここではそれらと@を踏まえて設計についての考えをまとめたいと思います。  

### 1.設計とは関係性を構築することである
これは前回の記事で説明しました。  
アプリケーション設計とはアプリケーション内の関係を構築することであり、良い設計を考えるとは開発者にとって作業しやすい形でアプリケーション内の関係を構築することになります。  

### 2.責務によって分割し、それらを単純な依存関係により組み合わせる
関係の構築のためレイヤードアーキテクチャではアプリケーションを責務によって層として分割し、それらが単一方向の依存関係になることを定義しました。  
このように責務によって分割しそれらが単純な関係で連携し合うようにすることで、開発者はアプリケーションを特定の目的を持ったプログラムの集合体として捉えることができるため、アプリケーションコードはより具体的になります。    
また責務の分割は関連性の高いコードをまとめて(高凝集)関連性の低い(ない)コードを分離する(疎結合)ので、プログラマは自身が現在担当している責務に関係するコードにだけ集中して開発を行うことができます。(関心の分離)
### 3.データフローは一方向
データフローも開発の重要な要素です。    
データフローが一方向になっていることでプログラムの流れを追いやすくなり、コードの可読性が上がります。  
レイヤードアーキテクチャの記事ではデータフローに関して直接言及しませんでしたが、実際にはレイヤードアーキテクチャも一方向のデータフローを前提としていると思います。  

レイヤードアーキテクチャのデータフローのイメージ
### 4.開発事情を考慮する
本記事ではクリーンアーキテクチャについて説明してきましたが、その内容を一言でまとめると**クリーンアーキテクチャは実際の開発事情を考慮してレイヤードアーキテクチャを再構築したもの**であると言えると思います。  
[記事内](#クリーンアーキテクチャは現実の開発状況をより反映させている)でも触れたように、開発状況を踏まえてクリーンアーキテクチャはビジネスロジックを中心にプログラムを構成しています。  
このように実際のサービス仕様に該当するビジネスロジックを中心に置くことで、プロダクトの変化にプログラム側が柔軟に対応できるようになり開発効率が上がります。  

改めて言葉にすると当たり前ではあるのですが、このように設計を考える際には現実の開発事情を踏まえた上で論理を組み立てることが重要になります。    

### 5.データフローの蓄積による状態変化に考慮する
設計についてまとめるに当たり、1~4の内容に加えてあと一つ考慮しなければいけない点があると思います。  
それはデータフローの蓄積です。  
ここまでの設計に関する話ではどれもデータフローについては深く取り上げず、ある一つの入力から出力までのデータの流れを前提として話をしていました。  
しかし実際に私たちがUI上で触れるアプリケーションはいくつものデータフローの積み重ねによって成り立っており、プログラム上でもそれを考慮しながら設計することは重要です。    
実際に設計にデータフローの蓄積の視点を取り入れることで得られるメリットは以下2点だと思います。      
1. 複数画面での状態の共有が容易になる
2. アプリケーション全体のデータフローの統一性が高まる
それぞれの詳細はここでは省略しますが、このような特徴はアプリケーションのUX、プログラムの質の向上につながります。(詳細は補論「データフローの蓄積を考える意味」で書きました。)  

私たちの身近なところでこれを実践しているのはFlux、Reduxでしょう。    
FluxやReduxといったアーキテクチャではAction、Store(State)コンポーネント等を主要コンポーネントとすることでアプリケーションレベルでデータフローが統一化され、またデータフローの蓄積によって生成される状態の管理を可能にしています。    

設計の際このデータフローとその蓄積という二つの時間の視点を踏まえるというのはアプリ開発では概念として確立していないように感じますが、私が恣意的にこの2つの視点を挙げているわけではありません。(ただ概念として確立していなくとも局所的には開発の際自然と実践していると思います。)  
他の分野、ある対象を考察、モデリングしようとする時にこの2つを踏まえて考えるのは一般的な考えだと思います。    
例えば経済学では経済的事象を一定期間の経済活動の成果を指すフローと過去からのフローの蓄積をストックという二つの視点から説明していきますし、他の社会系の分野でも現象・構造を研究するために共時・通時という言葉をよく使います。(共時・通時はそれぞれ経済のフロー・ストック、つまりデータフローとその蓄積と同じと捉えて問題ありません。)  
またそうした専門分野に目を向けなくても、「静」と「動」、もしくは「ある切り取られた一点」と「時間の変化」の2つの視点から物事を考えるのはよくあることではないでしょうか。  

クリーンアーキテクチャにおいてこのデータフローの蓄積の視点が取り入れられていない原因は恐らく当時の開発環境にあったと思います。  
クリーンアーキテクチャ登場時Web・モバイルアプリケーションの規模やハードウェアのメモリの容量も今ほど大きくなく、そのため状態の管理はアプリケーションレベルで考えるものではなく画面単位もしくは局所的に行うことが基本だったのではないでしょうか。  
しかし現代的なアプリケーションを設計しようとした場合データフローの蓄積の視点を取り入れることは必須なように思います。  


### アプリケーション設計とは
設計に関する要点を5点述べました。  
アプリケーション設計を簡単に言ってしまうと、それは上記の4と5を考慮しながら1~3の作業をマクロからミクロに至るまで繰り返すことだと言えると思います。  
この作業を繰り返すことで、アプリケーションはレイヤー(層)->モジュール->コンポーネントと粒度を細かくしていき、細部にまで配慮が行き届いた開発しやすいプログラムになっていきます。  
そしてこの一連の記事の目的であるスケールしやすいアーキテクチャとは上記のレイヤー・モジュールで破壊的な変更が起きないアプリケーション構造と言って良いと思います。    
日々追加されるアプリケーションの変更の中アプリケーションの隅々まで完璧に設計することは現実的ではありませんが、しかし同時に既に開発が始まっている中レイヤー・モジュールといった上位の設計から見直すことはとても時間も労力もかかる作業です。  
そのため本記事ではレイヤー・モジュールを中心に汎用性・柔軟性のあるアプリケーションアーキテクチャを探求していきます。  
前記事のレイヤードアーキテクチャ、本記事のクリーンアーキテクチャは設計の概要を説明していたと同時にこのレイヤーに関する設計について説明していた記事だと言えます。
次回以降はここで得られたレイヤーを踏まえながらモジュールについて考察していきます。  

## 補論1:クリーンアーキテクチャにおける層を跨ぐデータ構造がシンプルであるとは
本記事内で[層を跨ぐデータ構造はシンプルである必要がある](#層をまたぐオブジェクトはシンプルなデータ構造であること)と説明しました。  
しかしそもそも何をもってシンプルであると言えるのか曖昧なためここではそれについて補足します。  
### シンプルなデータ構造とは責務が漏出しないデータ構造
結論から言うと一般的に「シンプル」であるということは余計なものがないという意味で使われますが、ここでいう「シンプル」とは層の責務が漏出してしまうようなメソッドをもっていないデータ構造を指し、データとして一切余計なものがないという意味ではありません。    

具体例を用いて説明します。      
ある写真アプリのプログラムではユーザーを示すUser型と写真を示すPhoto型を定義していて、またアプリ機能の一つとしてあるユーザーの持つ写真のタイトルをリストで表示があるとします。          
必要な部分以外省略していますが、User型とPhoto型はそれぞれ以下の通りです。  

もしこの機能をクリーンアーキテクチャに沿って開発しようとすればControllerからユーザーの写真を取得するUseCaseを呼び出しその結果をPresenterに渡すという形式になり、この場合層を跨ぐデータはContrller->UseCaseとUseCase->Presenterの2箇所に存在します。          
このうちContrller->UseCaseで層を跨ぐのはUseCaseにパラメーターとして渡すデータです。  
一般的にはこのパラメーターのデータ型はUserのID型となるでしょう。  
このパラメーターはどのUserの写真を取得するか識別するためだけに利用されるため、User型をそのまま渡す必要はなくUser.ID型で十分です。        
それに対してUseCase->Presenterで渡されるデータはPhotoの配列です。  
こちらは先程と異なりPresenterで必要なのは写真のタイトル(Photo.title)だけなのに関わらず、Photoごと配列で渡されます。  
そのためPresenterではUseCaseから渡されたPhotoの配列の内titleだけを抽出します。        

これら2つのデータを比較すると、UseCase->Presenterのデータだけが余計な情報を持っています。    
必要以上の情報を持っているということは層を跨ぐデータはシンプルであるというルールを破ってしまっているように思えますが、なぜこのような状況が起こるのでしょうか？  

その理由は先程のUseCaseをコードで見てみるとわかります。     
コード例  
先程の層を跨ぐ2つのデータはUseCaseメソッドのパラメータとその出力であり両方ともUseCase(Application層)の設計の一部です。米印    
そしてこのうちパラメーターはUseCaseが自身の処理で利用するためどの型を受け取るべきなのかはわかりますが、それに対して出力がどう利用されるのかについてはUseCase自身は把握できません。  
そのためUseCase->Presenterのデータは利用するPresenterにとって余分なデータを持っている場合がありますが、これは設計上致し方ないことです。  

もしUseCaseからPresenterに渡される全てのデータの無駄をなくそうとするならばUseCaseはUI側の仕様を把握する必要があり、クリーンアーキテクチャの外側の層の影響を受けないというルールを破ってしまいます。  
またそのような全てのUIの要求にフィットするUseCaseメソッドを一つ一つ定義・実装しようとするならば、数が膨大になり層を跨ぐデータは無駄なくあらゆる面でシンプルになるかもしれませんがApplication層全体のプログラムは複雑化、肥大化していくでしょう。    


層を跨ぐデータをシンプルにする目的は層同士の関心の分離です。  
そのことを考えると上の例を見てもわかる通り層を跨ぐデータに求められるシンプルさとは要求に対して一才無駄がないことではなく、責務が他の層に漏れてしまうような構造を指していることがわかると思います。米印  

このように「シンプル」という言葉だけに着目すると誤解してしまいそうになりますが、その背景にある「関心の分離」に注意を払いながら設計を行う必要があります。  

### 層を跨ぐデータ構造をどう設計するかはケースバイケース
ちなみに他の層へ渡すデータをどのように設計するかは個々のプロダクトや設計者によります。  
例えば先程はPhoto型の配列で渡しましたが、場合によっては以下のようにPhotoは各Userのプロパティとして生やして単体では利用しないということもありえます。  
その場合UseCase->Presenterの出力はPhotoの配列ではなくUser型になります。(その場合User.IDを引数にUserを取得するのはおかしいので全体の設計も変わるでしょう)  
このように出力されるデータ型をどうするかはそのアプリケーションの提供している機能やそれらを踏まえた設計者の判断によって異なるため、これと言った正解があるわけではありません。  

### 層を跨ぐデータ型は自身の層の仕様を元に設計されるが、Interface Adapters層は例外
しかしInterface Adapters層だけは例外です。  
その理由は[記事内](#しかしInterface&nbsp;Adapters層は例外)書いたクリーンアーキテクチャの層の中でInterface Adapters層だけは外の層の影響を受ける理由と同じです。   
[先程の例のように](#シンプルなデータ構造とは責務が漏出しないデータ構造)、通常は他の層へ渡すデータ型は出力する層自身の仕様に基づいて設計されるべきです。  
しかしInterface Adapters層は受け取ったデータ型を渡す先の層に合わせて変換・出力するためそのデータ型は出力先の仕様に基づいて設計されます。  
これはInterface Adaptersが他の層と異なり主体的な目的をもたずただ仲介役として振る舞う性質によるものです。    

## 補論2:Swiftのプロトコル
本文内でテストしやすくなるという理由で[依存方向関係なくプロトコルを使った依存を利用した方が良い](#依存の方向関係なくプロトコルは積極的に利用する)と述べました。   
ここではそれについて補足します。    
### Protocol Oriented Programming
恐らくこれに関しては「依存関係構築時のプロトコルの利用」という文脈で語るよりも、より一般的なProtocol Oriented Programming(以下POPと省略)の文脈で説明した方がわかりやすいと思うのでPOPの話から始めます。    
POPとは所謂プロトコル指向プログラミングを意味しています。  
POPはSwiftを特徴づける概念でありiOS等Swiftを使っているプログラマーであればよく耳にする言葉なのではないでしょうか。        
しかしよく聞く言葉あるにもかかわらず、このPOPが具体的に何を意味しているのかについてはあまり理解されていないように思います。    
POPはただ積極的にプロトコルを利用することを推奨している概念ではありません。  
Swiftで提唱されたPOPですが、他の多くのプログラミング言語もSwiftのプロトコルに当たる言語機能は既に持っています。  
そのためPOPがただ積極的にプロトコルを利用するという意味だけならば、なぜ他言語でも既にあった機能を「POP」という大きな言葉を使いながら推奨しているのか説明できません。米印     

### POPとはSwiftにおけるポリモーフィズム実現の手段
ではPOPとはどういう意味なのかというと、私は[このオンライン書籍](https://heart-of-swift.github.io/protocol-oriented-programming/)の説明がすごいわかりやすいと思います。(余談ですがこの書籍ではプロトコル以外にもSwiftに関して面白い考察がなされているのでSwiftの基礎を一通り学んだ人にオススメです。また書籍と表現していますが無料です。)  
その定義を簡略に説明するとPOPはOOP(Object Oriented Programming)と対置関係にある概念です。  
複数の型を同様に扱いたい等、型を抽象化したい(ポリモーフィズム)場合、OOPではオブジェクトの継承を利用して実現することを推奨していました。  
しかしSwiftはクラスではなく値型と言われる構造体や列挙型を積極的に利用するプログラミングスタイルを特徴としており、この値型に継承機能はありません。  
そこでオブジェクトの継承を利用せずポリモーフィズムを実現する方法としてプロトコルを利用したプログラミングスタイルを提唱しています。  
このようにPOPとはオブジェクトではなく値型を主軸に考えるSwiftにおいて、プロトコルを利用してポリモーフィズムを実現するプログラミングスタイルを指しています。米印 米印2    
参考元ではSwiftの公式ドキュメントには何がProtocol-oriented Programming なのか明確には述べられていないと書かれており解釈の一つとして紹介していますが、POPがOOPを意識して生まれた概念であることはその名前からも明らかでありPOPの概要が上記の意味であることは間違いないと思います。    

### 依存関係でプロトコルを利用する目的
そして依存関係構築の際にプロトコルを利用するのもPOPの一部であり、その目的は同様に型の抽象化です。    

この場合における目的をより具体的に表すと以下3点になると思います。  
1. 開発時、実体型を差し替えて実装を変更したい
2. テストを行いたい
3. プログラム実行中、多義的な役割を担わせたい

このうち1と2は技術的には同義です。  
差し替えるコンポーネントが本番用なら1でテスト用なら2になるわけですが、これらは技術的には同義でも開発的には全く異なる役割になるので分けました。  
そして本記事で紹介したプロトコルの利用方法も1と2です。    
プロトコルという抽象型を利用して依存関係を構築し実体型に依存しないことで層の関心は分離され、またテストも容易になります。  
ただ3に関しては本記事では触れらていません。しかしこの3の用法こそ普段私たちが最もよくプロトコルを使う理由だと思います。  
3に当てはまるケースとしては例えばプログラム上で犬、猫、鳥、等複数の異なる実体型を動物型のように一つの型として利用したい場合です。  
コードは以下のようになります。  
このように共通の性質、振る舞いを持った複数の型にプロトコルを適用することで、柔軟なプログラミングが可能になります。  

### 依存関係でプロトコルを利用しない場合
依存関係構築の際プロトコルを利用する目的を説明しましたが、逆にいうと上記に該当しない場合の依存関係ではプロトコルを利用しても意味がありません。  
むしろ必要のないプロトコルを定義、利用することでそれぞれの型の意図が曖昧になってしまいプログラムの可読性が落ちてしまいます。    
ここでは依存関係の際プロトコルを利用する必要がないケースを紹介します。  
ただ留意点として紹介するどのケースにおいても先ほどの[依存関係でプロトコルを利用する目的](#依存関係でプロトコルを利用する目的)で挙げた
>3. プログラム実行中、多義的な役割を担わせたい
を実現する場合はプロトコルを利用する必要があります。  

#### 各層のデータオブジェクト
依存関係でプロトコルを利用しないケースとして各層のデータオブジェクトが挙げられます。  
依存関係においてプロトコルを利用する主な目的は層の関心分離、コンポーネントの差し替えを容易にすることです。  
しかしデータ型は基本的に層の外側にあるコンポーネントから依存されず、層内部のコンポーネントから依存されます。      
そのためデータ型に依存する際にプロトコルではなく実体型を利用したとしても層の関心の分離が破られることはありません。              
またデータ型は複雑なロジックを抱えていないので、実装の変更やテストのためにコンポーネントを差し替える必要性は低いです。  
大抵の場合、実装を変更したい時には実体型のコードをそのまま書き換えて問題ないと思います。      
例えば以下のようなPhoto型を利用してテストを行いたい場合は、データの値にテスト用のものを代入すれば十分でありわざわざプロトコルを利用して実体型を差し替える必要はありません。  

もちろん本記事でも触れたようにデータ型でも層を跨ぐものであれば層の関心を破る原因にはなります。  
しかしそれはデータ型の構造の問題であり、依存関係でプロトコルを利用するか実体型を利用するかという問題とは無関係です。      

#### Domain層オブジェクト
そして一般的にDomain層ではデータオブジェクトに限らず全てのオブジェクトでプロトコルを利用する必要はありません。  
その理由を端的に表現するのは少し難しいのですが、以下3つを要点として挙げました。  
1. Domainは円の中心にあり外側の層から依存されることしかないため、クリーンアーキテクチャの依存ルールを破らない
2. Domainは他の本番用コンポーネントと差し替える必要はない
3. Domainをテストコンポーネントとして利用しない

それぞれに関して説明していきますが、1に関してはそのままでDomainは円の中心にあるためプロトコルを利用しなくともクリーンアーキテクチャの依存ルールを破る恐れはありません。  
そして2について説明すると、一般的に本番用で実体型を差し替える必要があるコンポーネントは外部技術を利用しています。  
「機能は変更しないけど、他の外部技術を利用して実現したい」といった場合にプロトコルを使うことで他に影響を与えずにコードを変更することができます。    
ただDomainは外部技術には依存せず、純粋なプログラミング言語でのみ実装しているためコンポーネントを差し替える意味はありません。  
変更を行う場合は実体型をそのまま書き換えて問題ないと思います。  
最後の3に関してはDomainに関係してテストを行うコンポーネントとしてUseCaseとUIが想定されますが、その両者においてテストの際にDomainをテストコンポーネントとして利用する必要はありません。  
まずUseCaseはそもそもその性質から自身のテストを行う必要はありません。  
クリーンアーキテクチャのUseCaseの説明を見ると
>These use cases orchestrate the flow of data to and from the entities, and direct those entities to use their enterprise wide business rules to achieve the goals of the use case.
>
>意訳
>UseCaseはEntityを組み合わせて自身の目的を達成する  

となっており、基本的に他コンポーネントを組み合わせることが役割であり自身は複雑なロジックを抱えていません。  
そのため個々のDomainオブジェクトが正しく動作していれば、UseCaseのテストを行う必要はなくテスト用Domainコンポーネントの出番もありません。  
ちなみに本記事では触れませんでしたが、テスト設計の観点から言ってもアプリケーションのテストが必要な箇所を絞ることは非常に重要です。  
その意味でも基本的な設計方針としてUseCaseではテストが必要ないことを目指すべきであり、もしUseCaseでなにかしら複雑なロジックを抱えてしまっている場合は設計自体を見なした方が良さそうです。  
ただ中にはUseCaseでのテストを避けることが難しいケースもあります。  
例えばUseCaseの中で再帰的な処理を行っている場合はロジックとして複雑ではなくともヒューマンエラーを起こしている可能性は考えられるためテストした方が良いでしょう。  
しかしこの場合もわざわざDomainをテストコンポーネントに差し替える必要はないと思います。  

次にUIのテストに関しては、UIのレイアウトを確認したい等の場合にビジネスロジックをテストコンポーネントに差し替えてUIテストを行うということはありえます。  
しかしこの場合も以下のようにUseCaseをテストコンポーネントに差し替えるだけでUI側の要件は達成できるため、Domainまでテストコンポーネントに差し替える必要はありません。  

このようにDomain層のオブジェクトではクリーンアーキテクチャの依存ルールを破る恐れもコンポーネントを差し替える必要もないためプロトコル利用する必要はありません。  

```
補足:  
他にも外部技術は利用していないけどDomainが抱えているロジックが複雑だからプロトコルを利用したいという場合もあるかもしれません。    
ただ私は最初に挙げた多義的な役割を担わせたいという理由を除いてDomainではプロトコルを利用すべきではないと考えています。  
Domainはクリーンアーキテクチャの円の中心であるようにアプリケーションプログラムの核となる部分です。  
そのようなアプリケーションの屋台骨となるロジックやデータを扱うオブジェクトをプロトコル型を使って抽象化するということはプログラムの核心部分の設計が定まっていないということであり状態として不健全だと思います。  
人で言うならば素晴らしい信念を掲げつつも、その内実は全く定まっておらず時代や状況に応じて都合よくその内容を変えていくようなものでしょか。
```
本記事内で書いた通り層を跨いだ依存関係では基本的にコンポーネントを差し替え可能にすることで恩恵を得られるので積極的に使って行くべきです。  
しかしそれはここで書いた通り全ての依存関係でプロトコルを使うことを推奨しているわけではありません。 
依存関係


## Repository
ここではRepositoryに関していくつか説明します。  
### Repositoryのプロトコル(インターフェース)はDomain層、実体型はData層
タイトルの通りですが、レイヤードアーキテクチャのようにクリーンアーキテクチャのInterface Adaptersに該当する層が存在しない場合Repositoryのプロトコル(インターフェース)はDomain層、実体型は基本的にData層に属します。  
Repositoryは一般的にWebAPI、データベースを利用しますが、それらは内部実装としてインターフェース上では意識されません。  
そのため定義上においてはRepositoryはただDomainオブジェクトを操作するコンポーネントであり、そのプロトコルはDomain層に属することになります。  
それに対して実体型のRepositoryはWebAPIやデータベースを利用しながら実装されており、Data層に分類されます。  

### Repositoryとデータクライアントの出力で異なる場合があるのか
記事内の[Repositoryの設計に関する誤解](#Data層にDomain層の事情を持ち込むことでData層が肥大化する)を説明した箇所で、
>対応するリポジトリとデータクライアントの出力する値は必ずしも同じではない  

と書きましたが、なぜこのようなことが起こるのでしょうか?
  
その理由は詰まるところDomainとデータベースの設計の違いにあります。    
Domain層のオブジェクトを設計する際、私たちは純粋にそのサービスの観点からデータをどのような単位で扱いまたそれらをどのように繋げるか考えます。    
それに対してデータベースの設計ではサービスに加えてパフォーマンス等データベース特有の事情も考える必要があります。      
このようにDomainとデータベースではそれぞれ設計の基準が異なるため、結果的にDomainオブジェクトとデータベースのエンティティの単位も異なります。   
リポジトリとデータクライアントの出力する値が異なるのも同じ理由です。  
リポジトリとデータクライアントでは設計の視点が異なるため必ずしも出力が一対一で対応していることにはならず、場合によってはRepositoryの出力値を生成するために複数のWebAPIを利用する必要があります。  

### RepositoryとDAO
Repositoryと良く似ているコンポーネントにDAOというものがあります。  
ここではDAOとはなんなのか、そしてRepositoryとどのような関係であるのか説明します。  
DAOとはData Access Object略であり、技術的な詳細を内部実装として隠蔽しながらデータを操作を行うコンポーネントを指します。  
Repositoryも同様に詳細を隠蔽しながらデータを操作するコンポーネントであり、この意味でDAOとRepositoryは同じ役割を担っています。      
しかし設計の観点から考えるとこの2つは大きく異なります。  
その違いは大きく以下2点です。    
1. RepositoryはDomainオブジェクトの操作を対象としているのに対して、DAOはデータ操作全般を対象としている
2. RepositoryはDomain層とData層を切り離すことを目的としていてアプリケーションの層を意識したコンポーネントであるのに対して、DAOはデータ操作とそのメカニズムを切り離すことを目的としておりアプリケーションの層は意識されていない  

もちろん実際の開発ではDAOを利用によって「データ操作とそのメカニズムを切り離す」と同時に「層も切り離される」場合はあります。  
ただ少なくとも概念上ではDAOが関心があるのはデータ操作の技術でありアプリケーションの層ではありません。  

もともとRepositoryはアーキテクチャ設計、DAOはデザインパターンとそれぞれが登場する文脈が違います。  
そのため両者は機能的に似ていますが(もしく同じ)、その目的も異なっています。  

そしてこれはRepositoryとDAOが共存できることを意味しています。  
例えば先ほどの[Repositoryとデータクライアントの出力で異なる場合があるのか](#Repositoryとデータクライアントの出力で異なる場合があるのか)ではRepositoryの出力値を生成するために複数のWebAPIを利用する場合があると述べましたが、この時にRepository内でDAOを利用して複数のデータ操作し、最終的に一つのDomainオブジェクトを操作するということはありえます。  
実際に[Androidの公式ドキュメント](https://developer.android.com/jetpack/guide?hl=ja#addendum)ではRepository内でDAOを使っています。  

ちなみにDAOをクリーンアーキテクチャで利用した場合、DAOはData層ではなくInterface Adapters層となる可能性が高いです。(前提としてDomainオブジェクトの操作はRepositoryで行っているものとします) 
その理由はRepositoryに関する誤解で述べた通りData層はアプリケーション特有の事情からは独立しているべきだからです。  
DAOで操作する対象は層の中で独立して扱われるような意味のあるデータ型ではないかもしれません。  
ただそれでもそのデータはアプリケーションサービスになにかしら関係するデータであるはずです。    
そのためDAOは基本的にData層ではなくInterface Adapters層として扱うべきです。  

しかしこれに関しては他にもApplicationオブジェクトの操作するコンポーネントの命名をどうするかという問題もあります。  
私もこれに関してはDAOとするのかそれとも柔軟に解釈してRepositoryの仲間に入れてしまうのか、はたまた全く異なる名前を使うのかスッキリする答えを出せていません。  
  
  
  
  
  
## 参考：  
  
### 書籍  
- [ドメイン駆動設計](https://www.amazon.co.jp/エリック・エヴァンスのドメイン駆動設計-Architects’Archive-ソフトウェア開発の実践-エリック・エヴァンス/dp/4798121967/ref=asc_df_4798121967/?tag=jpgo-22&linkCode=df0&hvadid=295719984664&hvpos=&hvnetw=g&hvrand=3926308388276309968&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=1009283&hvtargid=pla-525481409888&psc=1&th=1&psc=1)  

### Web
- [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)([日本語訳](https://blog.tai2.net/the_clean_architecture.html))
- [VIPER](https://cheesecakelabs.com/blog/ios-project-architecture-using-viper/)
- [リポジトリとDAOの棲み分け方](https://blog.fukuchiharuki.me/entry/use-repository-and-dao-according-to-the-purpose)
- [Android公式アーキテクチャガイド](https://developer.android.com/jetpack/guide?hl=ja#addendum)
- [まだMVC,MVP,MVVMで消耗してるの？ iOS Clean Architectureについて](https://qiita.com/koutalou/items/07a4f9cf51a2d13e4cdc)

## 注釈文献
<a name="footnote1">*1</a>: この項の始めにあるFramework&Driversが外部技術であるという箇所と外部技術に依存しているという表現は矛盾しているような表現ですが、視点が異なっているだけです。  UIKitを例に出すとUIKitは内部でApple独自のレンダリング技術を使っているため外部技術に依存しているわけですが、他の層から見るとまさにそのUIKit自身が外部技術なわけです。

<a name="footnote2">*2</a>: ここでいう利用するとは実際にインスタンスを参照しているという意味であり、プロトコルに準拠していることは指していません。本来は括弧内で書いているように上位、下位と
表現することで十分だと思いますが、個人的にこれらの表現は淡白な割にどちらを上と見るかは捉え方次第で変わってしまうためあまり好きではなく利用する側、される側という表現しています。(ただ冒頭で説明したとり「利用する」とはなんであるのかも自明ではないため最適な表現ではなさそうですが...)


リポジトリとデータクライアントクラスの関係については補論RepositoryとDAOでもう少し詳しく取り上げました。  

