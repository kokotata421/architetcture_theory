
# iOSアプリでスケールしやすいアーキテクチャを考えてみた②-設計を理解するためのクリーンアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)**設計を理解するためのクリーンアーキテクチャ編←本記事**  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への準備編として設計の概観を理解するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  
また本記事はレイヤードアーキテクチャの知識を前提としていますので、レイヤードアーキテクチャがわからない方は前の記事から読むことをオススメします。  

## 前回までの内容と本記事の内容
初回である前回の記事ではスケールしやすいアーキテクチャを考えるためにクリーンアーキテクチャを通して設計概要を理解することを最初の目的としました。  
そしてクリーンアーキテクチャの前提知識のためにその原型とも言えるレイヤードアーキテクチャの理解を深めたのが前回までの内容です。

この記事ではいよいよクリーンアーキテクチャを学び、設計の全体像をより具体的に捉えたいと思います。

## 記事内の用語の表記ルール 
前回に引き続きアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。    

例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logicとし、InfrastructureはInfraと省略して表記します。  



## クリーンアーキテクチャとレイヤードアーキテクチャの共通点/相違点
まず前回学んだレイヤードアーキテクチャと今回学ぶクリーンアーキテクチャの共通点、そして相違点について整理することでレイヤードアーキテクチャを理解するために必要なポイントをまとめます。   
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>


前回の記事でレイヤードアーキテクチャの特徴が責務による層の分割と単一方向の依存関係による関心の分離であることを述べました。  
クリーンアーキテクチャでもそれは変わりません。    
円の中の一つ一つの色が層を示していて、また円内側の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格はつかめているといえます。  
ただ特徴は同じでもクリーンアーキテクチャではその層の分割と依存の方法が異なります。  
そのためクリーンアーキテクチャを理解するために層の分割と依存関係の詳細について見ていきたいと思うのですが、これらを理解することはクリーンアーキテクチャが円である理由を理解することと同じです。  
なので最初にクリーンアーキテクチャが円である理由を踏まえながら円の各層・依存関係について理解していきたいと思います。  

## Entities = Domain層 / Use Cases = Application層
クリーンアーキテクチャが円である理由を見ていきますが、その前に前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所があるのでそこから始めます。  
ちゃちゃっと終わらせるために結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層であり、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層です。   
最初にEntitiesから取り上げると円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」です。  
前回の記事でDomainとは「事業の知識・ルール」を意味していることを書きましたが、ここからEntitiesがDomainと同じであることがわかると思います。    
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesの方に書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要でしょう。

以後EntitiesはDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため

クリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか？  
実はその理由はレイヤードアーキテクチャの記事ですでに書いています。  
レイヤードアーキテクチャの記事のPresentation Domain Separation(以下PDSと表記)の説明でビジネスロジックを「アプリケーションプログラムの機能的中心」と表現しましたが、まさにこれがBusiness LogicであるDomainとApplicationが円の中心にいる理由です。  

もう少し具体的に示すと以下のようになります。  

1. サービスのアイディアを具体化したものがビジネスロジックのデータやロジックであり、ビジネスロジックなしではアプリケーションは成立しない。  
2. ビジネスロジックはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. ビジネスロジックは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

1については「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、プログラム化したものがDomain層であり、それをさらにアプリケーションとして提供するために書かれたコードがApplication層です。  
UI層はそのサービスをユーザーへ提供する窓口として存在し、Infraはそのサービスの実現のための手段として必要であって、ビジネスロジックなしにアプリケーションが生まれることはありません。    

(2について)またそれはビジネスロジックがアプリケーションの中で相対的に変わりづらい箇所であることも意味しています。(ここでいう「変更」はアプリケーションの仕様変更によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。)  
UIやInfraはBusiness Logicが変わることがなくてもUXや技術的なパフォーマンスの観点から変更することがあります。  
それに対してサービスの仕様が変更された場合はBusiness Logicも変更されますが、それに応じて必ずUIやInfraも変更を迫られることになります。  
このようにビジネスロジックはアプリケーションの機能的中心でサービスそのものであるため、ビジネスロジックの定義が変わる場合はそれに応じて他の層も変更する必要があります。  

3はどちらかというと「ビジネスロジックが円の中心である理由」というよりも「ビジネスロジックが他の層から切り離される理由」といった方が良いかもしれません。   
ただ純粋なプログラミング言語の定義によってのみ成立し外部技術に依存しない理由は、結局そのサービスの核心にあるため外部に依存していないという話につながります。 



そしてこうしたDomainとApplicationを中心に据えたクリーンアーキテクチャはレイヤードアーキテクチャと比べてより現実を反映させた設計であると言えます。  

レイヤードアーキテクチャは技術的な側面から依存関係を決定したため、技術的な基盤となるInfraがアプリケーションを支えていると捉え「UI->Application->Domain->Infra」という構造でした。  
それに対してクリーンアーキテクチャではアプリケーションの機能的中心であるビジネスロジックがアプリケーションを支えていると捉え、他の層がビジネスロジックに依存しています。  
クリーンアーキテクチャのこの構造はアプリケーション開発の実態をより正確に捉えています。  
アプリケーションは技術的にはインフラに依存していますが、サービス的に依存しているのはビジネスロジックであり開発はビジネスロジックを起点に動きます。  
そのためビジネスロジックを中心として他の層と切り離すことで、実務で発生する要件に柔軟かつ迅速に対応することが可能になるのです。  
私たちの日々の業務でも技術的にはインフラであるインターネットに依存しつつもその活動はビジネス的な事柄に依存していますが、それと同じです。

このようにクリーンアーキテクチャは技術的(レイヤードアーキテクチャ)には4層の中間に位置するビジネスロジックをアプリケーションの基盤と捉えそれを中心としたアプリケーション設計であり、それを
図で示すために円の形となっています。  

## Framework & Drivers層とInterface Adapter層
クリーンアーキテクチャがなぜ円なのかについて理解したところで、クリーンアーキテクチャの層でまだ説明されていないFrame & Drivers層とInterface Adapter層を説明していきます。  
### Framework & Drivers層
まず一番外にあるFrame & Drivers層から見ていきます。  
円を見てみるとこの層にはUI/Web/DataBase/Devices/External Interfacesとさまざまなものが表記されており、レイヤードアーキテクチャでいうUIとInfraが含まれていることになります。  
この層ではレイヤードアーキテクチャで異なる層であったUIとInfraが一つの層とされているわけですが、私たちは既に同様のケースを前回の記事でも見ています。  
PDS(以下)のPresentationです。  
PDSのPresentationにはUIのみならずInfraも含まれることを前回の記事で説明しましたが、クリーンアーキテクチャでも同様に同じ層として扱っているのはこの2つが以下の共通点を持っているためです。  
- 仕様の変更によってコードが変化しやすい
- 外部技術に依存している

こうした特徴を持った層に他の層が依存しているような設計だと、その層の変更による影響が他の層にも広がってしまい柔軟な開発を行うことが難しくなります。  
そのためクリーンアーキテクチャではこれらの特徴を持ったUI/Infra層を他の層から依存されないように同じ最外層に置いているのです。

もちろんクリーンアーキテクチャを採用した場合、UI層とInfra層はどこからも依存されないという共通の立ち位置にありながらも実際に提供している機能は大きく異なるため開発時には区別される側面もあります。  
このような層の分け方を見てもクリーンアーキテクチャはレイヤードアーキテクチャのようにアプリケーションにおいて提供している機能によって責務を捉えるのではなく、開発における性質というより抽象的な責務を捉えた設計であることがわかります。  


ちなみにFramework&Driversの意味はFrameworksはフレームワーク、つまりiOSのUIKit等パッケージ化された外部技術を指しており、DriversはIT用語でシステムに装着する外部装置を意味するのでこの層はビジネスロジックをアプリケーションプロダクトとして完成させるために必要な外部技術群と言えると思います。  

### Interface Adapter層

さて、残る一つはInterface Adaptersです。  
Interface Adapterという言葉だけ聞くとなにやら難しく感じてしまうのですが、簡単にいうとこの層は内側のBusiness Logicと外側のFramework&Drivers層を繋ぐための仲介役を担う層です。

円図ではこの層に該当するコンポーネントとしてController/Presenter/Gateway等が書かれていますが、身近なイメージで言えばこれらのうちControllerとPresenterがUIとビジネスロジックの、GatewayがBusiness LogicとInfraの仲介役を担っていると感じです。    
iOSMVCのControllerに当たるViewControllerもここに属し、円図でいうController/Presenterを担っています。    
ややこしいのですが、MVCアーキテクチャの文脈でいうControllerと円図に書いてあるControllerは意味が異なります。  
クリーンアーキテクチャでいうControllerは入力に関する処理を担当する、Presenterは出力に関する処理を担当するという意味で使われていますが、iOSMVCのControllerは画面の入出力に関する処理を担当しているのでこの図でいうControllerとPresenterの責務を両方含んでいます。(MVPのPresenterも同様に円図のControllerとPresenterを含んでいます)  
特定の文脈に依存しないControllerという言葉は入力の制御を意味しており、クリーンアーキテクチャではこの意味で使われています。  

このInterface Adapters層はレイヤードアーキテクチャでは存在していなかった層ですが、実際に開発で実践してみるとこの層の重要性に気づきます。  
層同士が連携して責務が混ざり合った箇所も一つの独立した層と捉えることで各層責務の純度が格段に上がるのです。
  
レイヤードアーキテクチャの機能的な責務による分割はあくまで理論上の話であって、実際のアプリケーションでは各層が連携して一つのアプリケーションとして動作するため複数の責務が交わって層の境界線が曖昧な部分が生まれます。  
例えばDomain層ではビジネス的な事柄が関心の対象なので、永続化機構でデータを更新するためのURLやそのためのデータ形式の変換に関心を向けるべきではありません。  
ただ一方でInfra層ではデータを永続化するという汎用的な責務を担ってはいるものの、特定のURLやそれに関する処理はそのアプリケーション(ドメイン)固有なものなのでInfra層がその責務を負うのはおかしなことです。  
このようにレイヤードアーキテクチャによる層の分割を実践しようとするとその層の境界線でどっちつかずな責務が発生してしまい、このような曖昧な責務の多くは妥協の末に利用している側(上の例ではDomainがInfraを利用しているのでDomain)に実装されるようになります。  
理論が現実と完全に合致しないことはしょうがないことではありますが、これではレイヤードアーキテクチャの目的である関心の分離が達成されないため良くありません。  
この問題を解決するためにクリーンアーキテクチャではレイヤードアーキテクチャの層が連携する責務も一つの独立した層として捉えました。  
こうすることで円の内側のビジネスロジックと外側のFramework & Drivers層に不純な責務が入らないことをアーキテクチャレベルで示し、またレイヤードアーキテクチャで不純な責務であった層の間の責務をデータの変換という「Interface Adapter層」として捉えることで明確化しており、各層の責務の純度を高く保つことができるようになります。  

ちなみに円図では表記されていませんが、開発でよく耳にするRepositoryコンポーネントもこのInterface Adapters層に入ります。  
Marin Flower氏の定義を引用するとRepositoryはDomain層とData層の仲介役であり、まさにInterface Adapter層のコンポーネントです。(引用文のdata mapping layersはData層と置き換えて問題ないと思います。)
>A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection
円図でいうとGatewaysの中に含まれていると考えればよいと思います。  

ちなみにGatewaysという名前はクラス名としてはあまり聞き慣れないと思いますが、これは単純に「内側と層と外側の層の仲介役」を意味しています。  
wikiでゲートウェイを調べるとネットワークの文脈において「プロトコルを変換して異なるネットワークプロトコル技術を用いたネットワークを相互接続する」機構であると説明されていますが、クリーンアーキテクチャ文脈でも同じで異なる層を接続する役目をもつコンポーネントの総称がGatewayであると捉えて良いでしょう。
つまりDomain層とData層のGatewayがRepositoryということになります。

私はInterfaceAdapter層のクラス名を命名するとき、できる限り具体的なControllerやRepositoryといった名前を使うようにしていますが適切な名前が見つからない時はGatewayの名前を使うようにしています。  
Gatewayは広範囲を示す名前ではありますが、プロジェクト内で乱用されるような名前ではなくそれだけでInterface Adapter層に属することは伝わると思うので「~Managerクラス」等より責務が明確で便利な単語だと思います。

## クリーンアーキテクチャの依存ルール
クリーンアーキテクチャでの依存は外側の層から内側の層であること、また外側の層の仕様は変わりやすく内側の層の仕様は変わりづらいことを説明しました。  
つまりクリーンアーキテクチャの依係は変更されやすい外側の層から変更されにくい内側の層へ向いており、こうすることで外側の層の変更のされやすさのアプリケーションへの影響を最小限に抑えています。  
ただ技術的に依存しているのはInfra層のはずなのに、Infra層がビジネスロジックに依存するということはどういうことなのでしょうか？  
これについてはこの後クリーンアーキテクチャを実践するためのルールを守るためのテクニックという節で説明します。  

## クリーンアーキテクチャの概要を一度整理する 
ここまででクリーンアーキテクチャの特徴は一通り触れられたと思いますが、レイヤードアーキテクチャがわかっているという前提のもと要所要所で説明を行うような形となりました。  
そのためこれまでの内容と重複する部分もありますが、ここで一度クリーンアーキテクチャの原文に沿った形でクリーンアーキテクチャの概要を整理したいと思います。  

### クリーンアーキテクチャの特徴  
①UI/WebAPI/データベースといった外部機能の変更を行いやすい。
コードを責務によりわけ、変更されやすいUI/Web API/データベースは円の外側に位置しておりどこからも依存されていない設計のためコードの変更がしやすいです。
②特定の外部技術に依存しない。
上とほぼ同義ですが、円の中心にある「Application/Domain」は純粋なデータ・ロジックの集まりであり、特定のフレームワーク・外部技術に依存していません。
フレームワークや外部技術は便利ではありますが、開発において制約にもなります。
なのでアーキテクチャの中心にある「Application/Domain」がそれらに依存しないことで開発を柔軟に行えるようになります。
③テストしやすい。
それぞれの層により責務が明確に別れているため、それぞれのコンポーネントで何を確認すべきかがより明確になっています。
後にみるように依存関係を構築する際に実体型に依存するのではなくプロトコル(インターフェース)に依存するようにすることで(依存関係の逆転の原則)、コードを書き直すことなくテストコンポーネントを利用できるようになるためテストが容易に行えるようになります。


クリーンアーキテクチャで守るべきルール  
クリーンアーキテクチャの特徴を保つために開発者は以下のルールを守る必要があります。
①依存方向は外から内側のみ
既に述べていますが、ビジネスロジックが単体で動作するために、またUI/Web APIなどの外部機能の変更を容易にするために、依存関係は外から内にのみ許されています。
②内側の層は外側の層に影響を受けない
上とほぼ同義なのですが、いくつか強調したいことがあるため別途挙げました。
まず上で述べた通り円の内側のビジネスロジックは独立して作動するためにその外側の仕様は知るべきではなく、またその変更によって影響を受けるような仕様になっているべきでもありません。
これはビジネスロジック内でも同様で、「Domain」はその外の「Application」の仕様を知らずとも作動する設計になっているべきです。
ただこのうち「Interface Adapter」は、少し例外と言えるかもしれません。
その理由は既に説明した通り「Interface Adapter」層は内側の層であるビジネスロジックと外側の層である外部機能をつなぎ合わせる役だからです。
UIにとってのInterface Adapter層に当たるPresenterやControllerは直接的にUIについて知ることはなくてもUIから受け取るイベントやUIへ通知するイベントによって、そのインターフェースも変更せざるを得ないので「UI」の仕様を全く知らないというと語弊があると思います。
またInfraにとってのInterface Adapterに当たるRepositoryやGatewayも同様で、例えばRepositoryはインターフェース上はドメインオブジェクトの操作における永続化に関わる処理を隠蔽しますがその実装ではその永続化機構がWebAPIかデータベースかという仕様によってコードが変わるため、こちらも外側の層を全く知らないとは言えないと思います。
③層をまたぐデータはシンプルなデータ構造であること
これも②と関連しています。
クリーンアーキテクチャは「内側の層は外側の層について知らないこと」をルールとしていますが、その根底には「関心の分離」があります。
なので内->外のみならず、あらゆる層の関心は他の層から切り離されているべきであり、それが不可能でも他層への関心は必要最低限でなければなりません。
そのため層をまたぐデータは単純な構造でなっているべきです。
もしこのデータが複雑であったりメソッドを持っている場合、層をまたいでさまざまな操作や処理が可能となり関心の分離ができていないためプログラムの予測することが難しくなります。

ルールを守るためのテクニック
クリーンアーキテクチャには以上のルールを守るための代表的なテクニックとして依存関係逆転の原則(Dependency Inversion Principle)があります。
多くの人は知っていると思いますが、簡単に説明します。
依存関係逆転というと難しそうに聞こえるのですが、要はあるコンポーネントに依存するとき実体クラスではなくインターフェース(プロトコル)に依存しようというだけです。
なぜインターフェースに依存することが「逆転」なのかというと、インターフェースの定義は利用する側の層に属していると考えられているからのようです。
そのため今まで利用するクラスが利用されるクラスに依存していたものが、利用されるクラスが利用する側の層のインターフェースに依存していると捉え「逆転」していると表現しているようです。(wikiの「依存性逆転パターン」参照)
簡単な例を書きます。
ViewAはそのクラス内でModelBを利用している時、ViewAはModelBに依存しておりViewA->ModelBといえます。
この依存関係に依存関係逆転の原則を適用するということは、ModelBの役割をインターフェースとして抽出してModelBProtocolを定義した上で、ViewAはModelBではなくModelBProtocolに依存してModelBもModelBに依存する(ModelBを採用するともいえます)ということです。
図で示すと以下の通りです。
図
この依存関係の逆転の原則がクリーンアーキテクチャで示す役割は以下2つといえます。
①テストが容易になる(各コンポーネントの独立性が高くなる)
言葉の通りですが、この後の例で同じく説明します。
②インターフェースを通して実質的に内側から外側へのアクセスを可能にする
クリーンアーキテクチャでは内側から外側への依存は禁止されています。
なのでインターフェースを使っていたら、内側から外へアクセス可能というのは表面的なレトリックのように聞こえますが、このテクニックがただの形式的なものではないというのはこの後の例で説明します。
ここでより実践的な例を使って具体的にみていきたいと思うのですが、クリーンアーキテクチャの図の右下にある図はちょうどそれに関するものであるためそれに沿って依存関係逆転の原則をもう少し具体的にみていきたいと思います。
この図です。
始めに言っておきたいのが登場コンポーネントはController/Presenter/UseCaseですが、ここでいうControllerはUIの入力に対する処理を行うクラスであり、PresenterはUIへの出力を処理するクラスでです。なのでMVCの"Controller"やMVPの"Presenter"とはそれぞれ意味が微妙に異なります。
図を見ればわかるとは思いますが、まず概要としてここで想定されている状況はUIからイベントを「Controller」が受け取り、その入力によって「Controller」は「UseCase」に処理を依頼し、「UseCase」は処理の結果をUIに表示するための「Presenter」に渡すというケースです。
簡易的に表すとController->UserCase->Presenterという流れです。
図
この状況を依存関係逆転の原則を適用せずにコードで実現しようとすると以下の問題が発生します。
わかりやすいように先程の依存関係の逆転の原則のクリーンアーキテクチャにおける2つの役割と対応させます。
①ControllerクラスがUseCaseクラスに依存しているため、Controllerのテストがしづらい
ControllerクラスはUseCaseクラスに依存している場合、ControllerクラスはUseCaseクラスが完成するまで動作確認ができないことになります。
②UseCaseクラスからPresenterクラスを呼び出すので、円の内側から外側に依存する
これは説明不要だと思います。Presenterクラスはクリーンアーキテクチャにおいて「Interface Adapter」層に属するのでUseCaseの層より外側です。そのためUseCaseからPresenterへの依存はクリーンアーキテクチャのルールに反します。
以上の問題を解決するため依存関係の逆転の原則を適用します。
それによる変更点は以下2点です。
・Controller->UseCaseの関係性で、UseCaseInputPortインターフェースを定義して利用する。
ControllerはUseCaseInputPortを呼び出し、UseCaseはUseCaseInputPortを採用する。
図
・UseCase->Presenterの関係性で、UseCaseOutputPortインターフェースを定義して利用する。
UseCaseはUseCaseOutputPortに結果を渡し、PresenterはUseCaseOutputPortを採用する。
図
これにより先程挙げた2つの問題が解決されます、一つずつみていきましょう。
①ControllerクラスがUseCaseクラスに依存しているため、Controllerのテストがしづらい
↓
ControllerクラスはUseCaseクラスではなく、UseCaseInputPortインターフェースに依存することになりました。
このためControllerクラスのテストのためにはUseCaseクラスは必須ではなくなり、UseCaseInputPortインターフェースを採用したクラスさえあればテスト可能になりました。このため簡易的なUseCaseInputPortインターフェースに適応したクラスを作成する等により以前より簡単にテストを行うことができます。
②UseCaseクラスからPresenterクラスを呼び出すので、円の内側から外側に依存する
↓
依存関係逆転の原則ではインターフェースの定義は利用する側に属していると説明しました。
そのためUseCaseOutputPortはUseCase層に属していることに、円の内側から外側に依存していることにはならなくなりました。
私がこれを表面的なレトリックではないと言ったのは、これにより円の内側から外側への依存を禁止している目的を満たしているためです。
「円の内側から外側への依存禁止」の目的は「関心の分離」と同時に「変わりやすい円の外側のコンポーネントの変更を容易にすること」です。
そしてUseCaseOutputPortインターフェースの定義により、UseCaseクラスが処理結果である値を渡すのはPresenterクラスである必要はなくなりました。
UseCaseOutputPortのインターフェースを採用していればどんなクラスでもOKであり、UseCaseOutputPortにあたる実体クラスが変更されてもUseCaseクラスは何も変更する必要はありません。
これによってUseCaseの層は外側のInterface adapter層に関心を払う必要がなくなり、Interface adapter層はその実体クラスを容易に変更することができるようになりました。
これは「円の内側から外側への依存禁止」の目的を十分に満たしていることになり、このインターフェースによる依存関係の変化が単なる表面的なものでないことを示していると思います。
クリーンアーキテクチャが教えてくれていること
ここまでで説明が一通り終わりましたので、まとめとしてクリーンアーキテクチャから学べることを簡単に書きます。
ここに書かれていることはレイヤードアーキテクチャなど類似のアーキテクチャにも当てはまると思います。
①MVC等のGUIアーキテクチャでは直接言及されていないコンポーネントをどう扱えば良いか教えてくれる
円図を見ればわかる通り、クリーンアーキテクチャではDeviceなど他のアーキテクチャではあまり言及されていないコンポーネントをどこにおけば良いか教えてくれています。
このように具体的な名前を出してアーキテクチャの中で言及してくれるのは開発者にとっては地味に大きいんではないでしょうか。
自分が利用しようと思うコンポーネントがそのアーキテクチャのどこに当たるのかわからないと開発者は混乱します。
私はそれまでDeviceをどこにおけば良いか、他のコンポーネントとどう連携させれば良いかわからなかったのですが、クリーンアーキテクチャを勉強して納得のいく理解が得られました。
②「アプリケーションにおいて変わりづらいものを中心にして、変わりやすいものは変更しやすいよう外側に置くように設計する」という平易な主張でアプリケーションの大きな方向性を示してくれる
これは人によりけりだとは思いますが、クリーンアーキテクチャの概念はGUIアーキテクチャと比べ、人にとってわかりやすいものだと思います。
MVCなど他のGUIアーキテクチャならば何よりもまずModel-View-Controllerという構図とそれらの詳細などテクニカルな部分に目がいきがちだと感じます。
クリーンアーキテクチャもその詳細にはテクニカルな説明を含んでいますが、何よりも前面に押し出しているのは「関心の分離」などのテクニックの背後にある開発思想だと思います。
③「テスト」など開発周辺のことについても示唆的である
これも②と同様に人によるとは思いますが、クリーンアーキテクチャはその「関心の分離」や「依存関係逆転の原則」といった考えを実践していく中で「テスト容易性」や「コードの保守性」など長期の開発をしていく上で大切なポイントに気付きやすいアーキテクチャだと思います。

