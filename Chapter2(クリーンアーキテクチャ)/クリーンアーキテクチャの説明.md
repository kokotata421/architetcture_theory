
# iOSアプリでスケールしやすいアーキテクチャを考えてみた②-設計を理解するためのクリーンアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)**設計を理解するためのクリーンアーキテクチャ編←本記事**  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への準備編として設計の概観を理解するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  
また本記事はレイヤードアーキテクチャの知識を前提としていますので、レイヤードアーキテクチャがわからない方は前の記事から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

### 記事内の用語の表記ルール 
記事内でアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。    

例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logic(層)と表記します。  
InfrastructureはInfraと省略して表記し、 Infra層のうちデータ操作に関するものをData(層)、端末機能に関するものをDevice(層)と表現する場合があります。  



## 前回までの内容と本記事の内容
初回である前回の記事ではスケールしやすいアーキテクチャを考えるためにクリーンアーキテクチャを通して設計概要を理解することを最初の目的としました。  
そしてクリーンアーキテクチャの前提知識としてその原型とも言えるレイヤードアーキテクチャの理解を深めたのが前回までの内容です。

この記事ではいよいよクリーンアーキテクチャを学び、設計についてまとめたいと思います。

## クリーンアーキテクチャとレイヤードアーキテクチャの共通点/相違点
まず前回学んだレイヤードアーキテクチャと今回学ぶクリーンアーキテクチャの共通点、そして相違点について整理することでクリーンアーキテクチャを理解するために必要なポイントをまとめます。   
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>


前回の記事でレイヤードアーキテクチャの特徴が**責務による層の分割と単一方向の依存関係による関心の分離**であることを述べました。  
クリーンアーキテクチャでもそれは変わりません。    
円の中の一つ一つの色が層を示していて、また円内側の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格はつかめているといえます。  
ただクリーンアーキテクチャではその詳細が異なっています。  
そのためクリーンアーキテクチャを理解するためにまず層の分割と依存関係の詳細について見ていきたいと思うのですが、これらを理解することはクリーンアーキテクチャが円である理由を理解することと同じです。  
なので最初にクリーンアーキテクチャが円である理由を踏まえながら円の各層・依存関係について理解していきたいと思います。  

## Entities = Domain層 / Use Cases = Application層
クリーンアーキテクチャが円である理由を見ていきますが、その前に前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所があるのでそこから始めます。  
ちゃちゃっと終わらせるために結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層であり、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層です。   
最初にEntitiesから取り上げると円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」です。  
前回の記事でDomainとは「事業の知識・ルール」を意味していることを書きましたが、ここからEntitiesがDomainと同じであることがわかると思います。    
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesの方に書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要でしょう。

以後EntitiesはDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため

クリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか？  
実はその理由はレイヤードアーキテクチャの記事ですでに書いています。  
レイヤードアーキテクチャの記事のPresentation Domain Separation(以下PDSと表記)の説明でビジネスロジックを「アプリケーションプログラムの機能的中心」と表現しましたが、まさにこれがBusiness LogicであるDomainとApplicationが円の中心にある理由です。  

もう少し具体的に示すと以下のようになります。  

1. サービスのアイディアを具体化したものがビジネスロジックのデータやロジックであり、ビジネスロジックなしではアプリケーションは成立しない   
2. ビジネスロジックはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. ビジネスロジックは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

### ビジネスロジックを円の中心に置く3つの理由

#### ビジネスはアイディアから
1については「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、プログラム化したものがDomain層であり、それをさらにアプリケーションとして提供するために書かれたコードがApplication層です。  
UI層はそのサービスをユーザーへ提供する窓口として存在しInfra層はそのサービスの実現のための手段として必要であって、Business Logic層なしにアプリケーションが生まれることはありません。    

#### ビジネスロジックは相対的に変更されづらい層
(2について)またそれはビジネスロジックがアプリケーションの中で相対的に変わりづらい箇所であることも意味しています。(ここでいう「変更」はアプリケーションの仕様変更や機能的に要求によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。)  
UIやInfraはBusiness Logicが変わることがなくてもUXや技術的なパフォーマンスの観点から変更することがあります。  
それに対してサービスの仕様が変更された場合はBusiness Logicも変更されますが、それに応じて必ずUIやInfraも変更を迫られることになります。  
このようにビジネスロジックはアプリケーションの機能的中心でサービスそのものであるため、ビジネスロジックの定義が変わる場合はそれに応じて他の層も変更する必要があります。  

#### 外部技術に依存していない
3はどちらかというと「ビジネスロジックが円の中心である理由」というよりも「ビジネスロジックが他の層から切り離される理由」といった方が良いかもしれません。   
ただ純粋なプログラミング言語の定義によってのみ成立し外部技術に依存しない理由は、結局そのサービスの核心にあるため外部に依存していないという話につながりるため理由の一つとして加えました。   


### クリーンアーキテクチャは現実の開発状況をより反映させている
そしてこうしたDomainとApplicationを中心に据えたクリーンアーキテクチャはレイヤードアーキテクチャと比べてより現実を反映させた設計であると言えます。  

レイヤードアーキテクチャは技術的な側面から依存関係を決定したため、技術的な基盤となるInfraがアプリケーションを支えていると捉え「UI->Application->Domain->Infra」という依存関係でした。  
それに対してクリーンアーキテクチャではアプリケーションの機能的中心であるBusiness Logicがアプリケーションを支えていると捉え、他の層がBusiness Logicに依存しています。  
クリーンアーキテクチャのこの構造はアプリケーション開発の実態をより正確に捉えています。  
アプリケーションは技術的にはインフラに依存していますが、サービス的に依存しているのはビジネスロジックであり開発はビジネスロジックを起点に動きます。  
そのためビジネスロジックを中心として他の層と切り離すことで、実務で発生する要件に柔軟かつ迅速に対応することが可能になるのです。  
私たちの日々の業務でも技術的にはインフラであるインターネットに依存しつつもその活動はビジネス的な事柄に依存していますが、それと同じです。

このようにクリーンアーキテクチャは技術的(レイヤードアーキテクチャ)には4層の中間に位置するビジネスロジックをアプリケーションの基盤と捉えそれを中心としたアプリケーション設計であり、それを
図で示すために円の形となっています。  

## Framework & Drivers層とInterface Adapter層
クリーンアーキテクチャがなぜ円なのかについて理解したところで、クリーンアーキテクチャの層でまだ説明されていないFrame & Drivers層とInterface Adapter層を説明していきます。  
### Framework & Drivers層
まず一番外にあるFrame & Drivers層から見ていきます。  
円を見てみるとこの層にはUI/Web/DataBase/Devices/External Interfacesとさまざまなものが表記されており、レイヤードアーキテクチャでいうUIとInfraやフレームワーク等が含まれていることになります。  
この層ではレイヤードアーキテクチャで異なる層であったUIとInfraが一つの層とされているわけですが、私たちは既に同様のケースを前回の記事でも見ています。  
PDS(以下)のPresentationです。  
PDSのPresentationにはUIのみならずInfraも含まれることを前回の記事で説明しましたが、クリーンアーキテクチャでも同様に同じ層として扱っているのはこの2つが以下の共通点を持っているためです。  
- 仕様の変更によってコードが変化しやすい
- 外部技術に依存している

こうした特徴を持った層に他の層が依存しているような設計だと、層の変更による影響が依存している他の層にも広がってしまい柔軟な開発を行うことが難しくなります。  
そのためクリーンアーキテクチャではこれらの特徴を持ったUI/Infra層を他の層から依存されないように同じ最外層に置いているのです。

### クリーンアーキテクチャの層==アプリケーションのディレクトリ構造ではない
クリーンアーキテクチャを採用した場合、UI層とInfra層はどこからも依存されないようにするという意味でアプリケーション上同じ立ち位置ですが、実際に提供している機能は大きく異なるため開発時には区別されます。  
クリーンアーキテクチャはあくまで考え方であって、アプリケーションプロジェクトではUI/Business Logic/Infra等レイヤードアーキテクチャの責務分割に沿ってディレクトリを分けることが多いです。  
クリーンアーキテクチャの層と実際のプロジェクト内の層の関係についてはもう少し詳細に説明したいことがあるので記事の最後に補論として書きました。  


ちなみにFramework&Driversの意味はFrameworksはフレームワーク、つまりiOSのUIKit等パッケージ化された外部技術を指しており、DriversはIT用語でシステムに装着する外部装置を意味するのでこの層はビジネスロジックをアプリケーションプロダクトとして完成させるために必要な外部技術群と言えると思います。  

### Interface Adapters層

さて、残る一つはInterface Adaptersです。  
Interface Adapterという言葉だけ聞くとなにやら難しく感じてしまうのですが、簡単にいうとこの層は内側のBusiness Logicと外側のFramework&Drivers層を繋ぐための仲介役を担う層です。  

円図ではこの層に該当するコンポーネントとしてController/Presenter/Gateway等が書かれていますが、基本的にこれらのうちControllerとPresenterがUIとビジネスロジックの、GatewayがBusiness LogicとInfraの仲介役を担っていると捉えて問題ないでしょう。  
iOSMVCのControllerに当たるViewControllerもここに属し、円図でいうController/Presenterを担っています。

#### MVCのControllerと円図にあるControllerは異なる
ややこしいのですが、MVCアーキテクチャの文脈でいうControllerと円図に書いてあるControllerは意味が異なります。  
私たちにとってはControllerというと画面の入出力処理を担うMVCアーキテクチャのControllerが馴染み深いと思いますが、ITでの一般的なControllerは入力のみに関する処理装置を意味していて出力に関する意味は含まれていません。  
これはMVPのPresenterにも同じことが言えて、Presenterは一般的には出力のみに関する処理装置を指しておりMVPのPresenterは円図でいうControllerとPresenterの両方の責務を担っていることになります。  

#### Interface Adapter層は各層の責務の純度を高くしてくれる
このInterface Adapters層が担う層の仲介という責務はレイヤードアーキテクチャでは存在していなかったのですが、実際に開発で実践してみるとこの層の重要性に気づきます。  
層同士が連携して責務が混ざり合った箇所を一つの独立した層として捉えることで各層責務の純度が格段に上がるのです。  
  
レイヤードアーキテクチャの層はアプリケーションを機能によってわかりやすく分割していますが、それはあくまで理論上の話であって実際のアプリケーションでは各層が連携して一つのアプリケーションとして動作するため複数の層の責務が交わり境界が曖昧な処理が発生します。  
例えばDomain層ではビジネス的な事柄が関心の対象なので、永続化機構でデータを更新するためのURLやそのためのデータ形式の変換に関心を向けるべきではありません。  
ただ一方でInfra層ではデータを永続化するという汎用的な責務を担ってはいるものの、特定のURLやそれに関する処理はそのアプリケーション(ドメイン)固有なものなのでInfra層がその責務を負うのはおかしなことです。  
このようにレイヤードアーキテクチャによる層の分割を実践しようとするとその層の境界でどっちつかずな責務が発生してしまい、このような責務は基本的に妥協の末に利用している側(上の例ではDomainがInfraを利用しているのでDomain)に実装されるようになります。  

この問題を解決するためにクリーンアーキテクチャではレイヤードアーキテクチャの層が連携する責務も一つの独立した層として捉えました。  
こうすることで円の内側のビジネスロジックと外側のFramework & Drivers層に不純な責務を含める必要がなくなり、各層の責務の純度を高く保つことができるようになりました。  

#### RepositoryもInterface Adapters層
ちなみに円図では表記されていませんが、開発でよく耳にするRepositoryコンポーネントもこのInterface Adapters層に入ります。  
Marin Flower氏の定義を引用するとRepositoryはDomain層とData層の仲介役です。(引用文のdata mapping layersはData層を指しています。)  
>A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection  
円図でいうとGatewaysのカテゴリの中に含まれていると考えればよいと思います。   

#### Gatewayとは異なる層の中継役という意味
Gatewayという名前はクラス名としてはあまり聞き慣れないと思いますが、ネットワークの文脈では異なる層の中継役を担う装置を指しており、クリーンアーキテクチャでも同様の意味です。  　　
私はInterfaceAdapter層のクラス名を命名するとき、できる限り具体的なControllerやRepositoryといった名前を使うようにしていますが適切な名前が見つからない時はGatewayの名前を使うようにしています。  
Gatewayは広範囲を示す名前ではありますが、プロジェクト内で乱用されるような名前ではなくそれだけでInterface Adapter層のコンポーネントだと伝わると思うので「~Managerクラス」や「~Serviceクラス」等より責務が明確で便利な単語だと思います。  



## クリーンアーキテクチャの依存ルール
クリーンアーキテクチャでの依存は外側の層から内側の層へという方向であること、また外側の層の仕様は変わりやすく内側の層の仕様は変わりづらいことを説明しました。  
つまりクリーンアーキテクチャの依存は変更されやすい外側の層から変更されにくい内側の層へ向いており、こうすることで外側の層の変更のされやすさがアプリケーションへ影響することを最小限に抑えています。  
ただ技術的に依存しているのはInfra層のはずなのに、Infra層がビジネスロジックに依存するということはどういうことなのでしょうか？  
これについてはこの後クリーンアーキテクチャのルールを守るためのテクニックという節で説明します。  

## クリーンアーキテクチャの概要を一度整理する 
ここまででクリーンアーキテクチャの特徴に一通り触れました。  
しかしレイヤードアーキテクチャの理解を前提として話を進めたため、必要な要点のみ説明して基本的な説明をあまりしてきませんでした。      
なのでこれまでの内容と重複する部分もありますが、ここで一度クリーンアーキテクチャの原文に沿った形でその概要を整理したいと思います。  

## クリーンアーキテクチャの特徴   
クリーンアーキテクチャの記事の冒頭では、ヘキサゴナルアーキテクチャ・オニオンアーキテクチャなどのシステムアーキテクチャを紹介しています。  
システムアーキテクチャの厳密な意味は私もはっきり理解しているわけではないですが、恐らくアプリケーションの特定の領域にこだわらずシステム全体を関心の対象としているアーキテクチャという理解で大丈夫だと思います。  
そして記事ではそれらシステムアーキテクチャの特徴として以下の共通点があると述べています。  

1. 関心の分離  
どのシステムアーキテクチャも関心の分離を基本として、少なくともビジネスロジックとその他の2層に分けようしています。
2. UI/WebAPI/データベース/フレームワークといった外部技術が独立している  
アプリケーションのうち変更されやすいUI/Web API/データベース/フレームワーク等のコードにどこからも依存しない。  
このような外部技術は便利なものの、同時に開発時の制約も発生するためこれらに依存しないようにすることで柔軟な開発が可能になります。  
3. テストしやすい  
ビジネスロジックが特定の外部技術に依存していないためテストが容易になります。  
またのちに見るように層の依存関係をclassなどの実体型で実現するのではなく、プロトコルを利用した抽象型によって実現することでビジネスロジック以外の層でもテストがやりやすくなります。 

そしてこうした特徴を図としてまとめたものがクリーンアーキテクチャの円図です。  

##
ちなみに原文には必要であればもっと層を細かくわけても構わないと書かれています。  
ただ該当箇所の小見出しには「Only Four Circles?(4つの層だけ?)」と書かれており、基本的に4つの層より多くなることはあっても4つの層より少なくなるようなことはないという考えのようです。   
私としても責務の分離を目的とするなら少なくともBusiness Logic/Interface Adapters/Framework&Driversの3層は必要だと思いますし、Business Logicも設計者がBusiness Logic内での層の分割を意識してるかどうかは別としてその中で責務をしっかり分けていくと実質的にはDomain/Applicationの分離が生まれてくると思うのでこの4層をベースとして必要であればそれ以上に層を分けるというスタンスで良いのかなと考えています。  

## クリーンアーキテクチャで守るべきルール  
クリーンアーキテクチャの特徴を保つために開発者が守らなければいけないルールが大きくいって2つあります。

### ルール1: 円の内側の層は外側の層については知らない何も知らないし、影響も受けない
  
Business Logicは外側の層について何も知らなくても独立して動作できるようになっている必要があります。  
またBusiness Logic内のDomainとApplicationに関しても同様で内側の層であるDomainは外側のApplicationについて知っているべきではありません。  
クリーンアーキテクチャではこのようにアプリケーションとして動作するため各層は連携しつつ、可能な限り関心を分離することを目的としているので依存して良いのは外側の層から内側の層へのみということになっています。  

ただこのうち「Interface Adapter」は少し例外といえます。   
既に説明した通り「Interface Adapter」は内側と外側の層の中継役となる層なので直接的にではなくても外側の層の事情を知ることになるからです。  
具体的に説明すると、UI側のInterface Adapter層はUIの仕様によって自身の入力・出力の処理を変更することになるので直接UIを知らなくても間接的にその仕様について知っていることになりますし、Infra側のInterface Adapter層もデータベースかWebAPIかでインターフェースが異なるので実体型としてデータベースやWebAPIを参照していなくともメソッド名やその引数から外側の層の事情はある程度把握できますし、データベースからWebAPIへの移行時にコードへの影響は避けられません。    
原文の記事でも冒頭で  
>Nothing in an inner circle can know anything at all about something in an outer circle.  
>
>意訳  
>内側の層は外側の層について全く知らないこと。  

と強調しながらも、Interface Adapter層の説明でSQLデータベースを例に出しながらInterface Adapter層で外側の層を知っていることは致し方ないことだと書いています。(ただ同時に外側の層がInterface Adapter層に与える影響は必要最低限に留めることも強調しています。)
>If the database is a SQL database, then all the SQL should be restricted to this layer, and in particular to the parts of this layer that have to do with the database.
>
>意訳  
>もしデータベースがSQLならば、SQLに関するコードはInterface Adapter層の内データベースと関与する箇所のみにとどめるべきである。  

### ルール2:層をまたぐオブジェクトはシンプルなデータ構造であること
アプリケーションとして動作するためには層同士で連携してオブジェクトの受け渡しを行う必要があるのですが、これをネガディブに表現すると層の責務の漏出ということになります。  
どんなに正当な理由があろうともある層のオブジェクトが他の層に渡されて利用されるということは、層同士の関心の分離が破られてしまうことになるからです。  
クリーンアーキテクチャではこうした状況でも関心の分離をできる限り徹底するため、層をまたぐオブジェクトはシンプルなデータ構造であることをルールとしています。  

もし層をまたぐオブジェクトが複雑な処理のメソッドを持っていた場合、またいだ先の層でもそのメソッドの呼び出しが可能であるためそのメソッドを通して複雑な処理が行われて責務が他の層へどんどん漏出していく恐れがあります。  
なにより受け渡し元の層からしたらメソッドを持ったオブジェクトが受け渡し先でどのように利用されるのか想定しきれないため、開発における不確実性が高まりバグの温床となります。  

それに対してこの層をまたぐオブジェクトがメソッドを持たないデータ構造である場合は、他の層に漏れる責務はそのデータ構造のみとなり受け渡し元で制御可能となります。  

このように層をまたぐオブジェクトをシンプルなデータ構造にすることによって、層の責務の漏出は必要最低限かつ予測可能なものとなり関心の分離は高い水準に保たれます。  

細かい話ですが、ここでいうメソッドを持ったオブジェクトとはある層の責務が漏れてしまうような処理を持っているものを指し、Swiftの配列Arrayなどの型は含まれません。  
例えば銀行アプリでお金の計算をするのはApplication層またはDomain層の責務ですがそのようなお金の計算処理をメソッドとして持つDomain層のオブジェクトをInterface Adapter層であるViewModelに渡してしまった場合、ViewModel側でもお金の計算が可能になってしまうためViewModelにDomain層の責務が漏れてしまっていることになります。  
それに対してArray型などSwiftが既存で提供している型はメソッドを持ってはいるもの、そのメソッドが影響を与えるのはそのデータ構造のみであり決して層の責務が漏れることはありません。  

ここに関しては他にも何を持ってデータ構造が「シンプル」であるのかという問題もあります。  
「シンプルなデータ構造」を厳密に言葉で定義しようとするとなかなか難しいのですが、ここでいうシンプルさというのは何度も言っているように層の関心を分離するためであってそれを無視して設計してしまうとおかしくなります。  
再び具体例を出すとUI側でユーザ名が必要な場合ViewModelではApplication層にユーザー名の取得を要求しますが、この時にユーザー名を含めたアプリケーションに関する全ての情報を含んだデータを渡されても完全に情報過多です。  
開発時に最初から関わっている人はその特殊な事情を知っているかも知れませんが何も知らず新しく入ってきた開発者はユーザー名の取得のためにわざわざアプリケーションに関するすべての情報を取得しあまりに多くの知識がApplication層からViewModelに漏れていることに「何か自分が理解できていないことがあるのでは？」と気を揉むことになるでしょう。    
  
また反対にユーザー名の取得のためにユーザー名のみ返す場合はそれはシンプルなデータ構造を渡しているといえますが、こうなるとユーザーの電話番号、口座番号とUI側で必要な個々の情報に応じてApplication層側に取得メソッドを定義する必要があり、それはすなわちApplication層の定義がUIの仕様に影響を受けていることになるので関心の分離ができていません。  

例に出したケースでは、基本的にはユーザー名が取得したい場合はApplcation層はユーザー情報をViewModelに渡して、ViewModel側でユーザー情報からユーザー名のみ利用するというのが正解だと思います。  
ユーザー情報はアプリケーションの仕様として一つのまとまった情報単位であることは間違いないですし、もしこのユーザー情報という単位に変更が必要な場合はそれはUI側の事情ではなくアプリケーションの事情によるものであると言って良いでしょう。

ここで出した例をもとに層をまたぐシンプルなデータ構造を持ったオブジェクトをもう少し正確に説明すると、「受け渡す二つの層のうち内側にある層の仕様を基準に設計されたシンプルなデータ構造」と言えます。  



ちなみに話が何度も逸れて申し訳ないですが、上の例でInterface Adapter層がDomain層のデータを受け取ることに違和感を持つ人もいるかも知れません。  
クリーンアーキテクチャの円図で言うとInterface Adapter層が関わるのはApplication層で直接Domain層と関わることはあり得ないからです。    
ただ実際の開発ではApplication層がInterface Adapter層にデータを渡す際にはDomain層のデータを渡すことが多いです。  

### ルール3：データフローは一方向
これはクリーンアーキテクチャの原文に明言されているわけではないのですが、クリーンアーキテクチャを実践するさいには自然とこれを守るようになりますし、また設計という観点からみてもデータフローが一方向であるということは重要なことなのでルールとして加えました。  
クリーンアーキテクチャの右下の図はデータフローにも関係していることなので、それを用いて説明します。  
以下の図では正確には他のことにも言及しているのですが、とりあえずここではデータフローについてのみ説明します。  

アプリケーションに関するデータフローを円図に沿ってたどっていくと、入力は円の外側のUIから起こり、その処理のため内側のBusiness Logicに入っていき、再びその結果は出力先であるUIに向かうため円の外->内->外と流れていき一見クリーンアーキテクチャの依存関係のように綺麗に一方向になっていない印象を抱かせますが、それはこの円図がデータフローではなく依存関係に着目して作られているからであって実際のところデータフローも一方向となっているべきです。  

具体的に説明すると最初に出した図が表しているように円図のデータフローはContrller->UseCase(Applciation)->Presenterとなっているように、円の外->内->外といっても最初に外から内へ入る時と、そのあと内から外へ出ていく時の経路が異なるため実質的にデータのフローは一方向となっているのです。  

これはMVCのControllerやMVPのPresenter等、一つのコンポーネントが画面の入出力を担当している場合も同じことが言えます。  
これらのコンポーネントでは一つの中に入出力の責務がありながらも、実際のコード上では入力と出力の責務が交わらないように設計されていることが前提となっています。    
同じコンポーネントを通しているのにデータフローは別というのはおかしいと思う方もいるかも知れませんが、これは別に詭弁であるわけではありません。  
繰り返しになりますが、まず第一に重要なことはデータフローが一方向であるということであって、MVCのController等をまねして一つのコンポーネントに入出力をまとめることではありません。  
もしあなたが入出力を一つのコンポーネントにまとめた場合、入力と出力で切り離すことが不可能だと考えるならクリーンアーキテクチャのControllerとPresenterのように別々のコンポーネントで定義するべきです。  
しかし実際にはしっかりと設計をすれば、ほとんどのケースで一つのコンポーネントでも入出力の切り離しは可能であり、それにも関わらずわざわざ入力と出力で別々のコンポーネントを定義するのは手間であるため一つのコンポーネントとして定義しているのがMVCのControllerやMVPのPresenterだと考えた方が良いでしょう。  

のちに見るように開発時、入出力で一つのコンポーネントにまとめている場合でもProtocol上は入力用と出力用で別々に定義してそれら両方を一つのコンポーネントが採用しているというケースが多いです。  

そのようなケースでクリーンアーキテクチャ全体のデータフローを示した一例を下に載せときます。  


## ルールを守るためのテクニック
ここまでクリーンアーキテクチャについていろいろと説明してきましたが、クリーンアーキテクチャの核心とも言える「円の内側が外側についてなにも知らない」というルールを守ったままアプリケーションを実現する方法について説明していません。  
アプリケーションのあらゆる操作は最終的にUIへの出力という形で表れますし、また技術的にもBusiness LogicはInfraに依存しているはずなので円の内から外への矢印がないことは不可解なことのように思えます。  
ここではクリーンアーキテクチャの依存が外側から内側のみである問題をどう解決すればよいか説明していきます。  

これには依存関係逆転の原則(Dependency Inversion Principle)というテクニックを利用します。    
「依存関係逆転」と聞くと難しそうに聞こえるのですが、要はこれはあるコンポーネントに依存するとき実体クラスではなくインターフェース(Swiftでいうプロトコル)型に依存するというだけです。  
なぜプロトコルに依存することで層の外側から内側の依存のみになるのかというと、プロトコルを利用した依存関係の場合、そのプロトコルは利用される側の層ではなく利用する側の層に属していると捉えられるからです。  
これはこの概念の名前にある通り「依存関係の逆転」とも言えるのですが、これだけだとわかりづらいと思うので一つ例を出して説明します。

あまり具体的な例ではないのですが、クラスAがクラスBを利用している場合、その依存関係はA->Bとなり利用する側のAが利用される側のBに依存しています。  

ここで「BType」というプロトコルを定義して、クラスAはBTypeプロトコルを利用してさらにクラスBはBTypeプロトコルに準拠した場合、A->BType<-BとなりクラスAもBもBTypeプロトコルに依存していることになります。(堅苦しいですが、Swiftではある実体型にプロトコルを適用する場合「プロトコルに準拠する」とよく表現します。)
そしてBTypeプロトコルは利用する側であるクラスAの層に属していると捉えられているため、プロトコルを利用せず実体型のみの依存関係では利用する側が利用される側に依存していた関係性が、プロトコルを利用した場合利用される側から利用する側への依存に逆転したことになります。  
これがプロトコルを利用した依存関係の構築が「依存関係逆転」と言われている理由であり、クリーンアーキテクチャでは内から外の依存がないと言われている理由です。  
クリーンアーキテクチャでは内から外への依存が必要なときはプロトコルを利用しています。  

プロトコルを利用した依存が「依存関係の逆転」と言われているから内から外の依存はないというのはただの概念的な操作であって、レトリックにしかすぎないと思う人もいるかもしれません。  
ただここでもう一度思い返して欲しいのですが、クリーンアーキテクチャで外から内への依存のみ許している理由は以下の二つです。  
- Business Logicを外側の層から切り離す
- テストを容易にする

実体型を利用した依存関係では満たすことはできない上記の要件をプロトコルを利用することによってしっかり満たすことができるようになっています。  
Infra側ではそれまで実際のInfraクラスに定義されていたメソッドなどを要件としたプロトコルに準拠クラスであればなんでも良いので実際のInfraクラスが完成せずともBusiness Logicのテストが可能ですし、
UIも同様にデザインが完成していなくともとりあえずコンソールなどに出力が正しいか確認できます。  

このようにプロトコルを利用した依存関係によってアプリケーションは外側の層に依存しないようになっているため、開発において非常に効果のあるしっかりとしたテクニックです。  

ちなみに内から外への依存を行いたいときのテクニックとして依存関係逆転の原則を紹介しましたが、実際には外から内への依存でも積極的にプロトコルを利用することをオススメします。  
UIのテストを行いたいときなど、出力値が正しいかどうかではなく出力値を表示するレイアウトを確認したいといった場合があると思います。  
こうした場合、UIからViewModelやPreseterなど実体型に依存することなくプロトコルに依存することで実際の処理を記述することなくテストを行うことができます。  
このようにプロトコルの依存によりテストが容易になるのはあらゆる依存関係で言えることなので、依存の方向性関係なくプロトコルを利用した依存関係を積極的に使っていった方が良いと思います。  

## クリーンアーキテクチャにある誤解
一通りクリーンアーキテクチャについて説明できたと思うのですが、ネット上でiOSにおけるクリーンアーキテクチャを調べると大きく2点ほど誤解されているところがあると思うのでここではそれについて説明したいと思います。  

1. EntityはData(Infra)層に属しておらず、また単純なデータ型でもない　　

まずはEntityに関する誤解です。  
ネットで調べているとEntityがData層であるような記述があるのですが、クリーンアーキテクチャにおけるEntityはData層ではなくDomain層です。  
EntityをData層としてしまうとあの円図の中心はData層ということになり、ビジネスロジックを他から切り離すというクリーンアーキテクチャの目的とは異なる意図を持った図になってしまいます。  
そうなると各層の質的な連続性、クリーンアーキテクチャの主張の論理的な一貫性が失われてしまうためあの円図を理解するのは難しくなるでしょう。  

恐らくEntityをData層とする主張はデータベースの文脈におけるエンティティと混同しているのだと思います。  
データベースの文脈ではエンティティはデータベース上で操作する一つのデータのまとまりを指し、恐らくプログラミング業界ではエンティティというとこのデータベースにおけるエンティティの歴史が一番古く広く浸透しています。    
ただ先ほどもいった通りEntityをData層と解釈してしまうと、クリーンアーキテクチャの主張と根本的に矛盾してしまうため注意が必要です。  

そしてEntityに関してはもう一つ誤解があります。  
Entityは単純なデータ型を意味しておらず、ビジネスルールを指しています。  
これはクリーンアーキテクチャのEntityの定義を見ればわかると思います。  
>Entities encapsulate Enterprise wide business rules.   
>An entity can be an object with methods, or it can be a set of data structures and functions.  
>  
>意訳  
>エンティティは事業のビジネスルールである。  
>エンティティはメソッドをもったオブジェクト、もしくはデータ構造と関数の集まりである。  

このようにクリーンアーキテクチャにおけるEntityはロジックを含んだビジネスルールをカプセル化したものです。  

こちらの誤解は意味としては先ほどのData層における誤解ほど大きな影響はないと思うのですが、その誤解の原因は非常に厄介なように思います。  
既にクリーンアーキテクチャのEntityがなんであるかは説明できたと思うので詳細は省きますが、その理由はクリーンアーキテクチャにおけるEntityはドメイン駆動開発におけるエンティティともVIPERアーキテクチャのエンティティとも異なるからです。  
特にクリーンアーキテクチャをiOSの開発環境で実践しやすいように最適化したVIPERアーキテクチャのエンティティと意味が微妙に異なるため誤解しやすいなと思います。(ちなみにVIPERの
エンティティもData層ではないことは強調されています。)  

まあそのような詳細はさておき、ここでの内容をまとめるとクリーンアーキテクチャにおけるEntityはDomain層であり、またロジックを含んだビジネスルールを指しているということです。  

2. 異なる層のためのデータ変換はInterface Adapter層の役割である
こちらに関しても詳細としては2つに分けられて、UI側のInterface Adapter層とInfra側のInterface Adapter層の指摘で異なる内容となります。  

最初にUI側の話をすると、クリーンアーキテクチャでApplication層であるUseCase内でTranslatorというデータ変換用のコンポーネントを利用してUI用のデータ形式に変換するという内容がありますがこれは誤りです。  

まずInterface Adapter層の役割が内側の層と外側の層の仲介役と説明しましたが、その詳細を原文を引用しながら再度紹介します。  
原文のInterface Adapter層の説明では
>The software in this layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency  
>  
>意訳
>この層(Interface Adapter)はApplication層もしくはDomain層のデータを最外層に最適な形式に変換することである。
  
と述べており、またそのすぐ後の説明では  
>Also in this layer is any other adapter necessary to convert data from some external form to the internal form used by the use cases and entities  
>
>意訳  
>またこの層(Interface Adapter)では最外層のデータを内側のApplication層やDomain層に最適な形式に変換する。　　

と書いており、方向性かかわらず内と外の層の間のデータ形式の変換を役割としています。  

クリーンアーキテクチャで異なる層へのデータ変換を行うのはInterface Adapter層だけです。(見方によればApplication層内でDomain層のデータをApplication層データに変換しているといえますが、ここでの「異なる層へのデータ変換」とは明らかに異質であるためここには含みません。)   

もしUI層へのデータ変換の責務をApplication層であるUseCaseとした場合、UseCaseはUIの仕様なしでは定義・実装できないことになりますし、UIの仕様に変更があった場合その影響をUseCaseが受けることになるのでクリーンアーキテクチャの「外側の層の変更の影響を内側の層は受けない」という特徴を失っていることになります。  


次にInfra側の話になりますが、私がここで指摘したいケースInfra⇄Business Logicのデータ変換をInterface Adapterで行わずにData(Infra)層にあたるコンポーネントがBusiness Logicに適したデータ形式を出力しているケースです。  
クリーンアーキテクチャでは外側の層が内側の層の仕様を知っていることは良しとしていますがそれでも必要がなければ関心を切り離すべきですし、これから説明するようにこのケースではある層が他の層の事情を持ち込むことによってコードが冗長化して変更に弱い設計になってしまっています。  

ここまででは想定されているケースがイマイチよくわからないと思うので、そこから例を出して説明していきます。  
前置きになりますが、ルールを守るためのテクニックのところでプロトコルを定義した場合プロトコルはそれを利用する側の層に属すると言いましたが、それを踏まえると言葉が冗長になってしまうのでここではプロトコルもそれに準拠する(利用される)側の層に属することとして話をします。  
まずObjectAを外部機構を通して操作するためのObjectARepositoryをInterface Adapter層として定義するとした場合、私が指摘しているのはここでData層でもObjectADataClientと定義しているようなケースです。  
コードでいうと以下のようになります。(この例では同期・非同期の話は関係ないので、Data層側は単純に出力を返り値で返すこととします。)

Data層側のコード
```
protocol ObjectADataClientType {
   func fetch() -> ObjectA
}

class ObjectADataClient: ObjectADataClientType {

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```

Repository(Interface Adapter)層側のコード
```
protocol ObjectARepositoryType {
   func fetch() -> ObjectA
}

class ObjectADataClient: ObjectADataClientType {

   private let dataClient: ObjectADataClientType
   
   init(dataClient: ObjectADataClientType) {
      self.dataClient = dataClient
   }

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```


RepositoryがDomain層のオブジェクトを返り値とするのはInterface Adapterの性質上おかしくないのですが、Data層であるクラスがDomain層のオブジェクトを返すような設計だとData層はBusiness Logicに依存しており、クリーンアーキテクチャの特徴である「Infra層は独立している」を満たせていません。  
また上の例のコードを見て気づいた方もいると思いますが、このような設計ではリポジトリとデータクライアントのインターフェースが同じなのでリポジトリはただデータクライアントのメソッドを呼び出して自身は何もしていないように思えます。  
さらに、上の例ではただ一例挙げただけでしたがアプリケーション全体のことを考えた場合どうなるでしょうか？   
仮にあるアプリケーションでObjectA~Zまでの26のオブジェクトをリポジトリで操作する場合一つ一つのオブジェクトに対して、リポジトリクラス(プロトコル)とデータクライアントクラス(プロトコル)を定義・実装しなければならず、さらにこれらのオブジェクトのどれかに仕様変更が起こった場合も両方に対して変更を適用しなければなりません。  
これはとても冗長で柔軟性のない設計になってしまっていると思います。  


Data層が出力するデータ形式は基本的にSwiftのData型であり、Interface AdapterはData層の出力したData型をドメインオブジェクトの形式に型変換するのが正解だと思います。  
またData層に対応するProtocolは可能な限り集約するべきでしょう。
ここでいう集約するとは例えばData層でWebAPIクライアントを定義しようとする場合、プロトコルは操作するオブジェクト毎に定義するのでなくWebAPIのインターフェースで統一します。  
コードで言うと以下のようになります。(この例でもこちらの意図したい箇所と関係ないので非同期の考慮はなされていませんし、メソッドのパラメーターなども不足している部分もあります。)

```
protocol WebAPIClientType {
   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data
}

```

このようにData層の出力をData型にして、プロトコルをWebAPIのインターフェースに合わせることでData型からDomain層のオブジェクトへのデータ変換は本来のInterface Adapter層の責務となり、またData層はビジネスロジックの仕様から独立してるのでコードの冗長さがなくなります。  

Data層のプロトコルをオブジェクト毎ではなくWebAPIのインターフェースに合わせることで、Data層でなんのオブジェクトを取得するか決定するのはData層自身ではなくData層を呼び出すInterface Adapter層の責務となるためInterface Adapter層はData層のクラスを再利用することが可能となります。  

図にするとこんな感じです。  

もちろんWebAPIとデータベースではプロトコルを別に定義する必要がありますが、Data層で異なる外部機構のインターフェースを統一するのは性質上不可能なので外部機構ごとにプロトコルを定義するのは致し方ないことだと思います。  

Data層ではそのビジネスロジック固有の事情から独立するように設計しましょう。  
そうすることで関心の分離が保たれて、Data層のコードの冗長さがなくなります。

>　補論: RepositoryとDAO
>　

## レイヤードアーキテクチャ+クリーンアーキテクチャ+αで設計について考える
