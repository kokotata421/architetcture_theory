
# iOSアプリでスケールしやすいアーキテクチャを考えてみた(準備編)

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)**設計を理解するためのクリーンアーキテクチャ編←本記事**  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への準備編として設計の概観を理解するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  

## 前回までの内容と本記事の内容
初回であった前回の記事ではスケールしやすいアーキテクチャを考えるためにクリーンアーキテクチャを通して設計概要を理解することを最初の目的としました。  
そしてクリーンアーキテクチャの前提知識のためにその原型とも言えるレイヤードアーキテクチャの理解を深めようとしたのが前回までの内容です。

この記事ではいよいよクリーンアーキテクチャを学び、設計という全体像をまとめたいと思います。

## クリーンアーキテクチャとレイヤードアーキテクチャの共通点/相違点
まず前回で学んだレイヤードアーキテクチャとクリーンアーキテクチャの共通点、そして相違点について整理することでレイヤードアーキテクチャを理解するために必要なポイントをまとめます。
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>


前回の記事でレイヤードアーキテクチャの特徴が責務による層の分割と単一方向の依存関係による関心の分離であることを述べました。  
クリーンアーキテクチャでもこの2つが主な特徴です。  
円の中の一つ一つの色が層を示していて、また円内側の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格は理解できていると言って良いと思います。  
ただ特徴は同じでもクリーンアーキテクチャではその層の分割と依存の方法が異なります。  
そのためクリーンアーキテクチャを理解するために層の分割と依存関係の詳細について見ていきたいと思うのですが、これらを理解することはクリーンアーキテクチャが円であることを理解することとほとんど同じです。
なのでまずクリーンアーキテクチャが円である理由を踏まえながら円の各層・依存関係について理解していきたいと思います。  

## Entities = Domain層 / Use Cases = Application層
クリーンアーキテクチャが円である理由を見ていきたいのですが、その前に前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所があるのでそこから始めます。  
ちゃちゃっと終わらせるために結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層であり、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層です。   
最初にEntitiesから取り上げると円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」です。  
前回の記事でDomainとは「事業の知識・ルール」を意味していることを書きましたが、これらを比較するとEntitiesがDomainと同じであることがわかると思います。  
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesの方に書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要だと思います。  

以後EntitiesはDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため

そしてクリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか？  
実はその理由はレイヤードアーキテクチャの記事ですでに書いています。  
レイヤードアーキテクチャの記事のPresentation Domain Separationの説明でビジネスロジックを「アプリケーションプログラムの機能的中心」と表現したのですが、まさにこれがビジネスロジックであるDomainとApplicationが円の中心にいる理由です。  

もう少し理由を具体的に書くと以下のようになります。  

1. サービスのアイディアを具体化したものがビジネスロジックのデータやロジックであり、ビジネスロジックなしではアプリケーションは成立しない。  
2. ビジネスロジックはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. ビジネスロジックは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

1については「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、プログラム化したものがDomain層であり、それをさらにアプリケーションとして提供するために書かれたコードがApplication層です。  
UI層はそのサービスをユーザーへ提供する窓口として存在し、Infraはそのサービスの実現手段として必要であって、ビジネスロジックなしにアプリケーションが生まれることはありません。    

(2について)またそれはビジネスロジックがアプリケーションの中で相対的に変わりづらい箇所であることも意味しています。(ここでいう「変更」はアプリケーションの仕様変更によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。)  
UIやInfraはビジネスロジックが変わることがなくてもUXや技術的なパフォーマンスの観点から変更することはあります。  
それに対してサービスの仕様が変更された場合はビジネスロジックも変更されますが、それに応じて必ずUIやInfraも変更を迫られることになります。  
このようにビジネスロジックはアプリケーションの機能的中心でサービスそのものであるため、ビジネスロジックの定義が変わる場合はそれに応じて他の層も変更する必要があります。  

3はどちらかというと「ビジネスロジックが円の中心である理由」というよりも「ビジネスロジックが他の層から切り離される理由」といった方が良いかもしれません。   
ただ純粋なプログラミング言語の定義によってのみ成立する理由は、結局そのサービスの核心にあるため外部技術に依存していないという話につながります。  
これらがビジネスロジックが円の中心にある理由です。  

そしてクリーンアーキテクチャの各層の依存は円の外側から内側へ向いているわけですが、これらを踏まえてクリーンアーキテクチャとレイヤードアーキテクチャを比較するとクリーンアーキテクチャはより現実を反映させた設計であると言えます。  

レイヤードアーキテクチャは技術的な側面から依存関係を決定したため、技術的な基盤となるInfraがアプリケーションを支えていると捉え「UI->Application->Domain->Infra」という構成でした。  
それに対してクリーンアーキテクチャではアプリケーションの機能的中心であるビジネスロジックがアプリケーションを支えていると捉え、他の層がビジネスロジックに依存しています。  
これはクリーンアーキテクチャのこの構造は開発の実態をより捉えています。  
アプリケーション開発において技術的にはインフラに依存していても、サービス的に依存しているのはビジネスロジックであり開発はビジネスロジックを起点に動きます。  
私たちの日々の業務も技術的にはインフラであるインターネットに依存しつつも、その活動はビジネス的な事柄に依存しています。  
 
このようにクリーンアーキテクチャが円で表現されている理由は、技術的(レイヤードアーキテクチャ)には4層の中間に位置するビジネスロジックをアプリケーションの基盤と捉えそれを中心としてアプリケーション設計を示すためです。

