
# iOSアプリでスケールしやすいアーキテクチャを考えてみた②-設計を理解するためのクリーンアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)**設計を理解するためのクリーンアーキテクチャ編←本記事**  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への準備編として設計の概観を理解するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  
また本記事はレイヤードアーキテクチャの知識を前提としていますので、レイヤードアーキテクチャがわからない方は前の記事から読むことをオススメします。  

## 前回までの内容と本記事の内容
初回である前回の記事ではスケールしやすいアーキテクチャを考えるためにクリーンアーキテクチャを通して設計概要を理解することを最初の目的としました。  
そしてクリーンアーキテクチャの前提知識としてその原型とも言えるレイヤードアーキテクチャの理解を深めたのが前回までの内容です。

この記事ではいよいよクリーンアーキテクチャを学び、設計の概要を捉えたいと思います。

## 記事内の用語の表記ルール 
前回に引き続きアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。    

例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logicとし、InfrastructureはInfraと省略して表記します。  



## クリーンアーキテクチャとレイヤードアーキテクチャの共通点/相違点
まず前回学んだレイヤードアーキテクチャと今回学ぶクリーンアーキテクチャの共通点、そして相違点について整理することでレイヤードアーキテクチャを理解するために必要なポイントをまとめます。   
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>


前回の記事でレイヤードアーキテクチャの特徴が責務による層の分割と単一方向の依存関係による関心の分離であることを述べました。  
クリーンアーキテクチャでもそれは変わりません。    
円の中の一つ一つの色が層を示していて、また円内側の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格はつかめているといえます。  
ただ特徴は同じでもクリーンアーキテクチャではその層の分割と依存の方法が異なります。  
そのためクリーンアーキテクチャを理解するためにまず、その層の分割と依存関係の詳細について見ていきたいと思うのですが、これらを理解することはクリーンアーキテクチャが円である理由を理解することと同じです。  
なので最初にクリーンアーキテクチャが円である理由を踏まえながら円の各層・依存関係について理解していきたいと思います。  

## Entities = Domain層 / Use Cases = Application層
クリーンアーキテクチャが円である理由を見ていきますが、その前に前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所があるのでそこから始めます。  
ちゃちゃっと終わらせるために結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層であり、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層です。   
最初にEntitiesから取り上げると円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」です。  
前回の記事でDomainとは「事業の知識・ルール」を意味していることを書きましたが、ここからEntitiesがDomainと同じであることがわかると思います。    
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesの方に書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要でしょう。

以後EntitiesはDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため

クリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか？  
実はその理由はレイヤードアーキテクチャの記事ですでに書いています。  
レイヤードアーキテクチャの記事のPresentation Domain Separation(以下PDSと表記)の説明でビジネスロジックを「アプリケーションプログラムの機能的中心」と表現しましたが、まさにこれがBusiness LogicであるDomainとApplicationが円の中心にいる理由です。  

もう少し具体的に示すと以下のようになります。  

1. サービスのアイディアを具体化したものがビジネスロジックのデータやロジックであり、ビジネスロジックなしではアプリケーションは成立しない。  
2. ビジネスロジックはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. ビジネスロジックは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

1については「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、プログラム化したものがDomain層であり、それをさらにアプリケーションとして提供するために書かれたコードがApplication層です。  
UI層はそのサービスをユーザーへ提供する窓口として存在し、Infraはそのサービスの実現のための手段として必要であって、ビジネスロジックなしにアプリケーションが生まれることはありません。    

(2について)またそれはビジネスロジックがアプリケーションの中で相対的に変わりづらい箇所であることも意味しています。(ここでいう「変更」はアプリケーションの仕様変更によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。)  
UIやInfraはBusiness Logicが変わることがなくてもUXや技術的なパフォーマンスの観点から変更することがあります。  
それに対してサービスの仕様が変更された場合はBusiness Logicも変更されますが、それに応じて必ずUIやInfraも変更を迫られることになります。  
このようにビジネスロジックはアプリケーションの機能的中心でサービスそのものであるため、ビジネスロジックの定義が変わる場合はそれに応じて他の層も変更する必要があります。  

3はどちらかというと「ビジネスロジックが円の中心である理由」というよりも「ビジネスロジックが他の層から切り離される理由」といった方が良いかもしれません。   
ただ純粋なプログラミング言語の定義によってのみ成立し外部技術に依存しない理由は、結局そのサービスの核心にあるため外部に依存していないという話につながります。 



そしてこうしたDomainとApplicationを中心に据えたクリーンアーキテクチャはレイヤードアーキテクチャと比べてより現実を反映させた設計であると言えます。  

レイヤードアーキテクチャは技術的な側面から依存関係を決定したため、技術的な基盤となるInfraがアプリケーションを支えていると捉え「UI->Application->Domain->Infra」という構造でした。  
それに対してクリーンアーキテクチャではアプリケーションの機能的中心であるビジネスロジックがアプリケーションを支えていると捉え、他の層がビジネスロジックに依存しています。  
クリーンアーキテクチャのこの構造はアプリケーション開発の実態をより正確に捉えています。  
アプリケーションは技術的にはインフラに依存していますが、サービス的に依存しているのはビジネスロジックであり開発はビジネスロジックを起点に動きます。  
そのためビジネスロジックを中心として他の層と切り離すことで、実務で発生する要件に柔軟かつ迅速に対応することが可能になるのです。  
私たちの日々の業務でも技術的にはインフラであるインターネットに依存しつつもその活動はビジネス的な事柄に依存していますが、それと同じです。

このようにクリーンアーキテクチャは技術的(レイヤードアーキテクチャ)には4層の中間に位置するビジネスロジックをアプリケーションの基盤と捉えそれを中心としたアプリケーション設計であり、それを
図で示すために円の形となっています。  

## Framework & Drivers層とInterface Adapter層
クリーンアーキテクチャがなぜ円なのかについて理解したところで、クリーンアーキテクチャの層でまだ説明されていないFrame & Drivers層とInterface Adapter層を説明していきます。  
### Framework & Drivers層
まず一番外にあるFrame & Drivers層から見ていきます。  
円を見てみるとこの層にはUI/Web/DataBase/Devices/External Interfacesとさまざまなものが表記されており、レイヤードアーキテクチャでいうUIとInfraが含まれていることになります。  
この層ではレイヤードアーキテクチャで異なる層であったUIとInfraが一つの層とされているわけですが、私たちは既に同様のケースを前回の記事でも見ています。  
PDS(以下)のPresentationです。  
PDSのPresentationにはUIのみならずInfraも含まれることを前回の記事で説明しましたが、クリーンアーキテクチャでも同様に同じ層として扱っているのはこの2つが以下の共通点を持っているためです。  
- 仕様の変更によってコードが変化しやすい
- 外部技術に依存している

こうした特徴を持った層に他の層が依存しているような設計だと、その層の変更による影響が他の層にも広がってしまい柔軟な開発を行うことが難しくなります。  
そのためクリーンアーキテクチャではこれらの特徴を持ったUI/Infra層を他の層から依存されないように同じ最外層に置いているのです。

もちろんクリーンアーキテクチャを採用した場合、UI層とInfra層はどこからも依存されないという共通の立ち位置にありながらも実際に提供している機能は大きく異なるため開発時には区別される側面もあります。  
このような層の分け方を見てもクリーンアーキテクチャはレイヤードアーキテクチャのようにアプリケーションにおいて提供している機能によって責務を捉えるのではなく、開発における性質というより抽象的な責務を捉えた設計であることがわかります。  


ちなみにFramework&Driversの意味はFrameworksはフレームワーク、つまりiOSのUIKit等パッケージ化された外部技術を指しており、DriversはIT用語でシステムに装着する外部装置を意味するのでこの層はビジネスロジックをアプリケーションプロダクトとして完成させるために必要な外部技術群と言えると思います。  

### Interface Adapter層

さて、残る一つはInterface Adaptersです。  
Interface Adapterという言葉だけ聞くとなにやら難しく感じてしまうのですが、簡単にいうとこの層は内側のBusiness Logicと外側のFramework&Drivers層を繋ぐための仲介役を担う層です。

円図ではこの層に該当するコンポーネントとしてController/Presenter/Gateway等が書かれていますが、基本的にこれらのうちControllerとPresenterがUIとビジネスロジックの、GatewayがBusiness LogicとInfraの仲介役を担っていると捉えて問題ないでしょう。  
iOSMVCのControllerに当たるViewControllerもここに属し、円図でいうController/Presenterを担っています。    
ややこしいのですが、MVCアーキテクチャの文脈でいうControllerと円図に書いてあるControllerは意味が異なります。  
私たちにとってはControllerというと画面の入出力処理を担うMVCアーキテクチャのControllerが馴染み深いと思いますが、ITの一般的なControllerは入力のみに関する処理装置を意味していて出力に関する意味は含まれていません。  
これはMVPのPresenterにも同じことが言えて、Presenterは一般的には出力のみに関する処理装置を指しているので、MVPのPresenterは円図でいうControllerとPresenterの両方の責務を担っていることになります。  

このInterface Adapters層が担う層の仲介という責務はレイヤードアーキテクチャでは存在していなかったのですが、実際に開発で実践してみるとこの層の重要性に気づきます。  
層同士が連携して責務が混ざり合った箇所を一つの独立した層と捉えることで各層責務の純度が格段に上がるのです。  
  
レイヤードアーキテクチャの機能的な責務によるアプリケーションを明確に分割していますが、それはあくまで理論上の話であって、実際のアプリケーションでは各層が連携して一つのアプリケーションとして動作するため複数の層の責務が交わって境界線が曖昧な部分が発生します。   
例えばDomain層ではビジネス的な事柄が関心の対象なので、永続化機構でデータを更新するためのURLやそのためのデータ形式の変換に関心を向けるべきではありません。  
ただ一方でInfra層ではデータを永続化するという汎用的な責務を担ってはいるものの、特定のURLやそれに関する処理はそのアプリケーション(ドメイン)固有なものなのでInfra層がその責務を負うのはおかしなことです。  
このようにレイヤードアーキテクチャによる層の分割を実践しようとするとその層の境界線でどっちつかずな責務が発生してしまい、このような曖昧な責務は基本的に妥協の末に利用している側(上の例ではDomainがInfraを利用しているのでDomain)に実装されるようになります。  
理論が現実と完全に合致しないことはしょうがないことではありますが、これではレイヤードアーキテクチャの目的である関心の分離が達成されないため理論の明らかな欠陥です。
この問題を解決するためにクリーンアーキテクチャではレイヤードアーキテクチャの層が連携する責務も一つの独立した層として捉えました。  
こうすることで円の内側のビジネスロジックと外側のFramework & Drivers層に不純な責務が入らないことをアーキテクチャレベルで示し、そしてレイヤードアーキテクチャで不純と見なされた層の境界線にあった責務をデータの変換を担う「Interface Adapter層」として捉え、各層の責務の純度を高く保つことができるようになりました。  

ちなみに円図では表記されていませんが、開発でよく耳にするRepositoryコンポーネントもこのInterface Adapters層に入ります。  
Marin Flower氏の定義を引用するとRepositoryはDomain層とData層の仲介役であり、まさにInterface Adapter層のコンポーネントです。(引用文のdata mapping layersはData層を指しています。)
>A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection  
円図でいうとGatewaysというカテゴリの中に含まれていると考えればよいと思います。   

またGatewayという名前はクラス名としてはあまり聞き慣れないと思いますが、ネットワークの文脈では異なる層の中継役を担う装置を指しており、クリーンアーキテクチャでも同様の意味です。  　　

私はInterfaceAdapter層のクラス名を命名するとき、できる限り具体的なControllerやRepositoryといった名前を使うようにしていますが適切な名前が見つからない時はGatewayの名前を使うようにしています。  
Gatewayは広範囲を示す名前ではありますが、プロジェクト内で乱用されるような名前ではなくそれだけでInterface Adapter層のコンポーネントだと伝わると思うので「~Managerクラス」や「~Serviceクラス」等より責務が明確で便利な単語だと思います。  

## クリーンアーキテクチャの依存ルール
クリーンアーキテクチャでの依存は外側の層から内側の層であること、また外側の層の仕様は変わりやすく内側の層の仕様は変わりづらいことを説明しました。  
つまりクリーンアーキテクチャの依存は変更されやすい外側の層から変更されにくい内側の層へ向いており、こうすることで外側の層の変更のされやすさのアプリケーションへの影響を最小限に抑えています。  
ただ技術的に依存しているのはInfra層のはずなのに、Infra層がビジネスロジックに依存するということはどういうことなのでしょうか？  
これについてはこの後クリーンアーキテクチャを実践するためのルールを守るためのテクニックという節で説明します。  

## クリーンアーキテクチャの概要を一度整理する 
ここまででクリーンアーキテクチャの特徴は一通り触れました。  
しかしレイヤードアーキテクチャの理解を前提としていたため、とりあえず要点のみ駆け足で説明した感じが拭ません。    
なのでこれまでの内容と重複する部分もありますが、ここで一度クリーンアーキテクチャの原文に沿った形でその概要を整理したいと思います。  

### クリーンアーキテクチャの特徴   
クリーンアーキテクチャの記事の冒頭では、ヘキサゴナルアーキテクチャ・オニオンアーキテクチャなどのシステムアーキテクチャを紹介しています。  
システムアーキテクチャとは厳密な意味は私もはっきり理解しているわけではないですが、とりあえずここではアプリケーションの特定の領域にこだわらずシステム全体を関心の対象としているアーキテクチャと捉えれば問題ないでしょう。  
そしてそれらのシステムアーキテクチャの特徴として以下の共通点があると述べています。  

1. 関心の分離  
どのシステムアーキテクチャも関心の分離を基本として、少なくともビジネスロジックとその他の2層に分けようしています。
2. UI/WebAPI/データベース/フレームワークといった外部技術が独立している  
アプリケーションのうち変更されやすいUI/Web API/データベース/フレームワーク等のコードにどこからも依存しない。  
このような外部技術は便利なものの、同時に開発時の制約も発生するためこれらに依存しないようにすることで柔軟な開発が可能になります。  
3. テストしやすい  
ビジネスロジックが特定の外部技術に依存していないためテストが容易になります。  
またのちに見るように層の依存関係をclassなどの実体型で実現するのではなく、プロトコルを利用した抽象型によって実現することでビジネスロジック以外の層でもテストがやりやすくなります。 

そしてこうした特徴を図としてまとめたものがクリーンアーキテクチャの円図であり、円の外側の層ではデータベースやUIなど特定の具体的な技術、内側の層にはビジネスに関するロジックとデータが示されていて、円の外側から内側にいくにつれてプログラムで表現しているものが抽象的になっていきます。　

ちなみに原文には必要であればもっと層を細かくわけても構わないと書かれています。  
ただ該当箇所の小見出しには「Only Four Circles?(4つの層だけ?)」と書かれており、基本的に4つの層より多くなることはあっても4つの層より少なくなるようなことはないという考えのようです。   
私としても責務の分離を目的とするなら少なくともBusiness Logic/Interface Adapters/Framework&Driversの3層は必要だと思いますし、Business Logicも設計者がBusiness Logic内での層の分割を意識してるかどうかは別としてその中で責務をしっかり分けていくと実質的にはDomain/Applicationの分離が生まれてくると思うのでこの4層をベースとして必要であればそれ以上に層を分けるというスタンスで良いのかなと考えています。  

### クリーンアーキテクチャで守るべきルール  
クリーンアーキテクチャの特徴を保つために開発者が守らなければいけないルールが大きくいって2つあります。

#### ルール1: 円の内側の層は外側の層については知らない何も知らないし、影響も受けない
  
Business Logicは外側の層について何も知らなくても独立して動作できるようになっている必要があります。  
またBusiness Logic内のDomainとApplicationに関しても同様で内側の層であるDomainは外側のApplicationについて知っているべきではありません。  
クリーンアーキテクチャではこのようにアプリケーションとして動作するため各層は連携しつつ、可能な限り関心を分離することを目的としているので依存して良いのは外側の層から内側の層へのみということになっています。  

ただこのうち「Interface Adapter」は少し例外といえます。   
既に説明した通り「Interface Adapter」は内側と外側の層の中継役となる層なので直接的にではなくても外側の層の事情を知ることになるからです。  
具体的に説明すると、UI側のInterface Adapter層はUIの仕様によって自身の入力・出力の処理を変更することになるので直接UIを知らなくても間接的にその仕様について知っていることになりますし、Infra側のInterface Adapter層もデータベースかWebAPIかでインターフェースが異なるので実体型としてデータベースやWebAPIを参照していなくともメソッド名やその引数から外側の層の事情はある程度把握できますし、データベースからWebAPIへの移行時にコードへの影響は避けられません。    
原文の記事でも冒頭で  
>Nothing in an inner circle can know anything at all about something in an outer circle.  
>
>意訳  
>内側の層は外側の層について全く知らないこと。  

と強調しながらも、Interface Adapter層の説明でSQLデータベースを例に出しながらInterface Adapter層で外側の層を知っていることは致し方ないことだと書いています。(ただ同時に外側の層がInterface Adapter層に与える影響は必要最低限に留めることも強調しています。)
>If the database is a SQL database, then all the SQL should be restricted to this layer, and in particular to the parts of this layer that have to do with the database.
>
>意訳  
>もしデータベースがSQLならば、SQLに関するコードはInterface Adapter層の内データベースと関与する箇所のみにとどめるべきである。  

#### ルール2:層をまたぐオブジェクトはシンプルなデータ構造であること
アプリケーションとして動作するためには層同士で連携してオブジェクトの受け渡しを行う必要があるのですが、これをネガディブに表現すると層の責務の漏出ということになります。  
どんなに正当な理由があろうともある層のオブジェクトが他の層に渡されて利用されるということは、層同士の関心の分離が破られてしまうことになるからです。  
クリーンアーキテクチャではこうした状況でも関心の分離をできる限り徹底するため、層をまたぐオブジェクトはシンプルなデータ構造であることをルールとしています。  

もし層をまたぐオブジェクトが複雑な処理のメソッドを持っていた場合、またいだ先の層でもそのメソッドの呼び出しが可能であるためそのメソッドを通して複雑な処理が行われて責務が他の層へどんどん漏出していく恐れがあります。  
なにより受け渡し元の層からしたらメソッドを持ったオブジェクトが受け渡し先でどのように利用されるのか想定しきれないため、開発における不確実性が高まりバグの温床となります。  

それに対してこの層をまたぐオブジェクトがメソッドを持たないデータ構造である場合は、他の層に漏れる責務はそのデータ構造のみとなり受け渡し元で制御可能となります。  

このように層をまたぐオブジェクトをシンプルなデータ構造にすることによって、層の責務の漏出は必要最低限かつ予測可能なものとなり関心の分離は高い水準に保たれます。  

細かい話ですが、ここでいうメソッドを持ったオブジェクトとはある層の責務が漏れてしまうような処理を持っているものを指し、Swiftの配列Arrayなどの型は含まれません。  
例えば銀行アプリでお金の計算をするのはApplication層またはDomain層の責務ですがそのようなお金の計算処理をメソッドとして持つDomain層のオブジェクトをInterface Adapter層であるViewModelに渡してしまった場合、ViewModel側でもお金の計算が可能になってしまうためViewModelにDomain層の責務が漏れてしまっていることになります。  
それに対してArray型などSwiftが既存で提供している型はメソッドを持ってはいるもの、そのメソッドが影響を与えるのはそのデータ構造のみであり決して層の責務が漏れることはありません。  

ここに関しては他にも何を持ってデータ構造が「シンプル」であるのかという問題もあります。  
「シンプルなデータ構造」を厳密に言葉で定義しようとするとなかなか難しいのですが、ここでいうシンプルさというのは何度も言っているように層の関心を分離するためであってそれを無視して設計してしまうとおかしくなります。  
再び具体例を出すとUI側でユーザ名が必要な場合ViewModelではApplication層にユーザー名の取得を要求しますが、この時にユーザー名を含めたアプリケーションに関する全ての情報を含んだデータを渡されても完全に情報過多です。  
開発時に最初から関わっている人はその特殊な事情を知っているかも知れませんが何も知らず新しく入ってきた開発者はユーザー名の取得のためにわざわざアプリケーションに関するすべての情報を取得しあまりに多くの知識がApplication層からViewModelに漏れていることに「何か自分が理解できていないことがあるのでは？」と気を揉むことになるでしょう。    
  
また反対にユーザー名の取得のためにユーザー名のみ返す場合はそれはシンプルなデータ構造を渡しているといえますが、こうなるとユーザーの電話番号、口座番号とUI側で必要な個々の情報に応じてApplication層側に取得メソッドを定義する必要があり、それはすなわちApplication層の定義がUIの仕様に影響を受けていることになるので関心の分離ができていません。  

例に出したケースでは、基本的にはユーザー名が取得したい場合はApplcation層はユーザー情報をViewModelに渡して、ViewModel側でユーザー情報からユーザー名のみ利用するというのが正解だと思います。  
ユーザー情報はアプリケーションの仕様として一つのまとまった情報単位であることは間違いないですし、もしこのユーザー情報という単位に変更が必要な場合はそれはUI側の事情ではなくアプリケーションの事情によるものであると言って良いでしょう。

ここで出した例をもとに層をまたぐシンプルなデータ構造を持ったオブジェクトをもう少し正確に説明すると、「受け渡す二つの層のうち内側にある層の仕様を基準に設計されたシンプルなデータ構造」と言えます。  



ちなみに話が何度も逸れて申し訳ないですが、上の例でInterface Adapter層がDomain層のデータを受け取ることに違和感を持つ人もいるかも知れません。  
クリーンアーキテクチャの円図で言うとInterface Adapter層が関わるのはApplication層で直接Domain層と関わることはあり得ないからです。    
ただ実際の開発ではApplication層がInterface Adapter層にデータを渡す際にはDomain層のデータを渡すことが多いです。  

#### ルール3：データフローは一方向
これはクリーンアーキテクチャの原文に明言されているわけではないのですが、クリーンアーキテクチャを実践するさいには自然とこれを守るようになりますし、また設計という観点からみてもデータフローが一方向であるということは重要なことなのでルールとして加えました。  
クリーンアーキテクチャの右下の図はデータフローにも関係していることなので、それを用いて説明します。  
以下の図では正確には他のことにも言及しているのですが、とりあえずここではデータフローについてのみ説明します。  

アプリケーションに関するデータフローを円図に沿ってたどっていくと、入力は円の外側のUIから起こり、その処理のため内側のBusiness Logicに入っていき、再びその結果は出力先であるUIに向かうため円の外->内->外と流れていき一見クリーンアーキテクチャの依存関係のように綺麗に一方向になっていない印象を抱かせますが、それはこの円図がデータフローではなく依存関係に着目して作られているからであって実際のところデータフローも一方向となっているべきです。  

具体的に説明すると最初に出した図が表しているように円図のデータフローはContrller->UseCase(Applciation)->Presenterとなっているように、円の外->内->外といっても最初に外から内へ入る時と、そのあと内から外へ出ていく時の経路が異なるため実質的にデータのフローは一方向となっているのです。  

これはMVCのControllerやMVPのPresenter等、一つのコンポーネントが画面の入出力を担当している場合も同じことが言えます。  
これらのコンポーネントでは一つの中に入出力の責務がありながらも、実際のコード上では入力と出力の責務が交わらないように設計されていることが前提となっています。    
同じコンポーネントを通しているのにデータフローは別というのはおかしいと思う方もいるかも知れませんが、これは別に詭弁であるわけではありません。  
繰り返しになりますが、まず第一に重要なことはデータフローが一方向であるということであって、MVCのController等をまねして一つのコンポーネントに入出力をまとめることではありません。  
もしあなたが入出力を一つのコンポーネントにまとめた場合、入力と出力で切り離すことが不可能だと考えるならクリーンアーキテクチャのControllerとPresenterのように別々のコンポーネントで定義するべきです。  
しかし実際にはしっかりと設計をすれば、ほとんどのケースで一つのコンポーネントでも入出力の切り離しは可能であり、それにも関わらずわざわざ入力と出力で別々のコンポーネントを定義するのは手間であるため一つのコンポーネントとして定義しているのがMVCのControllerやMVPのPresenterだと考えた方が良いでしょう。  

のちに見るように開発時、入出力で一つのコンポーネントにまとめている場合でもProtocol上は入力用と出力用で別々に定義してそれら両方を一つのコンポーネントが採用しているというケースが多いです。  

そのようなケースでクリーンアーキテクチャ全体のデータフローを示した一例を下に載せときます。  


### ルールを守るためのテクニック
クリーンアーキテクチャには以上のルールを守るためのテクニックとして依存関係逆転の原則(Dependency Inversion Principle)があります。    
依存関係逆転の原則は
依存関係逆転というと難しそうに聞こえるのですが、要はあるコンポーネントに依存するとき実体クラスではなくインターフェース(プロトコル)に依存しようというだけです。
なぜインターフェースに依存することが「逆転」なのかというと、インターフェースの定義は利用する側の層に属していると考えられているからのようです。
そのため今まで利用するクラスが利用されるクラスに依存していたものが、利用されるクラスが利用する側の層のインターフェースに依存していると捉え「逆転」していると表現しているようです。(wikiの「依存性逆転パターン」参照)
簡単な例を書きます。
ViewAはそのクラス内でModelBを利用している時、ViewAはModelBに依存しておりViewA->ModelBといえます。
この依存関係に依存関係逆転の原則を適用するということは、ModelBの役割をインターフェースとして抽出してModelBProtocolを定義した上で、ViewAはModelBではなくModelBProtocolに依存してModelBもModelBに依存する(ModelBを採用するともいえます)ということです。
図で示すと以下の通りです。
図
この依存関係の逆転の原則がクリーンアーキテクチャで示す役割は以下2つといえます。
①テストが容易になる(各コンポーネントの独立性が高くなる)
言葉の通りですが、この後の例で同じく説明します。
②インターフェースを通して実質的に内側から外側へのアクセスを可能にする
クリーンアーキテクチャでは内側から外側への依存は禁止されています。
なのでインターフェースを使っていたら、内側から外へアクセス可能というのは表面的なレトリックのように聞こえますが、このテクニックがただの形式的なものではないというのはこの後の例で説明します。
ここでより実践的な例を使って具体的にみていきたいと思うのですが、クリーンアーキテクチャの図の右下にある図はちょうどそれに関するものであるためそれに沿って依存関係逆転の原則をもう少し具体的にみていきたいと思います。
この図です。
始めに言っておきたいのが登場コンポーネントはController/Presenter/UseCaseですが、ここでいうControllerはUIの入力に対する処理を行うクラスであり、PresenterはUIへの出力を処理するクラスでです。なのでMVCの"Controller"やMVPの"Presenter"とはそれぞれ意味が微妙に異なります。
図を見ればわかるとは思いますが、まず概要としてここで想定されている状況はUIからイベントを「Controller」が受け取り、その入力によって「Controller」は「UseCase」に処理を依頼し、「UseCase」は処理の結果をUIに表示するための「Presenter」に渡すというケースです。
簡易的に表すとController->UserCase->Presenterという流れです。
図
この状況を依存関係逆転の原則を適用せずにコードで実現しようとすると以下の問題が発生します。
わかりやすいように先程の依存関係の逆転の原則のクリーンアーキテクチャにおける2つの役割と対応させます。
①ControllerクラスがUseCaseクラスに依存しているため、Controllerのテストがしづらい
ControllerクラスはUseCaseクラスに依存している場合、ControllerクラスはUseCaseクラスが完成するまで動作確認ができないことになります。
②UseCaseクラスからPresenterクラスを呼び出すので、円の内側から外側に依存する
これは説明不要だと思います。Presenterクラスはクリーンアーキテクチャにおいて「Interface Adapter」層に属するのでUseCaseの層より外側です。そのためUseCaseからPresenterへの依存はクリーンアーキテクチャのルールに反します。
以上の問題を解決するため依存関係の逆転の原則を適用します。
それによる変更点は以下2点です。
・Controller->UseCaseの関係性で、UseCaseInputPortインターフェースを定義して利用する。
ControllerはUseCaseInputPortを呼び出し、UseCaseはUseCaseInputPortを採用する。
図
・UseCase->Presenterの関係性で、UseCaseOutputPortインターフェースを定義して利用する。
UseCaseはUseCaseOutputPortに結果を渡し、PresenterはUseCaseOutputPortを採用する。
図
これにより先程挙げた2つの問題が解決されます、一つずつみていきましょう。
①ControllerクラスがUseCaseクラスに依存しているため、Controllerのテストがしづらい
↓
ControllerクラスはUseCaseクラスではなく、UseCaseInputPortインターフェースに依存することになりました。
このためControllerクラスのテストのためにはUseCaseクラスは必須ではなくなり、UseCaseInputPortインターフェースを採用したクラスさえあればテスト可能になりました。このため簡易的なUseCaseInputPortインターフェースに適応したクラスを作成する等により以前より簡単にテストを行うことができます。
②UseCaseクラスからPresenterクラスを呼び出すので、円の内側から外側に依存する
↓
依存関係逆転の原則ではインターフェースの定義は利用する側に属していると説明しました。
そのためUseCaseOutputPortはUseCase層に属していることに、円の内側から外側に依存していることにはならなくなりました。
私がこれを表面的なレトリックではないと言ったのは、これにより円の内側から外側への依存を禁止している目的を満たしているためです。
「円の内側から外側への依存禁止」の目的は「関心の分離」と同時に「変わりやすい円の外側のコンポーネントの変更を容易にすること」です。
そしてUseCaseOutputPortインターフェースの定義により、UseCaseクラスが処理結果である値を渡すのはPresenterクラスである必要はなくなりました。
UseCaseOutputPortのインターフェースを採用していればどんなクラスでもOKであり、UseCaseOutputPortにあたる実体クラスが変更されてもUseCaseクラスは何も変更する必要はありません。
これによってUseCaseの層は外側のInterface adapter層に関心を払う必要がなくなり、Interface adapter層はその実体クラスを容易に変更することができるようになりました。
これは「円の内側から外側への依存禁止」の目的を十分に満たしていることになり、このインターフェースによる依存関係の変化が単なる表面的なものでないことを示していると思います。
クリーンアーキテクチャが教えてくれていること
ここまでで説明が一通り終わりましたので、まとめとしてクリーンアーキテクチャから学べることを簡単に書きます。
ここに書かれていることはレイヤードアーキテクチャなど類似のアーキテクチャにも当てはまると思います。
①MVC等のGUIアーキテクチャでは直接言及されていないコンポーネントをどう扱えば良いか教えてくれる
円図を見ればわかる通り、クリーンアーキテクチャではDeviceなど他のアーキテクチャではあまり言及されていないコンポーネントをどこにおけば良いか教えてくれています。
このように具体的な名前を出してアーキテクチャの中で言及してくれるのは開発者にとっては地味に大きいんではないでしょうか。
自分が利用しようと思うコンポーネントがそのアーキテクチャのどこに当たるのかわからないと開発者は混乱します。
私はそれまでDeviceをどこにおけば良いか、他のコンポーネントとどう連携させれば良いかわからなかったのですが、クリーンアーキテクチャを勉強して納得のいく理解が得られました。
②「アプリケーションにおいて変わりづらいものを中心にして、変わりやすいものは変更しやすいよう外側に置くように設計する」という平易な主張でアプリケーションの大きな方向性を示してくれる
これは人によりけりだとは思いますが、クリーンアーキテクチャの概念はGUIアーキテクチャと比べ、人にとってわかりやすいものだと思います。
MVCなど他のGUIアーキテクチャならば何よりもまずModel-View-Controllerという構図とそれらの詳細などテクニカルな部分に目がいきがちだと感じます。
クリーンアーキテクチャもその詳細にはテクニカルな説明を含んでいますが、何よりも前面に押し出しているのは「関心の分離」などのテクニックの背後にある開発思想だと思います。
③「テスト」など開発周辺のことについても示唆的である
これも②と同様に人によるとは思いますが、クリーンアーキテクチャはその「関心の分離」や「依存関係逆転の原則」といった考えを実践していく中で「テスト容易性」や「コードの保守性」など長期の開発をしていく上で大切なポイントに気付きやすいアーキテクチャだと思います。
クリーンアーキテクチャによくある誤解
クリーンアーキテクチャについて色々と説明してきましたが、ネット上でクリーンアーキテクチャについて学んでいく中で大きく2点ほどよく誤解されているところがあると思うのでそこについて書きたいと思います。
① EntityはData(Infra)層に属しておらず、また単純なデータ型でもない
まずEntityに関する誤解です。
最初にクリーンアーキテクチャの文脈でEntityはData層に属していると記述されている記事を見かけますが、恐らくこれはデータベースの文脈と混同してしまっているため起きてしまった誤解だと思います。
すでに述べた通りクリーンアーキテクチャとは、アプリケーションにおいてそのビジネスの根底を規定しているビジネスロジックを中心に据えているアーキテクチャです。
なのでこの中心にあるEntitiesをData層だと認識してしまうと、クリーンアーキテクチャの基本思想と矛盾してしまいその理解において合点がいかない部分が出てきてしまいます。
Entitesはクリーンアーキテクチャ説明の最初で書いた通りビジネスロジックの核に当たるDomain層です。
またクリーンアーキテクチャにおけるEntityは単純なデータ型ではありません。
これはドキュメントのEntityの説明を見ればわかります。
Entities encapsulate Enterprise wide business rules. 
An entity can be an object with methods, or it can be a set of data structures and functions.
エンティティは事業全体のビジネスルールである。
エンティティはメソッドをもったオブジェクト、もしくはデータ構造と関数の集まりである。
クリーンアーキテクチャにおけるEntityはオブジェクト(モノ)ではなくルールであり、ビジネスにおけるなにかしらのロジックを持っています。
WebAPIなどから取得したオブジェクトはビジネスルールを表現するEntityの変数やメソッドのパラメーターとしてその役割の一端を担いますが、Entityそれ自体ではありません。
私としてはこのEntityという言葉はプロジェクト内でディレクトリやクラス(構造体)名として使わない方が良いと考えています。
Entityはプログラミングにおいて文脈によってさまざまな意味を持っていて誤解を生みやすい言葉ですし、Entityという言葉自体が「実体、存在」と抽象的な意味でありこの単語をコンポーネントの命名の際に利用したところで開発者がそのコンポーネントの役割を理解するための助けにはなりません。
ちなみにクリーンアーキテクチャのEntityはデータベースやDDDの文脈とも異なっていますが、クリーンアーキテクチャから派生したアーキテクチャであるVIPERとも異なっているので注意が必要です。
VIPERの記事ではEntityを
The Entity is probably the simplest element inside a VIPER structure.
VIPERの中で恐らく一番シンプルな要素である
と言った上でその例として単純なデータ構造を示しています。
②異なる層のためのデータ形式の変換はInterface Adapter層の役割である
これは「Interface Adapter層の役割における誤解」という共通点を持っていますが、 Data層よりのRepositoryとUI層よりのViewModelやPresenterで微妙に内容が異なります。
まず大前提として題にもある通りデータを異なる層に適した形式に変換するのはInterface Adapter層の役割です。
クリーンアーキテクチャの元記事のInterface Adapter層の説明には
The software in this layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency
ソフトウェアにおいてこの層はユースケース、又はエンティティ層のデータ形式を外部の層に適した形式に変換する役割を持ったアダプターの集まりである。
*原文の文意として必要ない一部を省いて表記しています。
としており、
また同様に
Also in this layer is any other adapter necessary to convert data from some external form to the internal form used by the use cases and entities
同様にこの層には外部層のデータ形式をユースケース、エンティティという内部の層に適したデータ形式に変換するアダプターも存在する
*原文の文意として必要ない一部を省いて表記しています。
としています。
要するにこのInterface Adapter層は方向関係なく、外側と内側のデータ形式を自身が渡す層に最適な形式に変換するという役割をになっています。
その上でまずUI層側であるViewModelやPresenterなどに関する話をしたいのですが、iosにおけるクリーンアーキテクチャを学ぼうとWebで調べるとUseCase内でTranslatorというコンポーネントを利用してApplication(Domain)オブジェクトをUIに適したデータ形式に変換するという記事を見かけます。
クリーンアーキテクチャではInterface Adapter層の一部の例外を除いて内部の層は外部の層の仕様の変更に影響を受けないことになっていますが、UseCase層にUI層のデータ形式に変換する役目を担わせてしまうとUseCase層は自身やEntity層の仕様が変更されていなくてもUI層の仕様の変更によりコードを変更する必要性が生まれてしまいます。
UseCase層がUI層からの影響を受けないために、UseCase(Entity)でのデータをUI層に最適な形式へ変換する責務はViewModelやPresenterといったInterface Adapter層が担うことになります。
そして次にData層側のInterface Adapterについての話ですが、私がここで具体的に言及したいのは以下のようにData層のデータクライアントインターフェースの返り値としてDomain層のデータ型を定義しているケースです。
依存関係逆転原則から考えるとデータクライアントインターフェース自体はそれを利用するInterface adapter層に属していますが、そのインターフェースを採用するクラスはData層であるので結果的にData層がDomainオブジェクトを返していることになります。
円の外側にあるData層が円の内側のDomain層を知っていても良いはずですが、それでも私がここで問題としたいポイントは「Domain層へのデータ変換をするのはInterface Adapter層の役割であること」と「外層が内層について知ることは禁止はされていないが、『関心の分離』の観点からよろしくない」ということです。
そしてこの問題は概念的な次元の話に留まらず実際の開発にも影響を与え、Data層の肥大化させDataコンポーネントを変更しづらくさせます。
具体的な例とともに説明したいと思います。
ここではオブジェクトAからZまでのドメインオブジェクトをData層を通して永続化しているとします。
もしこのケースにおいて問題を指摘したData層のデータクライアントインターフェースの返り値としてDomain層のデータ型を定義した場合以下のようになると思います。(ここで示したいのは多くのドメインオブジェクトを永続化していた場合どうなるかという話なので、パラメーターや返り値で非同期を考慮していなかったり細かい点はテキトウです。)
このようにインターフェースではオブジェクトA~Zを取得するため、26個のメソッドを定義する必要があります。
こうしてData層の返り値の段階でドメインオブジェクトの型を返すような設計にした場合、実際のクライアントクラスがWebAPIだろうがデータベースだろうがこの一つのインターフェースで十分そうです。
本来WebAPIではベースURLやメソッド等、データベースとは異なるデータをパラメーターとして扱うはずですが、このインターフェースメソッドはオブジェクト毎に定義されているのでそれぞれ固有のパラメーターはそのインターフェースを採用する実体クラスの中で解決すれば良いからです。
ただこれだとインターフェースが共有できてもデータクライアントクラスを変更しづらくないですか？
例えインターフェースが同じだろうとそれを採用する実体クラスではインターフェースに定義されているオブジェクトA~Zを取得する26個のメソッドの実装をしなければなりません。
変更されやすいはずのデータベースやWebAPIを変えるごとに26個メソッドの実装を書き直すというのはなかなか骨の折れる作業ですし、アプリケーションによってはもっと多くの永続化オブジェクトを持っている可能性はあります。
これはこの記事のタイトルである「スケールしやすいアーキテクチャ」を考えるなら望ましい状況ではありません。
こうなってしまった原因はData層がDomain層に関心を払うような設計にしてしまったがために、Domainオブジェクト毎にメソッドを定義してしまったことにあります。
ドメイン層に関する著名な設計本である「ドメイン駆動設計」の本の副題は「ソフトウェアの核心にある複雑さに立ち向かう」ですが、ここではData層は自らその複雑なDomain層に関心を払うことで自身の設計も複雑にしてしまったように思います。
またRepositoryインターフェースと比較するとわかりますが、データ層がドメインオブジェクトの型を返すような仕様にするとRepositoryのインターフェースとデータクライアントのインターフェースは同じになります。(実際の開発ではデータ層の取得するオブジェクトとドメイン層のオブジェクトは完全にイコールではない可能性はありますが、どちらにしてもそのインターフェースのほとんどが同じになるのは確かです。)
ではどうすればよいのでしょうか？
私はData層のクライアントは特定のオブジェクト型ではなくSwiftのData型に返し、そのインターフェースではリクエストの種類によって最低限のみ定義したほうが良いと思います。(詳しくは後ほど説明しますが、例えばデータベースの場合だと基本的に必要なメソッドはget/update/deleteの3つで十分なはずです。)
こうすることでデータ層のインターフェースはWebAPIとデータベースで別々に定義することになりますが、それぞれの定義とその実装はドメインの仕様には依存せず最小限となるため以前よりもWebAPIやデータベースの差し替えは行いやすいです。
そしてこの場合データベースクライアントを操作して目的なデータを取得し、またそのデータを適切にDomainオブジェクト型に変換する役目はRepositoryが担うことになります。急にRepositoryの責務が多くなったような感じがしますがもともと永続化の操作を隠蔽するのもデータを変換するのもInterface Adapter層であるRepositoryの役割なのでこれが本来の責務だと言えると思います。
文字ばかりで話が進んでしまったので、ここでここまでの内容をコードと図を使って示したいと思います。
WebAPI/データベースクライアントのインターフェース
変更後のRepository
図
以上のようにすることで、Data層とDomain層の「関心の分離」が実現され、またData層の変更容易性が高まりました。

