
# iOSアプリでスケールしやすいアーキテクチャを考えてみた②-設計を理解するためのクリーンアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)**設計を理解するためのクリーンアーキテクチャ編←本記事**  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert/Data Source編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への準備編として設計の概観を理解するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  
また本記事はレイヤードアーキテクチャの知識を前提としていますので、レイヤードアーキテクチャがわからない方は前の記事から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

### 記事内の用語の表記ルール 
#### アーキテクチャと設計
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの言葉の定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるもの  
  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっていることが多いと思うのでこの記事では上のように区別することとします。  
#### 各層の表記
記事内でアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。    
例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logic(層)と表記します。  
InfrastructureはInfraと省略して表記し、Infra層のうちデータ操作に関するものをData(層)、端末機能に関するものをDevice(層)と表現する場合があります。  

#### コンポーネント
本記事ではMVPのModel/View/Presenter、FluxのView/Action/Dispatcher/Store等、アプリケーションのオブジェクトに該当するような構成要素を**コンポーネント**と表記します。  
これは構成要素と表記してしまうとアーキテクチャの各層等、アプリケーション内の次元の異なる他の構成要素と区別がつきづらくなってしまうためです。  

## 前回までの内容と本記事の内容
初回である前回の記事ではスケールしやすいアーキテクチャを考えるためにクリーンアーキテクチャを通して設計を理解することを最初の目的としました。  
そしてその準備としてクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャの理解を深めたのが前回までの内容です。

本記事ではいよいよクリーンアーキテクチャを学び、設計についてまとめたいと思います。

## クリーンアーキテクチャとレイヤードアーキテクチャの共通点/相違点
最初に前回学んだレイヤードアーキテクチャと今回学ぶクリーンアーキテクチャの共通点、そして相違点について整理することでクリーンアーキテクチャを理解するために必要なポイントをまとめます。   
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" >


前回の記事でレイヤードアーキテクチャの特徴が**責務による層の分割と単一方向の依存関係による関心の分離**であることを述べました。  
クリーンアーキテクチャでもそれは変わりません。    
円の中の一つ一つの色が層を、また円内側の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格はつかめているといえます。  
ただクリーンアーキテクチャではその詳細が異なります。  
なのでクリーンアーキテクチャを理解するためにその層の分割と依存関係を詳しく見ていきたいと思うのですが、これらを理解することはクリーンアーキテクチャが円である理由を理解することと同じです。  
そのため最初にクリーンアーキテクチャが円である理由に触れながら円の各層・依存関係について説明していきたいと思います。  

## Entities == Domain層 && Use Cases == Application層
クリーンアーキテクチャが円である理由を見ていく前に、前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所があるので説明します。    
結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層であり、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層と同じです。     
円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」です。  
前回の記事でDomainとは「事業の知識・ルール」を意味していることを書きましたが、ここからEntitiesがDomainと同じであることがわかると思います。    
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesに書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要でしょう。

以後EntitiesではDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため

クリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか？  
実はその答えはレイヤードアーキテクチャの記事ですでに書いています。  
レイヤードアーキテクチャの記事のPresentation Domain Separation(以下PDSと表記)の説明でビジネスロジックを**アプリケーションプログラムの機能的中心**と表現しましたが、まさにこれがBusiness LogicであるDomainとApplicationが円の中心にある理由です。  

### Business Logicを円の中心に置く3つの理由
その理由をより具体的に示すと以下のようになります。  

1. Business Logicなしではアプリケーションは成立しない   
2. Business LogicはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. Business Logicは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

それぞれの詳細について説明します。  
#### 1.Business Logicなしではアプリケーションは成立しない   
Business Logicを円の中心に置く理由として3つ挙げましたが実質的にはこれこそがクリーンアーキテクチャの中心にBusiness Logicを置く理由であり、他2つはこれを別の側面から表現しているにすぎません。  
「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、プログラム化したものがDomain層であり、さらにそれをアプリケーションとして提供するためのプログラムがApplication層です。  
UI層やInfra層はそのサービスをプロダクトとしてユーザーに届ける手段として必要であって、アプリケーションは必ずBusiness Logicから生まれます。      

#### 2.Business LogicはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
またそれはBusiness Logicがアプリケーションの中で相対的に変わりづらい箇所であることも意味しています。<sup>[*1](#footnote1)</sup>  
UIやInfraはBusiness Logicが変わることがなくてもUXや技術的なパフォーマンスの観点から変更することがあります。  
それに対してサービスの仕様が変更された場合はBusiness Logicは変更されますが、それに応じて必ずUIやInfraも変更を迫られることになります。  
このようにサービスとそれ以外の要因で変更される可能性のあるUI/Infraに対して、アプリケーションの機能的中心であるBusiness Logicはサービス仕様によってのみ変更が起きるため相対的に変更されにくい層です。    
#### 3.Business Logicは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  
これはどちらかというと「Business Logicが円の中心である理由」というよりも「Business Logicが他の層から切り離される理由」といった方が良いかもしれません。   
ただBusiness Logicが純粋なプログラミング言語による定義によって成り立ち外部技術に依存しないのは、結局それがサービスの核心であるという話につながりますし、 Business Logicのこの特徴は円図を説明する上で重要な要素であるため理由の一つに加えています。         


### クリーンアーキテクチャは現実の開発状況をより反映させている
こうしたDomainとApplicationを中心に据えたクリーンアーキテクチャはレイヤードアーキテクチャと比べてより現実の開発を反映させた設計であると言えます。  

レイヤードアーキテクチャでは技術的な側面から依存関係を決定したため、技術的な基盤となるInfraをアプリケーションの支えとして捉え「UI->Application->Domain->Infra」という関係で成り立っていました。    
それに対してクリーンアーキテクチャはアプリケーションの機能的中心であるBusiness Logicがアプリケーションを支えていると捉え、他の層がBusiness Logicに依存しています。(上との対比だと「UI->(Application->Domain)<-Infra」と表現できます。)  
クリーンアーキテクチャのこの構造は現実のアプリケーション開発の実態をより正確に捉えています。  
アプリケーションは技術的にはインフラに依存していますが、サービス的に依存しているのはビジネスロジックであり開発はビジネスロジックを起点に動きます。  
そのためビジネスロジックを中心として他の層と切り離すことで、実務で発生する要件に柔軟かつ迅速に対応することが可能になるのです。  
私たちの日々の業務でも技術的にはインフラであるインターネットに依存しつつもその活動はビジネス的な事柄に依存していますが、それと同じです。  

このようにクリーンアーキテクチャは開発の実情を踏まえ、技術的には(レイヤードアーキテクチャでは)4層の中間に位置するBusiness Logicをアプリケーションの基盤に据えて再構築した設計であり、それを視覚的に示した結果円の形となっています。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/クリーンアーキテクチャはレイヤードアーキテクチャを現実の開発状況を考慮して再構築したもの.png" alt="クリーンアーキテクチャはレイヤードアーキテクチャを現実の開発状況を考慮して再構築したもの" width=80%　>


## Frameworks & Drivers層とInterface Adapter層
クリーンアーキテクチャがなぜ円なのか理解できたところで、まだ触れていないFrameworks & Drivers層とInterface Adapter層について説明していきます。  
### Frameworks & Drivers層
Frameworks&Driversの意味はFrameworksはフレームワーク、つまりiOSのUIKit等パッケージ化された外部技術、DriversはIT用語でシステムに装着する外部装置を意味しており、この層はビジネスロジックをアプリケーションプロダクトとして完成させるために必要な外部技術群を指していると言えます。  
円を見てみるとこの層にはUI/Web/DataBase/Devices/External Interfacesとさまざまなものが表記されており、レイヤードアーキテクチャのUI、Infraそしてフレームワーク等がここに含まれています。  
ここではレイヤードアーキテクチャで異なる層であったUIとInfraが一つの層とされているわけですが、私たちは既に同様のケースを前回の記事で見ています。  
PDS(以下)のPresentationです。  
PDSのPresentationにはUIのみならずInfraも含まれることを前回の記事で説明しましたが、クリーンアーキテクチャでも同様に同じ層として扱っているのはこの2つが以下の共通点を持っているためです。  
- 仕様の変更によってプログラムが変化しやすい
- 外部技術に依存している<sup>[*2](#footnote2)</sup>

こうした特徴を持った層に他の層が依存していると、変更による影響が依存している他の層にも広がってしまうため開発の柔軟性が落ちてしまいます。    
そのためクリーンアーキテクチャではこれらの特徴を持ったUI/Infra層が他の層から依存されないように同じ最外層に置いているのです。  
ただ留意点としてプロジェクトでクリーンアーキテクチャを採用した場合にも、ディレクトリ構造上はUIとInfraは区別されることが多いです。  
クリーンアーキテクチャのディレクトリ構造については[補論](#補論1クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない)にてもう少し詳しく説明しています。  
### Interface&nbsp;Adapters層

さて、次はInterface Adaptersです。  
Interface Adapterという言葉だけ聞くとなにやら難しく感じてしまうのですが、簡単にいえばこの層は内側のBusiness Logicと外側のFramework&Drivers層を繋ぐための仲介役を担う層です。  

円図ではこの層に該当するコンポーネントとしてController/Presenter/Gateway等が書かれていますが、基本的にこれらのうちControllerとPresenterがUIとBusiness Logicの、GatewayがInfraとBusiness Logicの仲介役を担っています。  
iOSMVCのControllerに当たるViewControllerもここに属し、円図でいうController/Presenterを担っています。  

#### MVCのControllerと円図にあるControllerは異なる
ややこしいのですが、MVCアーキテクチャの文脈でいうControllerと円図に書いてあるControllerは意味が異なります。  
私たちにとってはControllerというと画面の入出力処理を担うMVCアーキテクチャのControllerが馴染み深いと思いますが、ITにおける一般的なControllerは入力処理のみを責務としており出力処理の意味合いは含んでいません。     
これはMVPのPresenterにも同じことが言えて、Presenterは一般的には出力のみに関する処理装置を指しておりMVPのPresenterは円図でいうControllerとPresenterの両方の責務を担っていることになります。
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/2つのController(MVCとCA).png" alt="MVCとクリーンアーキテクチャのController" width=55%>

#### Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる
このInterface Adapters層が担う層の仲介という責務はレイヤードアーキテクチャでは存在していませんでしたが、実際に開発で実践してみるとこの層の重要性に気づきます。  
層同士が連携して責務が混ざり合ってしまう箇所を一つの独立した層として捉えることで各層の責務の純度が格段に上がるのです。  
  
レイヤードアーキテクチャの層はアプリケーションを機能によってわかりやすく分割していますが、それはあくまで理論上の話であって実際のアプリケーションでは各層が連携して一つのアプリケーションとして動作するため層の責務が交わり境界が曖昧な処理が発生します。  
例えばDomain層ではビジネス的な事柄が関心の対象なので、永続化機構でデータを更新するためのURLやそのためのデータ形式の変換に関心を向けるべきではありません。  
ただ一方でInfra層ではデータを永続化するという汎用的な責務を担ってはいるものの、特定のURLやそれに関する処理はそのアプリケーション(ドメイン)固有なものでありInfra層がその責務を負うのもおかしいです。  
このようにレイヤードアーキテクチャによる層の分割を実践しようとするとその層の境界でどっちつかずな責務が発生してしまい、このような責務は妥協の末に基本的に利用する側(上の例ではDomainがInfraを利用するのでDomain層)に実装されるようになります。  

この問題を解決するためにクリーンアーキテクチャではレイヤードアーキテクチャの層が連携する責務も一つの独立した層として捉えました。  
こうすることで円の内側のBusiness Logicと外側のFramework & Drivers層に強引な形で不純な責務を含める必要がなくなり、各層の責務の純度を高く保つことができます。   


<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/InterfaceAdapters層の役割.png" alt="Interface Adapters層は各層の純度を高くしてくれる" width=55%>  

> 補足:  
>「Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる」と言いながら、Domain機能であるプログラムがInterface Adapters層に置かれているのはおかしいと思う人もいるかと思います。  
>これに関しては簡潔な言葉で表現しようとするとどうしても矛盾しているように思える箇所が出てきてしまうのですが、ここで私が責務の純度があがると言ってるのはあくまでコード上の話です。  
>確かに概念上Domain機能のものであればDomain層に置いた方が純度が高いと言えるかもしれません。  
>ただ実際のプログラムでは機能上はDomainでもInfraのコードが多く混ざっている等のケースが多く、そうした雑多なコードをInterfaceAdapters層に置くことで各層の責務の純度が上がります。  
>また後ほど触れますが上の図に関しては他にも「Infraを利用したDomain層」はインターフェース上はDomain層である等、図では示せていないこともあるのであくまでイメージとして捉えてください。  
>とりあえずここで述べたいことはクリーンアーキテクチャでは「層の連携」というそれまで責務の境界の曖昧であった処理をInteraface Adapters層として扱うことで、各層のコードが区別されより明白になったということです。  

#### RepositoryもInterface Adapters層
円図では表記されていませんが、開発でよく耳にするRepositoryもこのInterface Adapters層に入ります。  
[Marin Flower氏の定義](https://martinfowler.com/eaaCatalog/repository.html)を引用するとRepositoryはDomain層とData層の仲介役です。(引用文のdata mapping layersはData層を指しています。)  
>A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection  
>
>意訳  
>RepositoryはDomainとData層の中立ちをし、インメモリなドメインオブジェクトコレクションのように振る舞います  

円図でいうとGatewaysの中に含まれていると考えればよいと思います。   

#### Gatewayとは異なる層の中継役という意味
ちなみにGatewayという名前はクラス名としてはあまり聞き慣れないと思いますが、クリーンアーキテクチャにおいてはBusiness Logicと最外層(主にInfra)の仲介に入りデータ変換を行うコンポーネントを指しています。  
私はInterfaceAdapter層のコンポーネントに命名するとき、できる限り「~Repository」等より具体的な名前を使うようにしていますが適切な名前が見つからない時は「~Gateway」と命名します。      
Gatewayは広範囲を示す名前ではありますが、プロジェクト内で乱用されるようなものではなくそれだけでInterface Adapter層のコンポーネントだと伝わると思うので「~Managerクラス」や「~Serviceクラス」等より責務が明確で便利な言葉だと思います。  

## クリーンアーキテクチャの依存ルール
クリーンアーキテクチャの依存は外側の層から内側の層へという方向であること、また外側の層の仕様は変わりやすく内側の層の仕様は変わりづらいことを説明しました。  
それはつまりクリーンアーキテクチャにおいて依存の方向は変更されやすい外側の層から変更されにくい内側の層へ向いているということであり、クリーンアーキテクチャではこの依存関係によって外側の層の変更のされやすさがアプリケーション全体へ影響することを最小限に抑えています。  
ただ技術的に依存しているのはInfra層であるはずなのに、Infra層がビジネスロジックに依存するということはどういうことなのでしょうか？  
これについてはこの後[クリーンアーキテクチャのルールを守るためのテクニック](#ルールを守るためのテクニック)という章で説明します。  

## クリーンアーキテクチャの概要を一度整理する 
ここまででクリーンアーキテクチャの特徴に一通り触れました。  
しかしレイヤードアーキテクチャの理解を前提として話を進めたため、クリーンアーキテクチャの基本的な説明をあまりしていません。        
なのでこれまでの内容と重複する部分もありますが、ここで一度[クリーンアーキテクチャの原文](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)に沿った形でその概要を整理したいと思います。  

## クリーンアーキテクチャの特徴   
クリーンアーキテクチャ原文の冒頭では、ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等のシステムアーキテクチャを紹介しています。  
システムアーキテクチャの意味は私も正確に把握しているわけではないのですが、恐らくアプリケーションの特定の領域にこだわらずシステム全体を関心の対象としているアーキテクチャという理解で大丈夫だと思います。     
原文ではそれらシステムアーキテクチャの特徴として以下の共通点があると述べています。    

1. 関心の分離  
どのシステムアーキテクチャも関心の分離を基本として、少なくともBusiness Logicとその他の2層に分けようしている  
2. UI/WebAPI/データベース/フレームワークといった外部技術が独立している  
アプリケーションのうち変更されやすいUI/Web API/データベース/フレームワーク等のコードにどこからも依存しない  
このような外部技術は便利なものの、同時に開発時の制約も発生するためこれらに依存しないようにすることで柔軟な開発が可能になる  
3. テストしやすい  
Business Logicは特定の外部技術に依存していないためテストが容易になる  
またのちに見るように層の依存関係をclassなどの実体型で実現するのではなく、プロトコルを利用した抽象型によって実現することでビジネスロジック以外の層でもテストがしやすくなる

### クリーンアーキテクチャの層は4つである必要はない
クリーンアーキテクチャはDomain/Applicatoin/Interface Adapters/Framework&Driversという4つの層からなっていると説明しましたが、原文には必要であればもっと層を増やしても構わないと書かれています。  
ただ該当箇所の見出しには「Only Four Circles?(4つの層だけ?)」と書かれており、基本的に4つの層より多くなることはあっても4つの層より少なくなるようなことはないという考えのようです。   
私も責務の分離を目的とするなら少なくともBusiness Logic/Interface Adapters/Framework&Driversの3層は必要だと考えていますし、Business Logicも設計者が層の分割を意識してるかどうかは別としてその中で責務をしっかり分けていくと実質的にDomain/Applicationの分離が生まれてくると思うのでこの4層を基本として、必要であればそれ以上に層を分けるというスタンスで良いと思っています。    

## クリーンアーキテクチャで守るべきルール  
クリーンアーキテクチャの以上の特徴を保つためには開発者が守らなければいけないルールがあります。  
それは大きく言って以下3点です。  

### ルール1:円の内側の層は外側の層については知らない何も知らないし、影響も受けない
Business Logicは外側の層について何も知らなくても独立して動作できるようになっている必要があります。  
それはBusiness Logic内のDomain層とApplication層に関しても同様で、内側の層であるDomainは外側のApplicationについて知っているべきではありません。  
クリーンアーキテクチャではアプリケーションとして動作するために各層は連携しつつも可能な限り関心を分離することを目的としているため、依存して良いのは外側の層から内側の層へのみとなっています。  

#### しかしInterface&nbsp;Adapters層は例外
ただこのうちInterface Adapters層は少し例外といえます。   
既に説明した通りInterface Adapters層は内側と外側の層の中継役となる層なので直接的ではなくても外側の層の事情を知ることになるからです。  
例えばUI側のInterface Adapters層はUIの仕様変更によって自身の入力・出力の処理も変更することになるので直接UIを知らなくても間接的にその仕様について知っている必要がありますし、またInfra側のInterface Adapters層も実体型としてデータベースやWebAPIを参照していなくともメソッド名やその引数から参照先がデータベースかWebAPIか等外側の層の事情はある程度把握できます。  
 
原文の記事でも冒頭で  
>Nothing in an inner circle can know anything at all about something in an outer circle.  
>
>意訳  
>内側の層は外側の層について全く知らないこと。  

と強調しながらも、Interface Adapter層の説明でSQLデータベースを例に出しながらInterface Adapter層が外側の層について知っていることは致し方ないことだと書かれています。(ただ同時に外側の層がInterface Adapter層に与える影響は必要最低限に留めることも強調しています。)  
>If the database is a SQL database, then all the SQL should be restricted to this layer, and in particular to the parts of this layer that have to do with the database.
>
>意訳  
>もしデータベースがSQLならば、SQLに関するコードはInterface Adapter層の内データベースと関与する箇所のみにとどめるべきである。  

### ルール2&#58;層をまたぐオブジェクトはシンプルなデータ構造であること
層同士でオブジェクトの受け渡しを行う際には層の責務が漏出してしまう危険性があります。  
アプリケーションとして動くためには層間の連携は避けられませんが、ある層のオブジェクトが他の層に渡されることで本来属する層以外で利用されることになるからです。  
クリーンアーキテクチャではこうした状況でも関心の分離を保つために、層をまたぐオブジェクトはシンプルなデータ構造であるべきだとしています。    
#### 層を跨ぐデータにより責務が他の層に漏出する場合
もし層をまたぐオブジェクトが複雑な処理のメソッドを持っていた場合、跨いだ先の層でもそのメソッドの呼び出しが可能であるためそのメソッドを通して責務が他の層へ漏出していってしまう恐れがあります。  
こうした場合受け渡されたオブジェクトが受け渡し先でどのように利用されるのか想定しきれないため、開発における不確実性が高まりバグの温床となってしまいます。    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/層を跨ぐデータにより責務が漏出してしまう場合.png" alt="層を跨ぐデータにより責務が漏出してしまう場合" width=50%> 

#### データが層を跨いでも責務が他の層に漏出しない場合
それに対して層を跨ぐオブジェクトがメソッドを持たないデータ構造である場合は、受け渡し先の層でそのオブジェクトに対して可能な処理はデータ操作のみであるため層を跨いでも責務が漏出する恐れはありません。<sup>[*3](#footnote3)</sup>  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/層を跨ぐデータで責務が漏出しない場合.png" alt="層を跨ぐデータで責務が漏出しない場合" width=50%>  

ちなみにここでいうメソッドを持ったオブジェクトとは層の責務の漏出につながるようなメソッドを持っているものを指しています。  
例えばSwiftのArrayはメソッドを持っていますが、それらのメソッドは自身に関するデータの取得、またデータ操作を行う処理であり、そこから層の責務が漏出してしまう恐れはないので層の受け渡しで利用しても問題ありません。  

層を跨ぐデータについてはもう少し掘り下げたい点があるため、[補論](#補論1&#58;クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない)で取り上げました。  

### ルール3:データフローは一方向
これはクリーンアーキテクチャの原文には明言されていません。    
ただ一方向のデータフローはクリーンアーキテクチャに限らず設計において重要であるためルールに加えました。  

アプリケーションのデータフローをクリーンアーキテクチャの円図に沿ってたどっていくと、まず入力が円の外側のUIで起こり、それを処理するため内側のBusiness Logicに入って、そしてその結果は再び出力先であるUIに向かっていきます。  
そのためデータは円の外->内->外と流れていて一見すると一方向になっていないように思えますが、それはあの円がデータフローではなく依存関係に着目して作られているからであって実際のところデータフローも一方向となっています。  
それを示すのがクリーンアーキテクチャの右下の図です。<sup>[*4](#footnote4)</sup>  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/クリーンアーキテクチャの右下の図.png" alt="クリーンアーキテクチャの右下の図" width=30%>  

図が表しているようにデータフローはContrller->UseCase(Applciation)->Presenterとなっており、これらは円図で見ると外->内->外ではありますが実際には最初に外から内へ入る時と、そのあと内から外へ出ていく時の経路が異なるため実質的にデータのフローは一方向となっています。    

これはMVCのControllerやMVPのPresenter等、一つのコンポーネントが画面の入出力を担当している場合も同じです。  
これらのコンポーネントでは一つの中に入出力の責務がありながらも、実際のコード上では入力と出力の責務が交わらないような設計が前提となっています。 

以下イメージ図(あくまで一例でありデータフローが一方向である設計が必ずこのような構造になっているわけではありません。)  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/データフローは一方向な例.png" alt="データフローは一方向な例" width=50%>  



## ルールを守るためのテクニック
クリーンアーキテクチャに関していろいろと見てきましたが、最重要ルールと言える「円の内側が外側についてなにも知らない」を守りながらアプリケーションをどう実現するのかについてはまだ触れていません。      
アプリケーションは技術的にInfraに依存しているにも関わらず円の内から外への依存がないというのは不可解なことのように思えます。  
ここではこの問題をどう解決すればよいか説明していきます。  

### 依存関係逆転の原則(Dependency&nbsp;Inversion&nbsp;Principle)
これには依存関係逆転の原則(Dependency Inversion Principle)を利用します。    
「依存関係逆転」と聞くと難しそうに聞こえるのですが、要はあるコンポーネントに依存するとき実体型ではなく抽象型(Swiftでいうプロトコル)を利用するというテクニックです。      
なぜプロトコルに依存することで層の外側から内側の依存のみになるのかというと、通常実体型による依存関係では上位(利用する側)の層から下位(利用される側)の層への依存となりますが、プロトコルを利用した依存関係の場合そのプロトコルは下位の層ではなく上位の層に属していると考えられているからです。  
そうすると上位コンポーネントも下位コンポーネントも上位の層にあるプロトコル依存していることになるため依存方向が逆転しています。    

もう少しわかりやすく説明するために以下で簡単な例を示します。  
### 依存関係逆転の例
クラスAがクラスBを利用しているとします。  
その場合それらの依存関係はA->Bとなり上位のAが下位のBに依存しています。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/プロトコルを利用しない依存関係.png" alt="プロトコルを利用しない依存関係" width=50%>  
ここでこれらに依存関係逆転の原則を適用するためクラスBの要件を満たした「BType」というプロトコルを定義し、クラスAはBクラスを直接利用するのではなくBTypeプロトコルを利用するようにします。  
この時BTypeプロトコルはBクラスの要件を全て満たしているのでAクラスはBクラスを利用していた時と同じようにBTypeプロトコルを利用できます。  
またクラスBはBTypeプロトコルに準拠するようにします。(堅苦しいですが、Swiftではある実体型にプロトコルを適用する場合「プロトコルに準拠する」とよく表現します。)  
```
// class Aはclass Bに依存せず、同じ要件を満たしたBTypeプロトコルに依存する
class A {
   let b: BType
   
   func hogeA() {
      b.hogeB()
   }
}

//　BTypeプロトコルはclass Bの要件を全て満たしている
protocol BType {
   func hogeB()
}

// class BはBTypeプロトコルに準拠している
class B: BType {
   ...
   func hogeB() {
      ...
   }
}

```
そうなるとクラスAはBTypeプロトコルを利用しBクラスもBTypeプロトコルに準拠するため、先程のA->Bで表していた依存関係はA->BType<-Bに変化します。(ここではプロトコルに準拠することも一種の依存としています)    
そしてBTypeプロトコルは利用する側であるクラスAの層に属していると捉えられているため、先ほど上位から下位へ(A->B)の依存であった関係が下位から上位への依存に逆転したことになります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/プロトコルを利用した場合の依存関係.png" alt="プロトコルを利用した場合の依存関係" width=50%>  
これがプロトコルを利用した依存関係の構築が「依存関係逆転」と言われている理由であり、クリーンアーキテクチャではこの原則を用いて層の内から外への依存を行わないようにします。  

### プロトコルを利用することでプログラムの変更を行いやすくなる
プロトコルを利用した依存が「依存関係の逆転」と言われているから内から外の依存はないというのはただの概念的な操作であって、レトリックにしかすぎないと思う人もいるかもしれません。  
ただここでもう一度思い返して欲しいのですが、クリーンアーキテクチャで外から内への依存のみ許している理由は以下の二つです。  
- Business Logicを外側の層から切り離す
- テストを容易にする

実体型を利用した依存関係では満たせていなかった上記の要件をプロトコルを利用することによってしっかりと満たせるようになっています。     
Infra側ではInterface Adapters層のコンポーネントが利用するのは実体型としてのInfraクラスではなくInfraの要件を満たしたプロトコルであるため、プロトコルに準拠したコンポーネントがあればInterface Adapter層側のコードを書き換えることなく実体型を差し替えることができますし、仮コンポーネントを使ったテストも容易に行えます。    
UIでも同様にデザインやUIプログラムが完成していなくともコンソールなどに出力して値が正しいか確認できるようになります。    

### 依存の方向関係なくプロトコルは積極的に利用する
内から外への依存を行いたいときのテクニックとして依存関係逆転の原則を紹介しましたが、実際にはテストの観点から外から内への依存でも積極的にプロトコルを利用することをオススメします。  
例えばUIテストを行う時、出力値が正しいかどうかではなく出力値を表示するレイアウトが正しいかどうか確認したい場合がありますが、UIからInterface Adaptes層への依存においてプロトコルを利用することで仮コンポーネントを利用してテストが可能になります。  

他にも依存とプロトコルについてはいくつか書きたいことがあったので[Swiftのプロトコル](#補論3:Swiftのプロトコル)という補論で取り上げています。    


## クリーンアーキテクチャにある誤解
ネット上でiOSにおけるクリーンアーキテクチャを調べると大きく2点ほど誤解されている箇所があるように思います。  
クリーンアーキテクチャの説明の最後にそれらについて説明します。    

### 1. Entityに関する誤解
  
### EntityはDomain層
ネットで調べているとEntityがData層であるというような内容の記事がありますが、クリーンアーキテクチャにおけるEntityはData層ではなくDomain層です。  
EntityをData層としてしまうと円図の中心にはData層があることになりビジネスロジックを他から切り離すというクリーンアーキテクチャの本来の目的を読み取れず、図が何を意味しているのかわからなくなってしまいます。    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/EntitiesがData層だった場合.png" alt="EntitiesがData層だった場合" width=80%>  
<sup>*図ではEntityの解釈に焦点が当たっているため、DomainではなくEntitiesと表記しています。</sup>  


恐らくEntityをData層とする主張はデータベースの文脈におけるEntityと混同しているのだと思います。  
データベースの文脈でEntityはデータベース上で操作するデータのまとまりを指し、プログラム開発で一般的にEntityというとこの意味で使われます。    
しかし先ほどもいった通りクリーンアーキテクチャにおけるEntityをData層と解釈してしまうと、その主張と根本的に矛盾してしまうため注意が必要です。  

### Entityはビジネスルール
Entityに関してもう一つ誤解があります。  
Entityは単純なデータ型として紹介されていることがありますが、そうではなくビジネスルールを指しておりロジックを含んでいます。  
これはクリーンアーキテクチャのEntityの定義を見ればわかります。  
>Entities encapsulate Enterprise wide business rules.   
>An entity can be an object with methods, or it can be a set of data structures and functions.  
>  
>意訳  
>エンティティは事業のビジネスルールである。  
>エンティティはメソッドをもったオブジェクト、もしくはデータ構造と関数の集まりである。  

クリーンアーキテクチャにおけるEntityはロジックを含んだビジネスルールをカプセル化したものです。  
そのためビジネスロジックを持っていない単純なデータオブジェクトは、Entityを構成する一要素ではありますがEntityそれ自体ではありません。  

この誤解がアーキテクチャに与える影響はあまり大きくないと思いますが、その原因は少し複雑です。         
既にクリーンアーキテクチャのEntityがなんであるかは説明できたので詳細は省きますが、クリーンアーキテクチャにおけるEntityは先程のデータベースの文脈におけるEntityに加え、ドメイン駆動開発におけるEntityともVIPERアーキテクチャのEntityとも異なります。    
特にクリーンアーキテクチャをiOSの開発環境で実践しやすいように最適化したVIPERアーキテクチャのEntityとクリーンアーキテクチャのEntityで意味が異なるのは誤解しやすいと思います。(ちなみにVIPERの
エンティティもData層ではないことは強調されており、その点はクリーンアーキテクチャのEntityと同じです。)  

### 2. Interface Adapter層の誤解
次にInterface Adapter層に関する誤解を説明します。  
### Business Logic層のデータをUI層のデータ形式へ変換するのはInterface Adapters層の責務
クリーンアーキテクチャにおいてApplication層であるUseCase内でTranslatorというデータ変換用のコンポーネントを利用してUI用のデータ形式に変換するという内容の記事がいくつかありますが、これは誤りだと思います。      
既に[記事内](#Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる)でも説明しましたが、Application層のデータをUI層の形式に変換するのはApplication層ではなくInterface Adapters層の責務だからです。    

Interface Adapter層の役割を原文に沿いながら再度説明します。  
原文のInterface Adapter層の説明では
>The software in this layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency  
>  
>意訳  
>この層(Interface Adapter)はApplication層もしくはDomain層のデータを最外層に最適な形式に変換することである。
  
とBusiness Logicのデータを最外層に適した形式に変換するのが役割だと述べたあとに、
>Also in this layer is any other adapter necessary to convert data from some external form to the internal form used by the use cases and entities  
>
>意訳  
>またこの層(Interface Adapter)では最外層のデータを内側のApplication層やDomain層に最適な形式に変換する。　　

最外層のデータをBusiness Logicに最適な形式に変換するとも述べており、ここからInterface Adapters層はその方向にかかわらず内層と外層間のデータ形式の変換を役割としているのがわかります。      

そしてクリーンアーキテクチャでは関心の分離を保つためにこうした異なる層へのデータ変換はInterface Adapter層に閉じ込められているべきです。(見方によればApplication層内でDomain層のデータをApplication層データに変換しているといえますが、Application層でDomainデータを直接扱うことは許容されておりここでいう「異なる層へのデータ変換」には含まれません。)     

もしUI層へのデータ変換の責務をApplication層であるUseCaseに置いたならば、UseCaseはUIの仕様なしでは定義・実装できないためクリーンアーキテクチャの[円の内側の層は外側の層について何も知らない](#ルール1\:円の内側の層は外側の層については知らない何も知らないし、影響も受けない)というルールを破ってしまうことになります。    

### Data層のデータをBusiness Logic層のデータ形式に変換するのはInterface Adapters層の責務
Interface Adapters層ではData側でもよく見かける誤解があります。
#### Data層でDomainオブジェクト型のデータを返すのは誤り
クリーンアーキテクチャの記事でDomainオブジェクトをData層で操作する際Data層が直接Domain層の型でオブジェクトを出力しているのを時々見かけますが、これも先ほど同じく最外層とBusiness Logic層のデータ変換をInterface Adapters層で行なっておらず誤りです。  
クリーンアーキテクチャでは外側の層が内側の層について知っていることは問題ありません。  
ただこの設計では[Infra(Data)層はApplication/Domain層から独立している](#クリーンアーキテクチャの特徴)という特徴を満たせておらず、コードが冗長化して変更に弱くなってしまいます。    

ここではData層とBusinness Logic層が分離できていないことでどういう問題が起きてしまうのか具体例を用いて説明します。 
#### Data層でBusiness Logic層のオブジェクトを出力する誤った例 
前置きとして[依存関係逆転](#依存関係逆転の原則(Dependency&nbsp;Inversion&nbsp;Principle))ではプロトコルはそれを上位の層に属すると説明しましたが、論旨とは関係ないためここではプロトコルも下位の層に属するものとして話をします。  
またData層でデータ操作を行うコンポーネントをData Clientと表現します。

それでは例を見ていきましょう。  
まず状況としてObjectAというDomain層のオブジェクトをData層を通して操作するObjectARepositoryが定義されているとします。    
今回指摘しているのはこのObjectARepository内で利用するData ClientがObjectAを返すインターフェースを持っている設計です。  
コードでいうと以下のようになります。(ここで同期・非同期は論旨とは関係ないので、Infraが出力するデータはシンプルに返り値で返されるようにしています。)  

Data層側のコード
```
protocol ObjectADataClientType: class {
   func fetch() -> ObjectA
}

class ObjectADataClient: ObjectADataClientType {

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```

Repository(Interface Adapters)層側のコード
```
protocol ObjectARepositoryType: class {
   func fetch() -> ObjectA
}

class ObjectADataRepository: ObjectARepositoryType {

   private let dataClient: ObjectADataClientType
   
   init(dataClient: ObjectADataClientType) {
      self.dataClient = dataClient
   }
   // Repositoryはデータクライアントクラスのメソッドを呼び出しているだけで、自身で独自の処理は何もしていない
   func fetch() -> ObjectA {
      return self.dataClient.fetch()
   }
}

```

上のコードをみてみるとInterface Adapters層のObjectARepositoryだけなく、Data層であるObjectADataClientもDomain層のObjectAを返しているのがわかります。  
このようにData層がDomain層のオブジェクトを返す設計だとData層はDomain層について知らなければ定義・実装できないため、クリーンアーキテクチャの[Infra(Data)層はApplication/Domain層から独立している](#クリーンアーキテクチャの特徴)という特徴を満たせていません。  

またObjectADataClientTypeとObjectARepositoryTypeの定義を比較すると両者ともにObjectAを取得していて機能が重複しており、RepositoryはData Clientのメソッドを呼び出しているだけで自身では独自の処理を全く行なっていないことがわかります。  

#### Data層にDomain層の事情を持ち込むことでData層が肥大化する
そして上記ような設計がアプリケーション全体に及んだ場合、Data層が肥大化します。(そもそもDomainオブジェクトと切り離されていないデータアクセス処理の集まりをData層と言って良いのかわかりませんが、ここではそういうことで話を進めます。)  
仮にあるアプリケーションでObjectA〜Zまでの26のオブジェクトをRepositoryで操作するとしましょう。  
その場合に先ほどの設計に沿って開発すると、ObjectA〜Zの一つ一つのオブジェクトに対してRepositoryとData Clientのプロトコル・実体型を定義、実装しなければならず、またこれらのDomainオブジェクトに仕様変更が起こった場合にも両方に対して変更を適用する必要があります。  

先程述べたようにRepositoryが実質的に何の独自処理も行なっていないことを考えると、この設計はあまりにも冗長なように感じます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/Data層とBusinessLogicが切り離されていない設計.png" alt="Data層とBusiness Logicが切り離されていない設計" width=65%>  

もちろん対応するRepositoryとData Clientの出力する値が必ずしも同じとは限らないため、実際のアプリケーションが必ず上の図のような構成になるとは限りません。  
ただどちらにしてもData層がBusiness Logic層から独立できていないため多くのData Clientコンポーネント(もしくはメソッド)が必要になり、冗長な設計となってしまうことは変わりません。                
こうした冗長さを回避するためにはData層をBusiness Logic層から切り離す必要があります。  

#### Infra層とBusiness Logic層を切り離した設計
Infra(Data)層をBusiness Logic層から切り離すために以下2点の変更を行います。  

1. Data Clientの出力をData型(もしくはIntやString等Swiftのプリミティブ型)にする
2. Data Clientコンポーネントを集約する  

それぞれの変更に関して説明すると、  
1ではInfra層が出力するデータ形式をData型を代表とするSwiftのプリミティブ型とすることでInfra層からBusiness Logic層へのデータ変換をInterface Adapters層であるRepositoryが担うようにしています。  
これによってRepositoryはただData Clientの出力を垂れ流すコンポーネントではなくなります。  

そして2はData Clientコンポーネントを操作対象であるオブジェクト毎ではなくWebAPIやデータベース等データアクセス機構毎に定義・実装することを意味しています。    
この集約によってData Clientを再利用することができ、プログラムの冗長さがなくなります。  

以下にコード例、また設計図を示しています。(このコード例でも論旨とは関係ないため出力するデータは返り値で返されるものとし、またメソッドのパラメーターも正確ではありません。)

Data層側のコード
```
protocol WebAPIClientType {
   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data
}

class WebAPIClient: ObjectADataClientType {

   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data {
         // 引数で指定されたURLと通信を行いデータを取得する処理
         ...
         return 通信で取得したData
    }
}



```

Repository(Interface Adapters)層側のコード
```
protocol ObjectARepositoryType: class {
   func fetch() -> ObjectA
}

class ObjectADataRepository: ObjectARepositoryType {

   private let dataClient: WebAPIClientType 
   
   init(dataClient: WebAPIClientType) {
      self.dataClient = dataClient
   }
   // RepositoryではObjectAのデータを取得するためのパラメーターをデータクライアントクラスのメソッドに渡し、またData型からObjectA型への変換を行なっている
   func fetch() -> ObjectA {
      // ObjectAのデータを取得するためにData Clientメソッドのパラメータを指定する
      let data: Data = self.dataClient
                           .request(url: ...,
                                    headers: ...,
                                    parameters: ...,
                                    method: ...,
                                    body: ...)
      // 取得したData型をObjectA型に変換(*ObjectAはDecodableに準拠してるものとします)                      
      return JSONDecoder().decode(ObjectA.self, from: data)

   }
}

```  

変更後の設計図  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/Data層とBusinessLogicが切り離されている設計.png" alt="Data層とBusiness Logicが切り離されている設計" width=65%>  

上記のコードと図をみると、**Data層の出力をData型にする**と**Data Clientコンポーネントの集約化する**という2点の変更を行なったことで、Data層がBusiness Logicから独立して、コンポーネントの数が大きく減ったのがわかると思います。  
もちろんWebAPIやデータベース等データアクセス機構毎にData Clientを定義・実装する必要はありますが、それはそれぞれの機構のインターフェースが異なることを考えれば致し方ありません。    

Data層はそのBusiness Logicから独立するように設計しましょう。  
そうすることで関心の分離が保たれて、Data層の肥大化が避けられます。  

```
補足:
データクライアントでの出力は基本Data型と述べましたが、設計次第ではDomainやApplicationオブジェクトを出力することも可能です。  
例えば以下のようにジェネリクスを利用して指定した型をデータクライアントが出力できる設計です。  
この場合、型変換の責務はあくまで呼び出す側であるリポジトリにあり、データクライアントはDomain/Applicationから独立しているため問題ありません。    


//パラメーターは本来のURLリクエストよりも簡略化させています。
protocol WebAPIClientType {
   func request<Object: Decodable>(url: URL,
                                   headers: [String: String],
                                   parameters: [String: String],
                                   method: HTTPMethod,
                                   body: Data?) -> Object
}

class WebAPIClient: ObjectADataClientType {

   func request<Object: Decodable>(url: URL,
                                   headers: [String: String],
                                   parameters: [String: String],
                                   method: HTTPMethod,
                                   body: Data?) -> Object {
      ...
   }
}



```

## レイヤードアーキテクチャ+クリーンアーキテクチャ+@で設計についてまとめる
前回の記事からレイヤードアーキテクチャとクリーンアーキテクチャを通して設計というものをみてきました。  
ここではそれらと+@を踏まえて設計についての考えをまとめたいと思います。  

### 1.設計とは関係を構築することである
これは前回の記事で説明しました。  
アプリケーション設計とはアプリケーション内の関係を構築することであり、良い設計を考えるとはこの関係を開発者にとって作業しやすい形に構築することになります。  

### 2.責務によって分割し、それらを単純な依存関係により組み合わせる
関係の構築のためにレイヤードアーキテクチャではアプリケーションを責務によって層に分割し、それらが単一方向の依存関係になるように定義しました。  
このようにプログラムを責務によって分割しそれらが単純な関係で連携するようにすることで、開発者はアプリケーションを特定の目的を持ったプログラムの集合体として捉えることができるため、コードを読み(書き)やすくなります。  
また責務の分割は関連性の高いコードをまとめて(高凝集)、関連性の低い(ない)コードを分離する(疎結合)ので、プログラマは自身が現在担当している責務に関連したコードのみに集中して開発を行うことができます。(関心の分離)
### 3.データフローは一方向
データフローも開発の重要な要素です。    
データフローが一方向になっていることでプログラムの流れを追いやすくなり、コードの可読性が上がります。  
### 4.開発事情を考慮する
本記事ではクリーンアーキテクチャについて説明してきましたが、その内容を一言でまとめると**クリーンアーキテクチャは実際の開発事情を考慮してレイヤードアーキテクチャを再構築したもの**であると言えます。  
[記事内](#クリーンアーキテクチャは現実の開発状況をより反映させている)で既に述べた通り、クリーンアーキテクチャはサービス仕様に該当するビジネスロジックを中心に置くことで、サービスの変化にプログラム側が柔軟に対応できるようになっています。  

改めて言葉にすると当たり前すぎる感じはありますが、設計の際には実際の開発事情を考慮しながらアプリケーションの関係を構築することが重要です。  


### 5.データフローの蓄積による状態変化に考慮する
ここが+@の内容です。  
設計についてまとめるに当たり、1~4の内容に加えてあと一つ考慮しなければいけない点があると思います。  
それは**データフローの蓄積**です。  
ここまでの設計に関する話ではデータフローについては深く取り上げず、入力から出力までのデータの流れに着目して設計の話をしていました。  
しかし実際のアプリケーションはいくつものデータフローの積み重ねによって成り立っており、設計の際にもそうしたデータフローの蓄積の視点を取り入れることは重要になります。        

私たちの身近なところでこれを実践しているのはFlux、Reduxでしょう。    
FluxやReduxといったアーキテクチャではActionとStore(State)コンポーネントを利用することで、データフローの蓄積によって生成される状態の管理を可能にしています。    

設計において**データフロー**と**その蓄積**という二つの時間の視点を踏まえるというのは決して私の恣意ではありません。  
例えば経済学では経済的事象を一定期間の経済活動の成果を指すフローと過去からのフローの蓄積をストックという二つの視点から説明していますし、他にも同様なアプローチはあらゆる分野の研究で取られています。<sup>[*5](#footnote5)</sup>    
一般的に言っても何かを考察する際にはある一点の時間と経過を含めた時間の2つの視点から行うことはよくあることではないでしょうか。  

それにも関わらずクリーンアーキテクチャにおいてこのデータフローの蓄積の視点が取り入れられていない原因は恐らく当時の開発環境にあると思います。  
クリーンアーキテクチャ登場時にはWeb・モバイルアプリケーションの規模やハードウェアのメモリの容量も今ほど大きくなかったため状態の管理はアプリケーションレベルで考えるものではなく画面単位もしくは局所的に行うのが基本だったのではないかと推測しています。  
  
しかし現代的なアプリケーションは規模が当時と比べて非常に大きく多くのデータフローが行き交っており、そうした個々のデータフロー俯瞰して捉える視点はプログラムの品質を大きく向上させます。    
そのため本記事ではデータフローの蓄積も踏まえてアプリケーション設計を考えていきます。  

### アプリケーション設計とは
設計に関する要点を5点述べました。  
アプリケーション設計を簡単に言ってしまうと、上記の(3)**一方向のデータフロー**、(4)**開発事情**、(5)**データフローの蓄積**を考慮しながら、(2)**責務による分割とそれらの関係の構築**をアプリケーションのマクロからミクロに至るまで繰り返すことであると思います。  
この作業を繰り返すことで、アプリケーションは層(レイヤー)->モジュール->コンポーネントと粒度を細かくしていき、細部にまで配慮が行き届いた開発しやすいプログラムへとなっていきます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/アプリケーション設計.png" alt="アプリケーション設計" width=85%>  

## スケールしやすいアーキテクチャとは
最後に本記事の目的であるスケールしやすいアーキテクチャについても簡単にまとめます。    
先程の「[アプリケーション設計とは](#アプリケーション設計とは)」を踏まえると、本記事が目指すスケールしやすいアーキテクチャとは層・モジュールといったアプリケーションの骨格と呼べる部分において破壊的な変更を起こすことなく開発を続けられるような設計と言えるでしょう。  
長期的なプロジェクトであればなにから何まで当初の設計通り開発が進むことはまずありえませんが、継続的に開発を続ける中アプリケーションの枠組みから設計し直すのは膨大なコストがかかり作業に大きな支障をきたします。  
そのため効率的な開発を目指す上でアプリケーションの枠組みにあたるレイヤー・モジュールにおいて破壊的な変更が起こらないような設計を考えていくことはとても重要になってきます。    

その意味で前記事のレイヤードアーキテクチャ・本記事のクリーンアーキテクチャは設計の概要と同時にアプリケーションの層に関する設計について考察していた記事だと言えます。  
次回以降はここで得られた層の設計を基盤としながら、一般的にアプリケーションに求められるであろう機能に関するモジュール・コンポーネントについて考察していきます。 

## 本記事のまとめ
- クリーンアーキテクチャとは技術的な依存によって成り立っていたレイヤードアーキテクチャの構造を、開発の実情を考慮して再構築した設計
- アプリケーション設計とは、一方向のデータフロー・開発事情・データフローの蓄積を考慮しながら、プログラムを責務によって分割しそれらの関係を構築していく作業。  

## 補論1&#58;クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない
クリーンアーキテクチャの層がそのままアプリケーションのディレクトリ構造になることは滅多にありません。    
Framework&Drivers層のUIとInfra、またInterface Adapters層のPresenter等UI側とRepository等Infra側は実際のアプリケーション開発では区別されます。      
その理由はクリーンアーキテクチャの層の構成がディレクトリ構造の目的と合致していないからです。  
ディレクトリ構造ではそのディレクトリにどのような責務のプログラムが置かれているかを具体的に示す必要がありますが、クリーンアーキテクチャではよりメタ視点から層を捉えています。  
例えばFramework&Drivers層はBusinessLogicに対する外部プログラムであることを意味しているだけであり、UIやInfra等のように具体的にどのような責務を担っているのか示しているわけではありません。     
そのためアーキテクチャとしてクリーンアーキテクチャを採用していても、アプリケーションのディレクトリ構造はレイヤードアーキテクチャの責務分割に沿ってなされていることがほとんどだと思います。      
こうした点からみるとクリーンアーキテクチャとレイヤードアーキテクチャではただ層の分け方だけでなく、層を捉える視点の次元も異なっているのがわかります。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/クリーンアーキテクチャのディレクトリ構造.png" alt="MVCとクリーンアーキテクチャのディレクトリ構造" width=80%　>

## 補論2:クリーンアーキテクチャにおける層を跨ぐデータ構造がシンプルであるとは
本記事内で[層を跨ぐデータ構造はシンプルでなければならない](#ルール2層をまたぐオブジェクトはシンプルなデータ構造であること)、と説明しました。  
しかしそもそも何をもってシンプルであると言えるのか、ここではそれについて補足します。  
### シンプルなデータ構造とは責務が漏出しないデータ構造
結論から言うと一般的に「シンプル」であるということは余計なものがないという意味で使われますが、ここでいう"シンプル"は**層の責務が漏出する恐れがない状態**を指しています。  

なぜ"シンプル"がそのような状態を指すのか、具体例を見ながら説明していきます。  
ある写真アプリのプログラムにはユーザーを示すUser型と写真を示すPhoto型が定義され、ユーザーの持つ写真のタイトルをリストで表示する機能があるとします。            
User型とPhoto型はそれぞれ以下の通りです。(必要な箇所以外省略しています)  

```
struct User {
   struct ID { ... }
   let id: ID
   ...
}

struct Photo {
   let title: String
   ...
}
```

この機能をクリーンアーキテクチャに沿って開発しようとするとControllerからユーザーの写真を取得するUseCaseを呼び出しその結果をPresenterに渡すという処理の流れになり、この場合、層を跨ぐデータはContrller->UseCaseとUseCase->Presenterの2箇所で発生します。  
このうちContrller->UseCaseで層を跨ぐのはUseCaseにパラメーターとして渡すデータです。  
一般的にこのパラメーターのデータ型はUserのID型となるでしょう。  
このパラメーターはどのUserの写真を取得するか識別するためだけに利用されるため、User型をそのまま渡す必要はなくUser.ID型で十分です。        
それに対してUseCase->Presenterで渡されるデータは恐らくPhotoの配列になると思います。    
こちらは先程と異なりPresenterで必要なのは写真のタイトル(Photo.title)だけであるのに拘らず、Photoごと配列で渡されます。  
そのためPresenterではUseCaseから渡されたPhotoの配列をPhoto.titleの配列へと変換します。          
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/層を跨ぐ2つのデータの非対称性.png" alt="層を跨ぐ2つのデータの非対称性" width=55%>  

こうして層を跨ぐこれら2つのデータを比較するとUseCase->Presenterのデータだけが余計な情報を持っていることがわかりますが、なぜUserCase->Presenterに渡すデータはUI側の要求に沿ってPhoto.titleではないのでしょうか。

その理由は先程のUseCaseのコードを見てみるとわかります。(論旨とは関係ないため、コード例では非同期は考慮されていません。)          
```
class FetchUsersPhotosUseCase {
   func execute(userID: User.ID) -> [Photo] {
      ...
   }
}
```
先程の層を跨ぐ2つのデータはUseCaseメソッドのパラメータとその出力であり両方ともUseCase(Application層)の設計の一部です。
この内パラメーターに関してはUseCase自身の処理内容に応じてそのデータ型を設計できるのに対して、自身の出力がPresenterからどういう目的で利用されるのかについてはUseCaseの設計の対象外であるため関知できません。  
そのためPresenterがUseCaseから受け取るデータは自身の要求に合致しているとは限らないわけです。(ただ合致していなくとも要求は満たしている必要があります)  

これは設計上致し方ないことです。  
もしUseCaseからPresenterに渡される全てのデータの無駄をなくそうとするならばUseCaseはUI側の仕様を把握する必要があり、クリーンアーキテクチャの外側の層の影響を受けないというルールを破ってしまうことになります。  
またそのように全てのUIの要求に合致するUseCaseメソッドを一つ一つ定義・実装しようとするならば、数が膨大になり層を跨ぐデータは無駄なくあらゆる面でシンプルになるかもしれませんがApplication層全体のプログラムは複雑化、肥大化していくでしょう。  

層を跨ぐデータをシンプルにする目的は層同士の関心の分離です。  
そうした本来の目的や上で示した事例を踏まえて考えると、層を跨ぐデータに求められるシンプルさとは要求に対して一才無駄がないことではなく、責務が他の層に漏れてしまわないような構造を意味しているのがわかるのではないでしょうか。  


### 層を跨ぐデータ構造をどう設計するかはケースバイケース
先程はUseCase->PresenterでPhoto型の配列で渡しましたが、場合によっては以下のようにPhotoは各Userのプロパティとして生えており単体では利用しないということもあり得ると思います。    
その場合UseCase->Presenterの出力はPhotoの配列ではなくUser型になります。(その場合User.IDを引数にUserを取得するのはおかしいので全体の設計も変わるでしょう)  
このように他の層への出力データ形式はあらかじめ決まっているわけではなく、個々のプロダクトや設計者の判断によって変わります。    
```
struct User {
   struct ID { ... }
   let id: ID
   let photos: [Photo]
   ...
}
```


## 補論3:Swiftのプロトコル
本文内でテストしやすくなるという理由で[依存方向関係なくプロトコルを使った依存を利用した方が良い](#依存の方向関係なくプロトコルは積極的に利用する)と述べました。   
ここではプロトコルを利用した依存についてもう少し説明します。    
### Protocol Oriented Programming(POP)
最初にProtocol Oriented Programming(以下POPと省略)の話から始めます。    
POPとは所謂プロトコル指向プログラミングを意味しています。  
Swiftを特徴づける概念でありiOS等Swiftを使っているプログラマーであればよく耳にする言葉なのではないでしょうか。        
しかしよく聞く言葉あるにもかかわらず、それが具体的に何を意味しているのかについてはあまり理解されていないように思います。    
POPはただ積極的にプロトコルを利用することを推奨している概念ではありません。  
Swiftで提唱されたPOPですが、Swiftのプロトコルに当たる言語機能は他の多くのプログラミング言語も既に持っています。  
そのためただ積極的にプロトコルを利用するという意味だけならば、なぜ他言語でも既にあった機能をわざわざPOPという大きな概念を用いて推奨しているのか十分に説明できていません。<sup>[*6](#footnote6)</sup>  

### POPとはSwiftにおけるポリモーフィズム実現の手段
ではPOPとはどういう意味なのかというと、私は[このオンライン書籍](https://heart-of-swift.github.io/protocol-oriented-programming/)の説明がすごいわかりやすいと思います。(余談ですがこの書籍ではプロトコル以外にもSwiftに関して面白い考察がなされているのでSwiftの基礎を一通り学んだ人にオススメです。また書籍と表現していますが無料です。)  
簡単に説明するとPOPはOOP(Object Oriented Programming)と対置関係にある概念です。  
複数の型を同様に扱いたい等、型を抽象化したい(ポリモーフィズム)場合、OOPではクラスの継承によって実現していました。  
しかしSwiftはクラスではなく値型と言われる構造体や列挙型を積極的な利用を推奨しており、この値型には継承機能はありません。  
そのためSwiftではポリモーフィズムを実現する方法としてクラスの継承の代わりにプロトコルを提案しています。    
POPとはこのようにクラスではなく値型を主軸に考えるSwiftにおいて、プロトコルを利用してポリモーフィズムを実現するプログラミングスタイルを指しています。<sup>[*7](#footnote7)</sup><sup>[*8](#footnote8)</sup>    

### 依存関係でプロトコルを利用する目的
そして依存関係におけるプロトコルの利用もPOPの一部であり、その目的は同様に型の抽象化です。    

具体的に示すと以下3点になると思います。  
1. 開発時、実体型を差し替えて実装を変更したい
2. テストを行いたい
3. プログラム実行中、多義的な役割を担わせたい

このうち1と2は技術的には同義です。  
差し替えるコンポーネントが本番用なら1でテスト用なら2になるわけですが、これらは技術的には同義でも開発的には役割が異なるので分けて表記しています。    
本記事で紹介したプロトコルの利用方法もこの1と2です。  
                       
3に関しては本記事では触れらていません。
しかし一般的に私たちがプロトコルを使う理由で一番多いのはこの3ではないでしょうか。  
このケースに当てはまる例としては例えば犬、猫、鳥、等複数の異なる実体型を動物型のように一つの型として利用したい場合です。  
このように複数の型に共通の性質・振る舞いを持たせたい場合にはプロトコルを適用することで実現できます。  
```
// 犬も猫も鳥も同じ動物としてプログラミングで扱いたい

protocol Animal {}

struct Dog: Animal {}

struct Cat: Animal {}

struct Bird: Animal {}

struct Person {
   // Animal型であるpetにはDog,Cat,Bird型のどのデータも代入できる
   let pet: Animal 
}
```

### 依存関係でプロトコルを利用しない場合
プロトコルを利用する目的を説明しましたが、逆にいうと上記に該当しない場合の依存関係ではプロトコルを利用しても意味がありません。  
むしろ必要のないプロトコルを定義、利用することでプログラムの意図が曖昧になって可読性が落ちてしまいますし、パフォーマンスにも悪影響なので利用しない方が良いでしょう。  
具体的にプロトコルを利用する必要のないケースとして以下2点が挙げられると思います。    
- 各層のデータオブジェクト
- Domain層のオブジェクト  

しかし先ほど挙げた[依存関係でプロトコルを利用する目的](#依存関係でプロトコルを利用する目的)の
>3. プログラム実行中、多義的な役割を担わせたい  

に該当する場合は上記のケースでもプロトコルは必要です。  

以下それぞれの詳細を説明します。  
#### 各層のデータオブジェクト
依存関係においてプロトコルを利用する主な目的は**層の関心分離**と**コンポーネントの差し替えを容易にする**ことです。  
しかしデータオブジェクトは基本的に層内部のコンポーネントから依存され,層の外側にあるコンポーネントからは依存されません。(クリーンアーキテクチャの思想に沿って設計すればローカルで利用されることはあっても直接されることはない)         
そのため実体型のデータオブジェクトに依存したとしても層の関心の分離が破られる恐れはないと考えられます。               
またほとんどのデータオブジェクトは複雑なロジックを抱えていないため、実装の変更やテストのためにコンポーネントを差し替える必要性も低い(もしくはない)です。    
実装を変更したい時には実体型のコードをそのまま書き換えて問題ないでしょう。      
  
例えば以下のようなPhoto型を利用してテストを行いたい場合は値にテスト用のものを代入すれば十分であり、わざわざプロトコルを利用して実体型を差し替える必要はありません。  

```
struct Photo {
    
    let id: String
    let createdAt: Date
    let width: Int
    let height: Int
    let description: String?
    let urls: PhotoImageUrls
    let altDescription: String?
    let likes: Int
    let likedByUser: Bool
    let user: User
    
}
```

```
補足:  
もちろん本記事でも触れたように層を跨ぐデータオブジェクトであれば層の関心を破る原因にはなりえます。  
しかしそれはオブジェクト構造の問題であり、依存関係でプロトコルを利用するか実体型を利用するかという問題とは話が異なります。        
```

#### Domain層オブジェクト
一般的にDomain層では全てのオブジェクトでプロトコルを利用する必要はありません。  
その理由を端的に表現するのは少し難しいのですが、以下3つを要点として挙げました。  
- Domainは円の中心にあり外側の層から依存されない
- Domainは他の本番用コンポーネントと差し替える必要はない
- Domainをテストコンポーネントとして利用しない

##### Domainは円の中心にあり外側の層から依存されない
Domainは円の中心にあるため外層からしか依存されず、プロトコルを利用しなくともクリーンアーキテクチャの依存ルールを破る恐れはありません。  

##### Domainは他の本番用コンポーネントと差し替える必要はない
一般的に本番用で実体型を差し替える必要があるコンポーネントは外部技術を利用しています。  
「機能は変更しないけど、他の外部技術を利用して実現したい」といった場合にプロトコルを使うことで自身に依存しているコンポーネントに影響を与えずにプログラムを変更することができるわけです。      
ただDomainは外部技術には依存せず、純粋なプログラミング言語でのみ実装しているためコンポーネントを差し替えて実装の変更を行う意味が特にありません。  
実装の変更を行いたい場合は実体型をそのまま書き換えれば良いと思います。 

##### Domainをテストコンポーネントとして利用しない
Domainに関連してテストを行うコンポーネントとしてUseCaseとUI(Presenter)が想定されますが、その両者のテストにおいてDomainをテストコンポーネントとして利用する必要はありません。  
###### UseCaseのテスト
UseCaseはその性質から自身のテストを行う必要は基本的にはありません。  
クリーンアーキテクチャのUseCaseの説明を見てみるとそのことがよくわかると思います。  

>These use cases orchestrate the flow of data to and from the entities, and direct those entities to use their enterprise wide business rules to achieve the goals of the use case.
>
>意訳
>UseCaseはEntityを組み合わせて自身の目的を達成する  

上記の説明にある通りUseCaseの役割は他コンポーネントを組み合わせることであり自身は複雑なロジックを抱えていないはずです。    
そのため個々のDomainオブジェクトが正しく動作していれば、UseCaseのテストを行う必要はなくテスト用Domainコンポーネントの出番もありません。    
```
補足:  
UseCaseによっては特有の事情によってテストを行いたいという場合もあるかもしれません。  
ただその場合もDomainコンポーネントをわざわざテスト用に差し替える必要はないでしょう。  
```


###### UI側のテスト
通常UIテストを行いたい場合はPresenterをテストコンポーネントに差し替えれば十分なはずですが、中にはPresenterのテストするためにBusiness Logicのテストコンポーネントが必要だという場合があると思います。  
しかしこの場合も以下のようにUseCaseをテストコンポーネントに差し替えるだけでUI側の要件は達成できるため、Domainまでテストコンポーネントに差し替える必要はありません。  


```
// お会計の表示のレイアウトが期待通りになっているか確認したい

protocol CalculateTheBillUseCaseType {
   func execute(items: [Item]) -> Int
}

// テスト用のUseCaseコンポーネントを作りたい場合、
// テストしたい値をUseCase自身で生成すれば良いのでDomain用のテストコンポーネントまで作成する意味はない
class TestCalculateTheBillUseCase: CalculateTheBillUseCaseType {
   func execute(items: [Item]) -> Int {
      return 15000
   }
}


class BillingPresenter {
   let calculateTheBill: CalculateTheBillUseCaseType
   ...
}

```

```
補足:  
他にも外部技術は利用していないけどDomainが抱えているロジックが複雑、等の理由でプロトコルを利用したいという場合もあるかもしれません。    
ただ私は最初に挙げた「実行時に多義的な役割を担わせたい」という理由を除いてDomainではプロトコルを利用すべきではないと考えています。  
Domainはクリーンアーキテクチャの円の中心であるようにアプリケーションプログラムの核となる部分です。  
そのようなアプリケーションの屋台骨となるロジックやデータを扱うオブジェクトをプロトコル型を使って抽象化するということは  
プログラムの核心部分の設計が定まっていないということであり、プログラムとして不健全だと思います。  
人で例えるなら素晴らしい信念を掲げつつも、その内実は全く定まっておらず時代や状況に応じて都合よくその内容を変えていっているような感じでしょうか。  
私はDomainの実装が定まっていないのならば、プロトコルで抽象化してしまうのではなく自信のあるものできるまで向き合うべきだと考えます。  
```

## 補論4:Repository
ここではRepositoryに関していくつか説明します。  
### Repositoryのプロトコル&#40;インターフェース&#41;はDomain層&#12289;実体型はData層
Repositoryは一般的にWebAPI、データベースを利用しますが、それらは内部実装の話でありインターフェース上では意識されません。  
そのため定義上においてはRepositoryはただDomainオブジェクトを操作するコンポーネントであり、プロトコルはDomain層に属することになります。  
それに対して実体型のRepositoryはその実装でWebAPIやデータベースを利用するのでData層に分類されます。  

### なぜRepositoryとData Clientの出力が異なる場合があるのか
記事内の[Repositoryの設計に関する誤解](#Data層にDomain層の事情を持ち込むことでData層が肥大化する)を説明した箇所で、
>対応するリポジトリとデータクライアントの出力する値は必ずしも同じではない  

と書きましたが、なぜこのようなことが起こるのでしょうか?
  
その理由は詰まるところDomainとデータベースの設計の違いにあります。    
Domain層のオブジェクトを設計する際、私たちは純粋にそのサービスの観点からデータをどのような単位で扱いまたそれらをどのように関連し合うか考えます。    
それに対してデータベースの設計ではサービスに加えてパフォーマンス等データベース特有の事情も考える必要があります。      
そのため実体としては同じデータを扱っているのにDomainとデータベースで扱う単位が異なるということが起こります。  

リポジトリとデータクライアントの出力する値が異なるのも同じ理由です。  
リポジトリとデータクライアントでは設計の視点が異なるため必ずしも出力が一対一で対応していることにはならず、場合によってはRepositoryの出力値を生成するために複数のWebAPIを利用する等の必要があります。  

### RepositoryとDAO 
DAOとはData Access Object略であり、技術的な詳細を内部実装として隠蔽しながらデータを操作を行うコンポーネントを指します。  
Repositoryも同様に詳細を隠蔽しながらデータを操作するコンポーネントであり、この意味でDAOとRepositoryは同じ役割を担っています。      
しかし設計の観点から考えるとこの2つは大きく異なります。  
その違いは大きく以下2点です。    
- RepositoryはDomainオブジェクトを操作対象としているのに対して、DAOはデータ全般を操作対象としている
- RepositoryはDomain層とData層を切り離すことを目的としていてアプリケーションの層を意識したコンポーネントであるのに対して、DAOはデータ操作とそのメカニズムを切り離すことを目的としておりアプリケーションの層は意識されていない  

もちろん実際の開発ではDAOを利用することによって「データ操作とそのメカニズムを切り離す」と同時に「層も切り離される」場合もあります。  
ただ少なくとも概念上はDAOが関心があるのは「データ操作の技術」であり「アプリケーションの層分離」ではありません。  

もともとRepositoryはアーキテクチャ設計、DAOはデザインパターンとそれぞれが登場する文脈が違います。  
そのため両者は機能的に似ていますが(もしく同じ)、その目的が異なります。  

そしてこれはRepositoryとDAOが共存できることを意味しています。  
例えば先ほどの[Repositoryとデータクライアントの出力で異なる場合があるのか](#Repositoryとデータクライアントの出力で異なる場合があるのか)ではRepositoryの出力値を生成するために複数のWebAPIを利用する場合があると述べましたが、この時にRepository内でDAOを利用して複数のデータ操作し、最終的に一つのDomainオブジェクトを操作するということがありえます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/RepositoryとDAOの共存.png" alt="RepositoryとDAOの共存" width=65%>  
実際に[Androidの公式ドキュメント](https://developer.android.com/jetpack/guide?hl=ja#addendum)ではRepository内でDAOを使っています。  

### DAOはInterface Adapters層 
ちなみにDAOをクリーンアーキテクチャで利用した場合、DAOはData層ではなくInterface Adapters層となると思います。(Domainオブジェクトの操作はRepositoryで行っているものと仮定します)  
その理由は[本記事内Repositoryに関する誤解](#Data層でDomainオブジェクト型のデータを返すのは誤り)で述べた通りData層はアプリケーション特有の事情からは独立しているべきだからです。  
RepositoryでDomainオブジェクトの操作を行なっているならばDAOで操作するデータオブジェクトはDomain層とは異なりますが、それでもそのオブジェクトは間接的にせよアプリケーションサービスと何かしら
関係しているはずです。  
そのためDAOはData層ではなくInterfaceAdapters層の扱いになるべきだと思います。  
ただ[補論冒頭](#RepositoryのプロトコルインターフェースはDomain層実体型はData層)で述べたRepositoryと同様、概念上はData層に当たらなくとも実体型ではWebAPIやデータベースを利用するためData層に含まれます。    


## 補論5: データフローの蓄積の視点をアプリケーションレベルで設計に取り入れる
ここでは[本記事](#データフローの蓄積による状態変化に考慮する)内で触れたデータフローの蓄積の視点を設計に取り入れることでアプリケーションへ与える影響をもう少し詳しく説明します。    

私はデータフローの蓄積の視点をアプリケーションレベルで設計に取り入れることによるメリットは具体的に以下2点だと思います。        
1. 複数画面での状態の共有が容易になる
2. アプリケーション全体のデータフローがシンプルになる
  
### 複数画面での状態の共有が容易になる
これはFluxやReduxを知っている人ならすぐにイメージできるのでないでしょうか。  
状態を画面毎に管理するような設計では複数画面で状態を共有するために画面間でデータの受け渡しを行う必要がありますが、アプリケーションレベルで状態管理を行なっている場合にはデータの受け渡しを行わずとも各画面からApplication層で管理している状態にアクセスすれば良いため状態の共有が容易になります。      
このように複数画面で状態共有が容易になることでアプリケーションのローカル上で最新の状態を保ちやすくなりUXが向上しますし、またこのあと触れるようにデータフローの集約化にもつながります。<sup>[*9](#footnote9)</sup>    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/複数の画面で状態を共有する.png" alt="複数の画面で状態を共有する" width=55%>  
<sup>[*10](#footnote10)</sup>  
もちろんこのようなApplication層を利用した状態管理は特定データに対してのみ局所的に行うことも可能です。  
しかしアプリケーションレベルで行うことで全体のデータフローの整合性は高くなりますし、既存のデータを複数画面で共有する等の仕様の変更にも対応しやすくなります。  

### アプリケーション全体のデータフローがシンプルになる
データフローの蓄積を考慮して設計することで、煩雑なデータフローを回避できるケースが出てきます。  
例えばあるデータの取得にはページネーション機能がついているとします。  

もし画面毎に状態を管理する設計であった場合、そのデータ取得に関するページネーションと累積データの管理はUI側であるPresenterの責務になります。      

それによって発生するPresenter単体の処理は命令的プログラミングで実装すればそこまで複雑にはならないと思います。    
ただ先の例で見たように複数画面で共有しようとすれば画面間でページ情報とデータの受け渡しを行う必要がありますし、またそもそも概念的にはページネーションとデータの累積の管理はApplication層、もしくはBusiness Logicの責務であり、それをPresenter側で処理することで通常よりもデータフローが複雑になってしまっていることは間違いありません。   
またRxSwift等、個々のデータフローが明確に区別されているリアクティブプログラミングで実装しようとする場合にはさらに煩雑なデータフローとなってしまいます。    

もしこの機能をデータフローの蓄積も考慮して設計したならば、上記で述べた通りページングと累積データの管理はApplication層側で行うことになるでしょう。<sup>[*7](#footnote7)</sup>   
そうするとPresenter内とPresenter-Application層間のデータフローはシンプルになり、Presenterは取得したデータをUI用に変換するのみとなるため責務がより明確化されます。  

当たり前ですが、データフローの蓄積も考慮するということはより俯瞰的に視点からデータフローの設計を行うということです。  
そのため上の例のようにそれまで別個に扱っていたデータフローが集約される箇所が少なからず出てきます。　　  

上で紹介した例はサンプルプロジェクトで遭遇したケースを簡略化したもので、実際にはPresenter(サンプルプロジェクトではViewModel)は複数の経路からデータを取得してさらにプルリフレッシュ、追加取得を行うなどより複雑なロジックを抱えていました。  
しかしその後ページネーションとデータ累積のデータ操作ロジックをApplication層側に委譲することで、Presenterから複雑なロジックをなくすことができました。    

他にもReduxのようにStoreにデータフローを集約させ、複数の画面がStateによって状態を共有するとい機構も、データフローの蓄積の視点をより発展させたモノだと考えることができます。    


### 設計・開発のコストが高くなる
最後に設計にデータフローの蓄積の視点を取り入れる際のデメリットについて簡単に書きます。        
これはデメリットという表現が正しいかは微妙ですが、やはり設計のコストが高くなってしまうことでしょう。    
恐らくデータフローの蓄積の視点を設計に取り入れる一番身近な方法はFlux・Reduxといった既存のアーキテクチャの採用だと思いますが、その場合でさえほとんどのアプリケーションではその要件に合わせて独自に考えなければいけない設計箇所が出てくるはずです。(さらにアーキテクチャに対する理解をチームで共有する必要もあります。)  

またFlux・Reduxに頼らず取り入れようとした場合にも、汎用性のある形式でデータフローの蓄積を設計に組み込むためにはさまざまな検討が必要になります。      

設計にデータフローの蓄積の視点を取り入れようとすると全体の整合性を保つのはより難しくなります。    
そのため設計にコストがより高くなってしまうのはある程度致し方ないことです。    

しかしその反面一度汎用性のある設計が出来上がると、長期のプロジェクトにおいても一貫性を持ちながら開発を続けることができるため開発効率は大きく上がります。  
そのためスケールしやすいアーキテクチャを考える本記事ではこの視点を踏まえて設計を考えていきます。  

  
## 参考文献：  
  
### 書籍  
- [ドメイン駆動設計](https://www.amazon.co.jp/エリック・エヴァンスのドメイン駆動設計-Architects’Archive-ソフトウェア開発の実践-エリック・エヴァンス/dp/4798121967/ref=asc_df_4798121967/?tag=jpgo-22&linkCode=df0&hvadid=295719984664&hvpos=&hvnetw=g&hvrand=3926308388276309968&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=1009283&hvtargid=pla-525481409888&psc=1&th=1&psc=1)  

### Web
- [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)([日本語訳](https://blog.tai2.net/the_clean_architecture.html))
- [Repositoryの定義](https://martinfowler.com/eaaCatalog/repository.html)
- [VIPER](https://cheesecakelabs.com/blog/ios-project-architecture-using-viper/)
- [リポジトリとDAOの棲み分け方](https://blog.fukuchiharuki.me/entry/use-repository-and-dao-according-to-the-purpose)
- [Android公式アーキテクチャガイド](https://developer.android.com/jetpack/guide?hl=ja#addendum)
- [まだMVC,MVP,MVVMで消耗してるの？ iOS Clean Architectureについて](https://qiita.com/koutalou/items/07a4f9cf51a2d13e4cdc)
- [Heart of Swift](https://heart-of-swift.github.io/protocol-oriented-programming/)


## 注釈

<a name="footnote1">*1</a>:ここでいう「変更」はアプリケーションの仕様変更や機能的に要求によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。  
<a name="footnote2">*2</a>: この項の始めにあるFramework&Driversが外部技術であるという箇所と外部技術に依存しているという表現は矛盾しているような表現ですが、視点が異なっているだけです。  UIKitを例に出すとUIKitは内部でApple独自のレンダリング技術を使っているため外部技術に依存しているわけですが、他の層から見るとまさにそのUIKit自身が外部技術なわけです。

<a name="footnote3">*3</a>: 層の責務とはその層がするべき仕事(Do)と定義しています。そのためある層のオブジェクトが他の層に渡されることは層の知識(What)が漏出してるとは言えますが、層の責務(Do)が漏出したとはしません   
<a name="footnote4">*4</a>: 実際には依存関係も示した図なのですがここではデータフローについてのみ触れています    
<a name="footnote5">*5</a>: 他にも言語学の用語である共時性・通時性という概念は人文系全般でよく利用されています。  
<a name="footnote6">*6</a>:  個人や小さな組織が提唱しているのであれば、ただ流行らしたい(バズる！！！)等の理由で概念化している可能性もあると思います。しかしAppleのようなパブリックに影響力のある企業がそのような単純な理由で新しい技術的概念を提唱することは考えづらいと思います。 

<a name="footnote7">*7</a>: Swiftは構造体で積極的に定義していくプログラミング言語ではありますが、結果的にクラスで定義するコンポーネントの方が数が多くなることはあり得ます。     
<a name="footnote8">*8</a>: 参考元ではSwiftの公式ドキュメントには何がProtocol-oriented Programming なのか明確には述べられていないと書かれており解釈の一つとして紹介されていますが、POPがOOPを意識して生まれた概念であることはその名前からも明らかでありPOPの概要がここで記した意味であることは間違いないと思います。  
<a name="footnote9">*9</a>: 厳密に言えばFluxやReduxのように最新状態を即時共有するためにはObserverパターンが必要ですが、それにしてもその基盤に**データフローの蓄積を考慮する視点**があることには変わりません。  
<a name="footnote10">*10</a>: 仕様によってはアプリケーションレベルで状態管理を行なっても、状態を共有するために識別子となるIDに当たるデータを画面間で受け渡す必要があります。しかしその場合も共有したい情報を直接受け渡すよりは容易なはずです。    
<a name="footnote7">*7</a>: ここではモバイルアプリの一般的な仕様を前提としています。モバイルアプリの場合ページネーションはスクロールと連携して実装されることが多いためページは1ページ目から2ページ目、2ページ目から3ページ目と連続して変化していくため(プルリフレッシュを除く)、Presenter側でページを管理する必要はありません。しかしWebアプリの場合はページの変化は非連続的で1ページ目から5ページ目に飛ぶといった操作は一般的であるためPresenter側で現在のページ情報は保持する必要がある場合が多いと思います。  


