
# iOSアプリでスケールしやすいアーキテクチャを考えてみた②-設計を理解するためのクリーンアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)**設計を理解するためのクリーンアーキテクチャ編←本記事**  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への準備編として設計の概観を理解するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  
また本記事はレイヤードアーキテクチャの知識を前提としていますので、レイヤードアーキテクチャがわからない方は前の記事から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

### 記事内の用語の表記ルール 
記事内でアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。    
しかしどちらの意味でも文として成り立つ場合の表記については一貫性がないように感じる箇所があるかもしれません。    
例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logic(層)と表記します。  
InfrastructureはInfraと省略して表記し、 Infra層のうちデータ操作に関するものをData(層)、端末機能に関するものをDevice(層)と表現する場合があります。  



## 前回までの内容と本記事の内容
初回である前回の記事ではスケールしやすいアーキテクチャを考えるためにクリーンアーキテクチャを通して設計概要を理解することを最初の目的としました。  
そしてクリーンアーキテクチャの前提知識としてその原型とも言えるレイヤードアーキテクチャの理解を深めたのが前回までの内容です。

この記事ではいよいよクリーンアーキテクチャを学び、設計についてまとめたいと思います。

## クリーンアーキテクチャとレイヤードアーキテクチャの共通点/相違点
まず前回学んだレイヤードアーキテクチャと今回学ぶクリーンアーキテクチャの共通点、そして相違点について整理することでクリーンアーキテクチャを理解するために必要なポイントをまとめます。   
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>


前回の記事でレイヤードアーキテクチャの特徴が**責務による層の分割と単一方向の依存関係による関心の分離**であることを述べました。  
クリーンアーキテクチャでもそれは変わりません。    
円の中の一つ一つの色が層を示していて、また円内側の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格はつかめているといえます。  
ただクリーンアーキテクチャではその詳細が異なります。  
そのためクリーンアーキテクチャを理解するためにまずその層の分割と依存関係の詳細について見ていきたいと思うのですが、これらを理解することはクリーンアーキテクチャが円である理由を理解することと同じです。  
なので最初にクリーンアーキテクチャが円である理由を踏まえながら円の各層・依存関係について理解していきたいと思います。  

## Entities == Domain層 && Use Cases == Application層
クリーンアーキテクチャが円である理由を見ていきますが、その前に前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所があるのでそこから始めます。  
結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層であり、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層です。   
円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」です。  
前回の記事でDomainとは「事業の知識・ルール」を意味していることを書きましたが、ここからEntitiesがDomainと同じであることがわかると思います。    
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesの方に書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要でしょう。

以後EntitiesはDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため

クリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか？  
実はその理由はレイヤードアーキテクチャの記事ですでに書いています。  
レイヤードアーキテクチャの記事のPresentation Domain Separation(以下PDSと表記)の説明でビジネスロジックを「アプリケーションプログラムの機能的中心」と表現しましたが、まさにこれがBusiness LogicであるDomainとApplicationが円の中心にある理由です。  

### ビジネスロジックを円の中心に置く3つの理由
Business Logicをアプリケーションの中心とする理由をもう少し具体的に示すと以下のようになります。  

1. サービスのアイディアを具体化したものがビジネスロジックのデータやロジックであり、ビジネスロジックなしではアプリケーションは成立しない   
2. Business LogicはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. Business Logicは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

以下でそれぞれの詳細について説明します。  
#### 1.ビジネスはアイディアから
「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、プログラム化したものがDomain層であり、それをさらにアプリケーションとして提供するために書かれたコードがApplication層です。  
UI層はそのサービスをユーザーへ提供する窓口として存在しInfra層はそのサービスの実現のための手段として必要であって、Business Logic層なしにアプリケーションが生まれることはありません。    

#### 2.Business Logicは相対的に変更されづらい層
またそれはBusiness Logicがアプリケーションの中で相対的に変わりづらい箇所であることも意味しています。(ここでいう「変更」はアプリケーションの仕様変更や機能的に要求によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。)  
UIやInfraはBusiness Logicが変わることがなくてもUXや技術的なパフォーマンスの観点から変更することがあります。  
それに対してサービスの仕様が変更された場合はBusiness Logicも変更されますが、それに応じて必ずUIやInfraも変更を迫られることになります。  
このようにBusiness Logicはアプリケーションの機能的中心でサービスそのものであるため、Business Logicの定義が変わる場合はそれに応じて他の層も変更する必要があります。  

#### 3.外部技術に依存していない
これはどちらかというと「Business Logicが円の中心である理由」というよりも「Business Logicが他の層から切り離される理由」といった方が良いかもしれません。   
ただ純粋なプログラミング言語の定義によってのみ成立し外部技術に依存しない理由は、結局そのサービスの核心にあるため外部に依存していないという話につながりるため理由の一つとして加えました。   


### クリーンアーキテクチャは現実の開発状況をより反映させている
そしてこうしたDomainとApplicationを中心に据えたクリーンアーキテクチャはレイヤードアーキテクチャと比べてより現実を反映させた設計であると言えます。  

レイヤードアーキテクチャは技術的な側面から依存関係を決定したため、技術的な基盤となるInfraがアプリケーションを支えていると捉え「UI->Application->Domain->Infra」という依存関係でした。  
それに対してクリーンアーキテクチャではアプリケーションの機能的中心であるBusiness Logicがアプリケーションを支えていると捉え、他の層がBusiness Logicに依存しています。  
クリーンアーキテクチャのこの構造はアプリケーション開発の実態をより正確に捉えています。  
アプリケーションは技術的にはインフラに依存していますが、サービス的に依存しているのはビジネスロジックであり開発はビジネスロジックを起点に動きます。  
そのためビジネスロジックを中心として他の層と切り離すことで、実務で発生する要件に柔軟かつ迅速に対応することが可能になるのです。  
私たちの日々の業務でも技術的にはインフラであるインターネットに依存しつつもその活動はビジネス的な事柄に依存していますが、それと同じです。  


このようにクリーンアーキテクチャは技術的(レイヤードアーキテクチャ)には4層の中間に位置するBusiness Logicをアプリケーションの基盤と捉えたアプリケーション設計であり、それを
図で示すために円の形となっています。  

## Framework & Drivers層とInterface Adapter層
クリーンアーキテクチャがなぜ円なのかについて理解したところで、クリーンアーキテクチャの層でまだ説明されていないFrame & Drivers層とInterface Adapter層を説明していきます。  
### Framework & Drivers層
まず一番外にあるFrame & Drivers層から見ていきます。  

Framework&Driversの意味はFrameworksはフレームワーク、つまりiOSのUIKit等パッケージ化された外部技術を指しており、DriversはIT用語でシステムに装着する外部装置を意味するのでこの層はビジネスロジックをアプリケーションプロダクトとして完成させるために必要な外部技術群と言えると思います。  
円を見てみるとこの層にはUI/Web/DataBase/Devices/External Interfacesとさまざまなものが表記されており、レイヤードアーキテクチャでいうUI、Infraそしてフレームワーク等が含まれていることになります。  
この層ではレイヤードアーキテクチャで異なる層であったUIとInfraが一つの層とされているわけですが、私たちは既に同様のケースを前回の記事でも見ています。  
PDS(以下)のPresentationです。  
PDSのPresentationにはUIのみならずInfraも含まれることを前回の記事で説明しましたが、クリーンアーキテクチャでも同様に同じ層として扱っているのはこの2つが以下の共通点を持っているためです。  
- 仕様の変更によってコードが変化しやすい
- 外部技術に依存している<sup>[*1](#footnote1)</sup>

こうした特徴を持った層に他の層が依存しているような設計だと、層の変更による影響が依存している他の層にも広がってしまい柔軟な開発を行うことが難しくなります。  
そのためクリーンアーキテクチャではこれらの特徴を持ったUI/Infra層を他の層から依存されないように同じ最外層に置いているのです。

### クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない
これはこのあとのInterface Adapters層にも言えることですが、クリーンアーキテクチャの層がアプリケーションのディレクトリ構造になるわけではありません。  
具体的にいうとFramework&Drivers層のUIとInfraは実際のアプリケーション開発では区別されることが多いですし、またこのあとのInterface Adapters層でもPresenter等UI側のコンポーネントとRepository等Infra側のコンポーネントは区別されます。  
その理由はクリーンアーキテクチャの層の捉え方がディレクトリ構造にとって最適ではないからです。  
ディレクトリ構造ではそのディレクトリにどんな責務のコードがあるか具体的に示す必要がありますが、クリーンアーキテクチャではもっとメタ視点から層を捉えています。  
クリーンアーキテクチャのFramework&Drivers層とInterface Adapter層はBusiness Logicをアプリケーションの中心としてそこからのどれだけ距離があるかということを示しているだけで、具体的な責務を示していません。  
そのため実際のアプリケーションプロジェクトのディレクトリ構造はレイヤードアーキテクチャの責務分割に沿ってディレクトリを分けることが多いです。  
このようなところからクリーンアーキテクチャとレイヤードアーキテクチャでは層を捉える視点の次元が異なることがわかります。  

### Interface Adapters層

さて、残る一つはInterface Adaptersです。  
Interface Adapterという言葉だけ聞くとなにやら難しく感じてしまうのですが、簡単にいうとこの層は内側のBusiness Logicと外側のFramework&Drivers層を繋ぐための仲介役を担う層です。  

円図ではこの層に該当するコンポーネントとしてController/Presenter/Gateway等が書かれていますが、基本的にこれらのうちControllerとPresenterがUIとビジネスロジックの、GatewayがBusiness LogicとInfraの仲介役を担っています。  
iOSMVCのControllerに当たるViewControllerもここに属し、円図でいうController/Presenterを担っています。

#### MVCのControllerと円図にあるControllerは異なる
ややこしいのですが、MVCアーキテクチャの文脈でいうControllerと円図に書いてあるControllerは意味が異なります。  
私たちにとってはControllerというと画面の入出力処理を担うMVCアーキテクチャのControllerが馴染み深いと思いますが、ITでの一般的なControllerは入力のみに関する処理装置を意味していて出力に関する意味は含まれていません。  
これはMVPのPresenterにも同じことが言えて、Presenterは一般的には出力のみに関する処理装置を指しておりMVPのPresenterは円図でいうControllerとPresenterの両方の責務を担っていることになります。  

#### Interface Adapter層は各層の責務の純度を高くしてくれる
このInterface Adapters層が担う層の仲介という責務はレイヤードアーキテクチャでは存在していなかったのですが、実際に開発で実践してみるとこの層の重要性に気づきます。  
層同士が連携して責務が混ざり合った箇所を一つの独立した層として捉えることで各層責務の純度が格段に上がるのです。  
  
レイヤードアーキテクチャの層はアプリケーションを機能によってわかりやすく分割していますが、それはあくまで理論上の話であって実際のアプリケーションでは各層が連携して一つのアプリケーションとして動作するため複数の層の責務が交わり境界が曖昧な処理が発生します。  
例えばDomain層ではビジネス的な事柄が関心の対象なので、永続化機構でデータを更新するためのURLやそのためのデータ形式の変換に関心を向けるべきではありません。  
ただ一方でInfra層ではデータを永続化するという汎用的な責務を担ってはいるものの、特定のURLやそれに関する処理はそのアプリケーション(ドメイン)固有なものなのでInfra層がその責務を負うのはおかしなことです。  
このようにレイヤードアーキテクチャによる層の分割を実践しようとするとその層の境界でどっちつかずな責務が発生してしまい、このような責務は基本的に妥協の末に利用する側(上の例ではDomainがInfraを利用するのでDomain層)に実装されるようになります。  

この問題を解決するためにクリーンアーキテクチャではレイヤードアーキテクチャの層が連携する責務も一つの独立した層として捉えました。  
こうすることで円の内側のビジネスロジックと外側のFramework & Drivers層に不純な責務を含める必要がなくなり、各層の責務の純度を高く保つことができるようになりました。  

#### RepositoryもInterface Adapters層
ちなみに円図では表記されていませんが、開発でよく耳にするRepositoryもこのInterface Adapters層に入ります。  
Marin Flower氏の定義を引用するとRepositoryはDomain層とData層の仲介役です。(引用文のdata mapping layersはData層を指しています。)  
>A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection  

円図でいうとGatewaysの中に含まれていると考えればよいと思います。   

#### Gatewayとは異なる層の中継役という意味
Gatewayという名前はクラス名としてはあまり聞き慣れないと思いますが、ネットワークの文脈では異なる層の中継役を担う装置を指しており、クリーンアーキテクチャでも同様の意味です。  　　
私はInterfaceAdapter層のクラス名を命名するとき、できる限りRepository等具体的な名前を使うようにしていますが適切な名前が見つからない時はGatewayの名前を使うようにしています。  
Gatewayは広範囲を示す名前ではありますが、プロジェクト内で乱用されるような名前ではなくそれだけでInterface Adapter層のコンポーネントだと伝わると思うので「~Managerクラス」や「~Serviceクラス」等より責務が明確で便利な単語だと思います。  

## クリーンアーキテクチャの依存ルール
クリーンアーキテクチャでの依存は外側の層から内側の層へという方向であること、また外側の層の仕様は変わりやすく内側の層の仕様は変わりづらいことを説明しました。  
つまりクリーンアーキテクチャの依存は変更されやすい外側の層から変更されにくい内側の層へ向いており、こうすることで外側の層の変更のされやすさがアプリケーションへ影響することを最小限に抑えています。  
ただ技術的に依存しているのはInfra層のはずなのに、Infra層がビジネスロジックに依存するということはどういうことなのでしょうか？  
これについてはこの後クリーンアーキテクチャのルールを守るためのテクニックという節で説明します。  

## クリーンアーキテクチャの概要を一度整理する 
ここまででクリーンアーキテクチャの特徴に一通り触れました。  
しかしレイヤードアーキテクチャの理解を前提として話を進めたため、必要な要点のみ説明して基本的な説明をあまりしてきませんでした。      
なのでこれまでの内容と重複する部分もありますが、ここで一度クリーンアーキテクチャの原文に沿った形でその概要を整理したいと思います。  

## クリーンアーキテクチャの特徴   
クリーンアーキテクチャの記事の冒頭では、ヘキサゴナルアーキテクチャ・オニオンアーキテクチャなどのシステムアーキテクチャを紹介しています。  
システムアーキテクチャの厳密な意味は私もはっきり理解しているわけではないですが、恐らくアプリケーションの特定の領域にこだわらずシステム全体を関心の対象としているアーキテクチャという理解で大丈夫だと思います。  
そして記事ではそれらシステムアーキテクチャの特徴として以下の共通点があると述べています。  

1. 関心の分離  
どのシステムアーキテクチャも関心の分離を基本として、少なくともBusiness Logicとその他の2層に分けようしています。
2. UI/WebAPI/データベース/フレームワークといった外部技術が独立している  
アプリケーションのうち変更されやすいUI/Web API/データベース/フレームワーク等のコードにどこからも依存しない。  
このような外部技術は便利なものの、同時に開発時の制約も発生するためこれらに依存しないようにすることで柔軟な開発が可能になります。  
3. テストしやすい  
Business Logicも特定の外部技術に依存していないためテストが容易になります。  
またのちに見るように層の依存関係をclassなどの実体型で実現するのではなく、プロトコルを利用した抽象型によって実現することでビジネスロジック以外の層でもテストがやりやすくなります。 

そしてこうした特徴を図としてまとめたものがクリーンアーキテクチャの円図です。  

### クリーンアーキテクチャの層は4つである必要はない
クリーンアーキテクチャはDomain/Applicatoin/Interface Adapters/Framework&Driversという4つの層からなっていると説明しましたが、原文には必要であればもっと層を増やしても構わないと書かれています。  
ただ該当箇所の小見出しには「Only Four Circles?(4つの層だけ?)」と書かれており、基本的に4つの層より多くなることはあっても4つの層より少なくなるようなことはないという考えのようです。   
私としても責務の分離を目的とするなら少なくともBusiness Logic/Interface Adapters/Framework&Driversの3層は必要だと思いますし、Business Logicも設計者がBusiness Logic内での層の分割を意識してるかどうかは別としてその中で責務をしっかり分けていくと実質的にはDomain/Applicationの分離が生まれてくると思うのでこの4層を基本として、必要であればそれ以上に層を分けるというスタンスで良いのかなと考えています。  

## クリーンアーキテクチャで守るべきルール  
クリーンアーキテクチャの特徴を保つために開発者が守らなければいけないルールが大きくいって3つあります。

### ルール1: 円の内側の層は外側の層については知らない何も知らないし、影響も受けない
  
Business Logicは外側の層について何も知らなくても独立して動作できるようになっている必要があります。  
それはBusiness Logic内のDomain層とApplication層に関しても同様で、内側の層であるDomainは外側のApplicationについて知っているべきではありません。  
クリーンアーキテクチャではこのようにアプリケーションとして動作するため各層は連携しつつも、可能な限り関心を分離することを目的としているので依存して良いのは外側の層から内側の層へのみということになっています。  

#### しかしInterface Adapters層は例外
ただこのうちInterface Adaptersは少し例外といえます。   
既に説明した通りInterface Adaptersは内側と外側の層の中継役となる層なので直接的ではなくても外側の層の事情を知ることになるからです。  
具体的に説明すると、UI側のInterface Adapters層はUIの仕様によって自身の入力・出力の処理を変更することになるので直接UIを知らなくても間接的にその仕様について知っていることになりますし、Infra側のInterface Adapters層もデータベースかWebAPIかでインターフェースが異なるため実体型としてデータベースやWebAPIを参照していなくともメソッド名やその引数から外側の層の事情はある程度把握できます。
またデータベースからWebAPIへの移行の際にはInfra側のInterfaceAdapters層の変更が必要になります。  
  
原文の記事でも冒頭で  
>Nothing in an inner circle can know anything at all about something in an outer circle.  
>
>意訳  
>内側の層は外側の層について全く知らないこと。  

と強調しながらも、Interface Adapter層の説明でSQLデータベースを例に出しながらInterface Adapter層で外側の層を知っていることは致し方ないことだと書いています。(ただ同時に外側の層がInterface Adapter層に与える影響は必要最低限に留めることも強調しています。)
>If the database is a SQL database, then all the SQL should be restricted to this layer, and in particular to the parts of this layer that have to do with the database.
>
>意訳  
>もしデータベースがSQLならば、SQLに関するコードはInterface Adapter層の内データベースと関与する箇所のみにとどめるべきである。  

### ルール2:層をまたぐオブジェクトはシンプルなデータ構造であること
層同士で連携してオブジェクトの受け渡しを行う際には層の責務が漏出してしまう危険性があります。  
アプリケーションとして動くためには層間の連携は避けられませんが、ある層のオブジェクトが他の層に渡されることでそのオブジェクトが属する層以外で利用されることになるからです。  
クリーンアーキテクチャではこうした状況でも関心の分離を保つために、層をまたぐオブジェクトはシンプルなデータ構造であることをルールとしています。  

もし層をまたぐオブジェクトが複雑な処理のメソッドを持っていた場合、またいだ先の層でもそのメソッドの呼び出しが可能であるためそのメソッドを通して複雑な処理が行われて責務が他の層へ漏出していってしまう恐れがあります。  
こうした場合受け渡し元の層からメソッドを持ったオブジェクトが受け渡し先でどのように利用されるのか想定しきれないため、開発における不確実性が高まりバグの温床となります。  
　　
それに対してこの層をまたぐオブジェクトがメソッドを持たないデータ構造である場合は、他の層ではそのデータ操作のみ可能となるため渡す側の層はそのオブジェクトが他の層へ与える影響を制御可能です。  

このように層をまたぐオブジェクトをシンプルなデータ構造にすることによって、層の責務の漏出は必要最低限かつ予測可能なものとなり関心の分離は高い水準に保たれます。 

ちなみにここでいうメソッドを持ったオブジェクトとは層の責務の漏出につながるようなメソッドを指しています。  
例えばSwiftのArrayはメソッドを持っていますが、それらのメソッドは自身の操作に関するものが中心でそこから層の責務が漏出してしまうようなメソッドはないため層の受け渡しで利用しても問題ありません。  


他にもこの場合におけるシンプルなデータ構造とは何を意味しているのかについてはもう少し掘り下げた方が良いと思うため、記事の最後に補論として取り上げました。  

### ルール3：データフローは一方向
これはクリーンアーキテクチャの原文に明言されているわけではないのですが、開発時には自然とこれを守るようにしますし、またクリーンアーキテクチャに限らず設計においてデータフローが一方向であるということは重要なことなのでルールとして加えました。  
クリーンアーキテクチャの右下の図はデータフローにも関係しているので、それを用いて説明します。  
この図では正確には他のことにも言及しているのですが、とりあえずここではデータフローについてのみ取り上げます。  

アプリケーションに関するデータフローを円図に沿ってたどっていくと、入力は円の外側のUIから起こり、その処理のため内側のBusiness Logicに入っていき、再びその結果は出力先であるUIに向かうため円の外->内->外と流れていき一見一方向になっていないように思いますが、それはこの円図がデータフローではなく依存関係に着目して作られているからであって実際のところデータフローも一方向となっているいます。  

具体的に説明すると上で示した図が表しているようにデータフローはContrller->UseCase(Applciation)->Presenterとなっていて、これらは円図で見ると外->内->外ではありますが実際には最初に外から内へ入る時と、そのあと内から外へ出ていく時の経路が異なるため実質的にデータのフローは一方向となっているのです。  

これはMVCのControllerやMVPのPresenter等、一つのコンポーネントが画面の入出力を担当している場合も同じです。  
これらのコンポーネントでは一つの中に入出力の責務がありながらも、実際のコード上では入力と出力の責務が交わらないように設計されていることが前提となっています。 

のちに見るように開発時、入出力で一つのコンポーネントにまとめている場合でもプロトコル上は入力用と出力用で別々に定義してそれら両方を一つのコンポーネントが採用しているというケースが多いです。  
そのようなケースでクリーンアーキテクチャ全体のデータフローを示した一例を下に載せときます。  


## ルールを守るためのテクニック
クリーンアーキテクチャについていろいろと説明してきましたが、その最重要ルールとも言える「円の内側が外側についてなにも知らない」ままアプリケーションを実現する方法については説明していません。  
アプリケーションのあらゆる操作は最終的にUIへの出力という形で表れますし、また技術的にもBusiness LogicはInfraに依存しているはずなので円の内から外への矢印がないことは不可解なことのように思えます。  
ここではクリーンアーキテクチャの依存が外側から内側のみにする問題をどう解決すればよいか説明していきます。  

### 依存関係逆転の原則(Dependency Inversion Principle)
これには依存関係逆転の原則(Dependency Inversion Principle)というテクニックを利用します。    
「依存関係逆転」と聞くと難しそうに聞こえるのですが、要はあるコンポーネントに依存するとき実体型ではなく抽象型(Swiftでいうプロトコル)に依存するというだけです。  
なぜプロトコルに依存することで層の外側から内側の依存のみになるのかというと、実体型による依存関係では利用する側(上位)の層から利用される側(下位)の層への依存となりますが<sup>[*2](#footnote2)</sup>、プロトコルを利用した依存関係の場合、そのプロトコルは利用される側(下位)の層ではなく利用する側(上位)の層に属していると考えられるからです。  
そうなると実体型の依存では利用する層から利用される層へと依存利用するコンポーネントも利用されるコンポーネントも利用する側の層にあるプロトコル依存していることになり依存関係が逆転しています。  

いくつか例を見てみましょう。

### 依存関係逆転の例
クラスAがクラスBを利用している場合、その依存関係はA->Bとなり利用する側のAが利用される側のBに依存しています。  
ここで「BType」というプロトコルを定義して、クラスAはBTypeプロトコルを利用してさらにクラスBはBTypeプロトコルに準拠した場合、A->BType<-BとなりクラスAもBもBTypeプロトコルに依存していることになります。(堅苦しいですが、Swiftではある実体型にプロトコルを適用する場合「プロトコルに準拠する」とよく表現します。)
そしてBTypeプロトコルは利用する側であるクラスAの層に属していると捉えられているため、プロトコルを利用せず実体型のみの依存関係では利用する(上位)側が利用される(下位)側に依存していた関係性が、プロトコルを利用した場合利用される側から利用する側への依存に逆転したことになります。  
これがプロトコルを利用した依存関係の構築が「依存関係逆転」と言われている理由であり、クリーンアーキテクチャでは内から外の依存がないと言われている理由です。  
クリーンアーキテクチャでは内から外への依存が必要なときはプロトコルを利用しています。  

#### プロトコルを利用する実体型から切り離される
プロトコルを利用した依存が「依存関係の逆転」と言われているから内から外の依存はないというのはただの概念的な操作であって、レトリックにしかすぎないと思う人もいるかもしれません。  
ただここでもう一度思い返して欲しいのですが、クリーンアーキテクチャで外から内への依存のみ許している理由は以下の二つです。  
- Business Logicを外側の層から切り離す
- テストを容易にする

実体型を利用した依存関係では満たすことはできない上記の要件をプロトコルを利用することによってしっかり満たすことができるようになっています。  
Infra側ではアプリケーションが利用するのは実体型としてのInfraクラスではなくInfraの要件を満たしたプロトコルであるため、Business Logic層では実際のInfraクラスが完成していなくともプロトコルに準拠した仮コンポーネントを使ってテスト可能ですし、UIも同様にデザインが完成していなくともとりあえずコンソールなどに出力して値が正しいか確認できます。  

内から外への依存を行いたいときのテクニックとして依存関係逆転の原則を紹介しましたが、実際には外から内への依存でも積極的にプロトコルを利用することをオススメします。  
UIのテストを行いたいときなど、出力値が正しいかどうかではなく出力値を表示するレイアウトを確認したいといった場合があると思います。  
こうした場合、UIからViewModelやPreseterなどの実体型に依存することなくプロトコルに依存することで仮コンポーネントを利用してテストを行うことができます。  
このように依存の方向性関係なくプロトコルを利用した依存関係を構築するとテストが行いやすくなるため積極的に使っていった方が良いと思います。  
プロトコルについては記事最後の補論でも取り上げています。  

## クリーンアーキテクチャにある誤解
一通りクリーンアーキテクチャについて説明したのですが、ネット上でiOSにおけるクリーンアーキテクチャを調べると大きく2点ほど誤解されているところがあると思うのでここではそれについて説明したいと思います。  

### 1. Entityに関する誤解
  
#### EntityはDomain層
ネットで調べているとEntityがData層であるような記述があるのですが、クリーンアーキテクチャにおけるEntityはData層ではなくDomain層です。  
EntityをData層としてしまうとあの円図の中心はData層ということになり、ビジネスロジックを他から切り離すというクリーンアーキテクチャの目的とは異なる意図を持った図になってしまいます。  
そうなると各層の質的な連続性、クリーンアーキテクチャの主張の論理的な一貫性が失われてしまうためクリーンアーキテクチャを理解するのは難しくなってしまいます。    

恐らくEntityをData層とする主張はデータベースの文脈におけるエンティティと混同しているのだと思います。  
データベースの文脈ではエンティティはデータベース上で操作する一つのデータのまとまりを指し、恐らくプログラミング業界ではエンティティというとこの用法が一番古くからあり広く浸透しています。    
ただ先ほどもいった通りEntityをData層と解釈してしまうと、クリーンアーキテクチャの主張と根本的に矛盾してしまうため注意が必要です。  

#### Entityはビジネスルール
そしてEntityに関してはもう一つ誤解があります。  
Entityは単純なデータ型として紹介されていることがありますが、そうではなくビジネスルールを指しておりロジックを含んでいます。  
これはクリーンアーキテクチャのEntityの定義を見ればわかると思います。  
>Entities encapsulate Enterprise wide business rules.   
>An entity can be an object with methods, or it can be a set of data structures and functions.  
>  
>意訳  
>エンティティは事業のビジネスルールである。  
>エンティティはメソッドをもったオブジェクト、もしくはデータ構造と関数の集まりである。  

このようにクリーンアーキテクチャにおけるEntityはロジックを含んだビジネスルールをカプセル化したものです。  

こちらの誤解は先ほどのEntityをData層としていた誤解ほど大きな影響はないと思うのですが、その原因は非常に複雑なように思います。  
既にクリーンアーキテクチャのEntityがなんであるかは説明できたと思うので詳細は省きますが、クリーンアーキテクチャにおけるEntityは先程のデータベースの文脈におけるEntityに加え、ドメイン駆動開発におけるEntityともVIPERアーキテクチャのEntityとも異なるからです。  
特にクリーンアーキテクチャをiOSの開発環境で実践しやすいように最適化したVIPERアーキテクチャのEntityと意味が異なるのは誤解しやすいなと感じます。(ちなみにVIPERの
エンティティもData層ではないことは強調されています。)  


### 2. Interface Adapter層の誤解
### Business Logic層のデータをUI層のデータ形式へ変換するのはUI側のInterface Adapters層の責務
クリーンアーキテクチャでApplication層であるUseCase内でTranslatorというデータ変換用のコンポーネントを利用してUI用のデータ形式に変換するという内容がありますがこれは誤りです。  

まずInterface Adapter層の役割が内側の層と外側の層の仲介役と説明しましたが、原文を引用しながら再度紹介します。  
原文のInterface Adapter層の説明では
>The software in this layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency  
>  
>意訳
>この層(Interface Adapter)はApplication層もしくはDomain層のデータを最外層に最適な形式に変換することである。
  
またそのすぐ後の説明では  
>Also in this layer is any other adapter necessary to convert data from some external form to the internal form used by the use cases and entities  
>
>意訳  
>またこの層(Interface Adapter)では最外層のデータを内側のApplication層やDomain層に最適な形式に変換する。　　

と書かれており、その方向にかかわらず内と外の層の間のデータ形式の変換を役割としています。  

[Interface Adapter層の説明](#Interface Adapter層は各層の責務の純度を高くしてくれる)で既に述べた通り、クリーンアーキテクチャで異なる層へのデータ変換を行うのはInterface Adapter層の責務で
ありこの層に閉じ込められているべきです。(見方によればApplication層内でDomain層のデータをApplication層データに変換しているといえますが、Application層でDomainデータを直接扱うことは許容されておりここでの「異なる層へのデータ変換」とは明らかに異質であるためここには含みません。)   


もしUI層へのデータ変換の責務をApplication層であるUseCaseに置いた場合、UseCaseはUIの仕様なしでは定義・実装できないことになりますし、UIの仕様に変更があった場合その影響をUseCaseが受けることになるのでクリーンアーキテクチャの「外側の層の変更の影響を内側の層は受けない」という特徴を失っていることになります。  

### Infra層のデータをDomain/Application層のデータ形式に変換するのはInfra側のInterface Adapters層の責務

#### Data層でカスタムオブジェクトのデータを返すのは誤り
Infra層とBusiness Logic層のデータ変換でもInterface Adapterで変換を行わずにData(Infra)層にあたるコンポーネントがBusiness Logicに適したデータ形式を出力しているケースがあります。  
クリーンアーキテクチャでは外側の層が内側の層の仕様を知っていることは良しとしていますが、それでも必要がなければ関心を切り離すべきですし、ここで指摘しているケースではInfra層がBusiness Logic層の事情を持ち込むことによってコードが冗長化して変更に弱い設計になってしまっています。  

具体的に例を出して説明していきます。  
  
前置きになりますが、[依存関係逆転](#依存関係逆転の原則(Dependency Inversion Principle)プロトコルはそれを利用する側(上位)の層に属すると言いましたが、ここでの論旨とは関係なくそれを踏まえると説明が冗長になってしまうため、ここではプロトコルもそれに準拠する(利用される)側の層に属することとして話をします。  
  
ObjectAというDomain層のオブジェクトをInfraを通して操作するためにObjectARepositoryを定義しているとします。  
私が指摘しているケースはこのObjectARepository内で利用するData層のコンポーネントがObjectAを返しているような設計です。  
コードでいうと以下のようになります。(この例では同期・非同期の話は関係ないので、出力の型は単純にしています。)

Data層側のコード
```
protocol ObjectADataClientType {
   func fetch() -> ObjectA
}

class ObjectADataClient: ObjectADataClientType {

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```

Repository(Interface Adapter)層側のコード
```
protocol ObjectARepositoryType {
   func fetch() -> ObjectA
}

class ObjectADataClient: ObjectADataClientType {

   private let dataClient: ObjectADataClientType
   
   init(dataClient: ObjectADataClientType) {
      self.dataClient = dataClient
   }

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```


RepositoryがDomain層のオブジェクトを返り値とするのはInterface Adapterの性質上おかしくないのですが、Data層であるコンポーネントがDomain層のオブジェクトを返すような設計だとData層はBusiness Logicに依存しており、クリーンアーキテクチャの特徴である「Infra層は独立している」を満たせていません。  

またリポジトリとデータクライアントのインターフェースが同じなのでリポジトリでは本来の責務であるデータ変換も行う必要がなく、ただデータクライアントのメソッドを呼び出して自身は何もしていません。  


そしてこのような設計がアプリケーション全体に及んだ場合、開発がしづらくなっていることに気づきます。     
仮にあるアプリケーションでObjectA~Zまでの26のオブジェクトをリポジトリで操作するとします。  
その場合一つ一つのオブジェクトに対して、リポジトリクラス(プロトコル)とデータクライアントクラス(プロトコル)を定義・実装しなければならず、さらにこれらのオブジェクトのどれかに仕様変更が起こった場合も両方に対して変更を適用しなければなりません。 
これはとても冗長で柔軟性のない設計になってしまっていると思います。  


厳密にいうとリポジトリクラスとデータクライアントクラスの出力する値は必ずしも同じではありません。  
ただどちらにしても上記のようにオブジェクトの型毎にデータクライアントクラスを定義しているとData層はBusiness Logicから独立できていませんし、いくつもデータクライアントクラス(もしくはメソッド)を定義する必要があるためコードが冗長になります。  
リポジトリとデータクライアントクラスの関係については補論RepositoryとDAOでもう少し詳しく取り上げます。  

### Infra層のデータ形式は基本Data型
ではどのように設計したら良いのかという話ですが、Data層が出力するデータ形式は基本的にSwiftのData型(でなければIntやString等のプリミティブ型)であり、Interface AdapterであるRepositoryはData層の出力したData型をドメインオブジェクトの形式に型変換するのが正解だと思います。  

### Data層のProtocolは集約する
またData層に対応するProtocolは可能な限り集約するべきでしょう。
ここでいう「集約」とは、例えばData層でWebAPIクライアントを利用する場合にはそのプロトコルは操作するデータ毎に定義するのでなくWebAPIのインターフェースで統一することです。  
こうしてData層の出力をData型にして、プロトコルをWebAPIのインターフェースに合わせることでData型からDomain層のオブジェクトへのデータ変換は本来のInterface Adapter層の責務となり、またData層はビジネスロジックの仕様から独立してるのでコードの冗長さがなくなります。  
コードで言うと以下のようになります。(この例でもこちらの意図したい箇所と関係ないので非同期の考慮はなされていませんし、メソッドのパラメーターなども正確ではありません。)

Data層側のコード
```
protocol WebAPIClientType {
   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data
}

```

### Data層のコンポーネントが独立することで再利用可能になる
こうすることでData層でなんのオブジェクトを操作するのか決めるのはData層ではなくData層を呼び出すInterface Adapter層の責務となるためInterface Adapter層はData層のクラスを再利用することが可能となります。  

図にすると以下のようになります。  
先ほどと比べてData層のコンポーネントの数が大きく減ってコードの冗長性がなくなったのがわかると思います。  


もちろんWebAPIとデータベースなどInfra毎にプロトコルを別に定義する必要がありますが、各Infra機構毎にメソッドのパラメーターなどが異なるのはその性質上致し方ないことです。  

Data層ではそのビジネスロジック固有の事情から独立するように設計しましょう。  
そうすることで関心の分離が保たれて、Data層のコードの冗長さがなくなります。  

>　補論: RepositoryとDAO
>　

## レイヤードアーキテクチャ+クリーンアーキテクチャ+αで設計について考える
前回の記事と合わせてレイヤードアーキテクチャとクリーンアーキテクチャを通して設計というものをみてきました。
ここではそれらと+@を考えることで設計についての考えをまとめたいと思います。  

### 1.設計とは関係性を構築することである
これは前回の記事で説明しました。  
アプリケーション設計とはアプリケーション内の関係性を構築することであり、良い設計を考えるとは開発者にとって作業しやすいアプリケーション内の関係性を構築するということになります。  

### 2.責務によって分割し、それらを単純な依存関係により組み合わせる





細かい話ですが、ここでいうメソッドを持ったオブジェクトとはある層の責務が漏れてしまうような処理を持っているものを指し、Swiftの配列Arrayなどの型は含まれません。  
例えば銀行アプリでお金の計算をするのはApplication層またはDomain層の責務ですがそのようなお金の計算処理をメソッドとして持つDomain層のオブジェクトをInterface Adapter層であるViewModelに渡してしまった場合、ViewModel側でもお金の計算が可能になってしまうためViewModelにDomain層の責務が漏れてしまっていることになります。  
それに対してArray型などSwiftが既存で提供している型はメソッドを持ってはいるもの、そのメソッドが影響を与えるのはそのデータ構造のみであり決して層の責務が漏れることはありません。  

ここに関しては他にも何を持ってデータ構造が「シンプル」であるのかという問題もあります。  
「シンプルなデータ構造」を厳密に言葉で定義しようとするとなかなか難しいのですが、ここでいうシンプルさというのは何度も言っているように層の関心を分離するためであってそれを無視して設計してしまうとおかしくなります。  
再び具体例を出すとUI側でユーザ名が必要な場合ViewModelではApplication層にユーザー名の取得を要求しますが、この時にユーザー名を含めたアプリケーションに関する全ての情報を含んだデータを渡されても完全に情報過多です。  
開発時に最初から関わっている人はその特殊な事情を知っているかも知れませんが何も知らず新しく入ってきた開発者はユーザー名の取得のためにわざわざアプリケーションに関するすべての情報を取得しあまりに多くの知識がApplication層からViewModelに漏れていることに「何か自分が理解できていないことがあるのでは？」と気を揉むことになるでしょう。    
  
また反対にユーザー名の取得のためにユーザー名のみ返す場合はそれはシンプルなデータ構造を渡しているといえますが、こうなるとユーザーの電話番号、口座番号とUI側で必要な個々の情報に応じてApplication層側に取得メソッドを定義する必要があり、それはすなわちApplication層の定義がUIの仕様に影響を受けていることになるので関心の分離ができていません。  

例に出したケースでは、基本的にはユーザー名が取得したい場合はApplcation層はユーザー情報をViewModelに渡して、ViewModel側でユーザー情報からユーザー名のみ利用するというのが正解だと思います。  
ユーザー情報はアプリケーションの仕様として一つのまとまった情報単位であることは間違いないですし、もしこのユーザー情報という単位に変更が必要な場合はそれはUI側の事情ではなくアプリケーションの事情によるものであると言って良いでしょう。

ここで出した例をもとに層をまたぐシンプルなデータ構造を持ったオブジェクトをもう少し正確に説明すると、「受け渡す二つの層のうち内側にある層の仕様を基準に設計されたシンプルなデータ構造」と言えます。  



ちなみに話が何度も逸れて申し訳ないですが、上の例でInterface Adapter層がDomain層のデータを受け取ることに違和感を持つ人もいるかも知れません。  
クリーンアーキテクチャの円図で言うとInterface Adapter層が関わるのはApplication層で直接Domain層と関わることはあり得ないからです。    
ただ実際の開発ではApplication層がInterface Adapter層にデータを渡す際にはDomain層のデータを渡すことが多いです。  

## クリーンアーキテクチャにおける層を跨ぐデータ構造がシンプルであるとはどういうことか
## Swiftのプロトコル
## RepositoryとDAO

<a name="footnote1">*1</a>: この項の始めにあるFramework&Driversが外部技術であるという箇所と外部技術に依存しているという表現は矛盾しているような表現ですが、視点が異なっているだけです。  UIKitを例に出すとUIKitは内部でApple独自のレンダリング技術を使っているため外部技術に依存しているわけですが、他の層から見るとまさにそのUIKit自身が外部技術なわけです。

<a name="footnote2">*2</a>: ここでいう利用するとは実際にインスタンスを参照しているという意味であり、プロトコルに準拠していることは指していません。本来は括弧内で書いているように上位、下位と
表現することで十分だと思いますが、個人的にこれらの表現は淡白な割にどちらを上と見るかは捉え方次第で変わってしまうためあまり好きではなく利用する側、される側という表現しています。
