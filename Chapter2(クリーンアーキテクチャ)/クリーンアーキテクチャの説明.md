
# iOSアプリでスケールしやすいアーキテクチャを考えてみた②-設計を理解するためのクリーンアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)**設計を理解するためのクリーンアーキテクチャ編←本記事**  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への準備編として設計の概観を理解するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  
また本記事はレイヤードアーキテクチャの知識を前提としていますので、レイヤードアーキテクチャがわからない方は前の記事から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

### 記事内の用語の表記ルール 
#### アーキテクチャと設計
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの言葉の定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるもの  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっていることが多いと思うのでこの記事では上のように区別することとします。  
#### 各層の表記
記事内でアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。    
例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logic(層)と表記します。  
InfrastructureはInfraと省略して表記し、Infra層のうちデータ操作に関するものをData(層)、端末機能に関するものをDevice(層)と表現する場合があります。  


## 前回までの内容と本記事の内容
初回である前回の記事ではスケールしやすいアーキテクチャを考えるためにクリーンアーキテクチャを通して設計を理解することを最初の目的としました。  
そしてその準備としてクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャの理解を深めたのが前回までの内容です。

本記事ではいよいよクリーンアーキテクチャを学び、設計についてまとめたいと思います。

## クリーンアーキテクチャとレイヤードアーキテクチャの共通点/相違点
最初に前回学んだレイヤードアーキテクチャと今回学ぶクリーンアーキテクチャの共通点、そして相違点について整理することでクリーンアーキテクチャを理解するために必要なポイントをまとめます。   
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>


前回の記事でレイヤードアーキテクチャの特徴が**責務による層の分割と単一方向の依存関係による関心の分離**であることを述べました。  
クリーンアーキテクチャでもそれは変わりません。    
円の中の一つ一つの色が層を示していて、また円内側の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格はつかめているといえます。  
ただクリーンアーキテクチャではその詳細が異なります。  
なのでクリーンアーキテクチャを理解するためにその層の分割と依存関係の詳細を見ていきたいと思うのですが、これらを理解することはクリーンアーキテクチャが円である理由を理解することと同じです。  
そのため最初にクリーンアーキテクチャが円である理由を踏まえながら円の各層・依存関係について説明していきたいと思います。  

## Entities == Domain層 && Use Cases == Application層
最初にクリーンアーキテクチャが円である理由を見ていきますが、その前に前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所があるので説明します。    
結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層であり、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層と同じです。     
円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」です。  
前回の記事でDomainとは「事業の知識・ルール」を意味していることを書きましたが、ここからEntitiesがDomainと同じであることがわかると思います。    
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesに書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要でしょう。

以後EntitiesではDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため

クリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか？  
実はその答えはレイヤードアーキテクチャの記事ですでに書いています。  
レイヤードアーキテクチャの記事のPresentation Domain Separation(以下PDSと表記)の説明でビジネスロジックを「アプリケーションプログラムの機能的中心」と表現しましたが、まさにこれがBusiness LogicであるDomainとApplicationが円の中心にある理由です。  

### Business Logicを円の中心に置く3つの理由
その理由をもう少し具体的に示すと以下のようになります。  

1. サービスのアイディアを具体化したものがBusiness Logicのデータ・ロジックであり、Business Logicなしではアプリケーションは成立しない   
2. Business LogicはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. Business Logicは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

以下ではそれぞれの詳細について説明します。  
#### 1.ビジネスはアイディアから
Business Logicを円の中心に置く理由として3つ挙げましたが他の2つは副次的なものであり、これこそがクリーンアーキテクチャの中心にBusiness Logicを置く理由です。  
「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、プログラム化したものがDomain層であり、さらにそれをアプリケーションとして提供するために書かれたプログラムがApplication層です。  
UI層はそのサービスをユーザーへ提供する窓口として存在しInfra層はそのサービスの実現のための手段として必要であって、アプリケーションは必ずBusiness Logicから生まれます。      

#### 2.Business Logicは相対的に変更されづらい層
またそれはBusiness Logicがアプリケーションの中で相対的に変わりづらい箇所であることも意味しています。(ここでいう「変更」はアプリケーションの仕様変更や機能的に要求によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。)  
UIやInfraはBusiness Logicが変わることがなくてもUXや技術的なパフォーマンスの観点から変更することがあります。  
それに対してサービスの仕様が変更された場合はBusiness Logicは変更されますが、それに応じて必ずUIやInfraも変更を迫られることになります。  
このようにBusiness Logicはアプリケーションの機能的中心でサービスそのものであるため、Business Logicの定義が変わる場合はそれに応じて他の層も変更する必要があります。  

#### 3.外部技術に依存していない
これはどちらかというと「Business Logicが円の中心である理由」というよりも「Business Logicが他の層から切り離される理由」といった方が良いかもしれません。   
ただBusiness Logicが純粋なプログラミング言語の定義によってのみ構成されて外部技術に依存しないのは、結局そのサービスの核心であるため外部技術に依存していないという話につながりますし、この「外部技術に依存していない」という側面は円図を説明する上で重要な要素であるため理由の一つに加えました。       


### クリーンアーキテクチャは現実の開発状況をより反映させている
そしてこうしたDomainとApplicationを中心に据えたクリーンアーキテクチャはレイヤードアーキテクチャと比べてより現実を反映させた設計であると言えます。  

レイヤードアーキテクチャでは技術的な側面から依存関係を決定したため、技術的な基盤となるInfraをアプリケーションの支えとして捉え「UI->Application->Domain->Infra」という関係でした。  
それに対してクリーンアーキテクチャはアプリケーションの機能的中心であるBusiness Logicがアプリケーションを支えていると捉え、他の層がBusiness Logicに依存しています。  
クリーンアーキテクチャのこの構造は現実のアプリケーション開発の実態をより正確に捉えています。  
アプリケーションは技術的にはインフラに依存していますが、サービス的に依存しているのはビジネスロジックであり開発はビジネスロジックを起点に動きます。  
そのためビジネスロジックを中心として他の層と切り離すことで、実務で発生する要件に柔軟かつ迅速に対応することが可能になるのです。  
私たちの日々の業務でも技術的にはインフラであるインターネットに依存しつつもその活動はビジネス的な事柄に依存していますが、それと同じです。  

図  
このようにクリーンアーキテクチャは技術的には(レイヤードアーキテクチャでは)4層の中間に位置するBusiness Logicをアプリケーションの基盤と捉えたアプリケーション設計であり、それを
視覚的に示すため円の形となっています。  

## Framework & Drivers層とInterface Adapter層
クリーンアーキテクチャがなぜ円なのかについて理解できたところで、まだ説明されていないFrame & Drivers層とInterface Adapter層について説明していきます。  
### Framework & Drivers層
まずFrame & Drivers層から説明します。  

Framework&Driversの意味はFrameworksはフレームワーク、つまりiOSのUIKit等パッケージ化された外部技術、DriversはIT用語でシステムに装着する外部装置を意味しておりこの層はビジネスロジックをアプリケーションプロダクトとして完成させるために必要な外部技術群と指していると言えます。  
円を見てみるとこの層にはUI/Web/DataBase/Devices/External Interfacesとさまざまなものが表記されており、レイヤードアーキテクチャのUI、Infraそしてフレームワーク等がここに含まれています。  
ここではレイヤードアーキテクチャで異なる層であったUIとInfraが一つの層とされているわけですが、私たちは既に同様のケースを前回の記事でも見ています。  
PDS(以下)のPresentationです。  
PDSのPresentationにはUIのみならずInfraも含まれることを前回の記事で説明しましたが、クリーンアーキテクチャでも同様に同じ層として扱っているのはこの2つが以下の共通点を持っているためです。  
- 仕様の変更によってプログラムが変化しやすい
- 外部技術に依存している<sup>[*1](#footnote1)</sup>

こうした特徴を持った層に他の層が依存していると、変更による影響が依存している他の層にも広がってしまい柔軟な開発を行うことが難しくなります。  
そのためクリーンアーキテクチャではこれらの特徴を持ったUI/Infra層が他の層から依存されないように同じ最外層に置いているのです。

### クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない
これはこのあとのInterface Adapters層にも言えることですが、クリーンアーキテクチャの層がアプリケーションのディレクトリ構造になることは滅多にありません。    
Framework&Drivers層のUIとInfraは実際のアプリケーション開発では区別されることが多いですし、またInterface Adapters層でもPresenter等UI側のコンポーネントとRepository等Infra側のコンポーネントは区別されます。  
その理由はクリーンアーキテクチャの層の構成がディレクトリ構造の目的と合致していないからです。  
ディレクトリ構造ではそのディレクトリにどのような責務のプログラムが置かれているかを具体的に示す必要がありますが、クリーンアーキテクチャではよりメタ視点から層を捉えています。  
例えばFramework&Drivers層はBusinessLogicに対する外部プログラムであることを意味しているだけであり、UIやInfra等のように具体的にどのような責務を担っているのか示しているわけではありません。     
そのためアプリケーションのディレクトリ構造はレイヤードアーキテクチャの責務分割に沿って成り立っていることが多いです。    
このようなところからクリーンアーキテクチャとレイヤードアーキテクチャでは層を捉える視点の次元が異なることがわかります。  

図

### Interface Adapters層

さて、残る一つはInterface Adaptersです。  
Interface Adapterという言葉だけ聞くとなにやら難しく感じてしまうのですが、簡単にいえばこの層は内側のBusiness Logicと外側のFramework&Drivers層を繋ぐための仲介役を担う層です。  

円図ではこの層に該当するコンポーネントとしてController/Presenter/Gateway等が書かれていますが、基本的にこれらのうちControllerとPresenterがUIとビジネスロジックの、GatewayがBusiness LogicとInfraの仲介役を担っています。  
iOSMVCのControllerに当たるViewControllerもここに属し、円図でいうController/Presenterを担っています。  
図

#### MVCのControllerと円図にあるControllerは異なる
ややこしいのですが、MVCアーキテクチャの文脈でいうControllerと円図に書いてあるControllerは意味が異なります。  
私たちにとってはControllerというと画面の入出力処理を担うMVCアーキテクチャのControllerが馴染み深いと思いますが、ITにおける一般的なControllerは入力のみに関する処理装置を意味していて出力に関する意味は含まれていません。  
これはMVPのPresenterにも同じことが言えて、Presenterは一般的には出力のみに関する処理装置を指しておりMVPのPresenterは円図でいうControllerとPresenterの両方の責務を担っていることになります。  

#### Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる
このInterface Adapters層が担う層の仲介という責務はレイヤードアーキテクチャでは存在していませんでしたが、実際に開発で実践してみるとこの層の重要性に気づきます。  
層同士が連携して責務が混ざり合った箇所を一つの独立した層として捉えることで各層責務の純度が格段に上がるのです。  
  
レイヤードアーキテクチャの層はアプリケーションを機能によってわかりやすく分割していますが、それはあくまで理論上の話であって実際のアプリケーションでは各層が連携して一つのアプリケーションとして動作するため複数の層の責務が交わり境界が曖昧な処理が発生します。  
例えばDomain層ではビジネス的な事柄が関心の対象なので、永続化機構でデータを更新するためのURLやそのためのデータ形式の変換に関心を向けるべきではありません。  
ただ一方でInfra層ではデータを永続化するという汎用的な責務を担ってはいるものの、特定のURLやそれに関する処理はそのアプリケーション(ドメイン)固有なものなのでInfra層がその責務を負うのはおかしなことです。  
このようにレイヤードアーキテクチャによる層の分割を実践しようとするとその層の境界でどっちつかずな責務が発生してしまい、このような責務は妥協の末に基本的に利用する側(上の例ではDomainがInfraを利用するのでDomain層)に実装されるようになります。  

この問題を解決するためにクリーンアーキテクチャではレイヤードアーキテクチャの層が連携する責務も一つの独立した層として捉えました。  
こうすることで円の内側のビジネスロジックと外側のFramework & Drivers層に不純な責務を含める必要がなくなり、各層の責務の純度を高く保つことができます。   

図

#### RepositoryもInterface Adapters層
ちなみに円図では表記されていませんが、開発でよく耳にするRepositoryもこのInterface Adapters層に入ります。  
Marin Flower氏の定義を引用するとRepositoryはDomain層とData層の仲介役です。(引用文のdata mapping layersはData層を指しています。)  
>A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection  
>
>意訳
>RepositoryはDomainとData層の中立ちをし、インメモリなドメインオブジェクトコレクションのように振る舞います
円図でいうとGatewaysの中に含まれていると考えればよいと思います。   

#### Gatewayとは異なる層の中継役という意味
Gatewayという名前はクラス名としてはあまり聞き慣れないと思いますが、ネットワークの文脈では異なる層の中継役を担う装置を指しており、クリーンアーキテクチャでも同様の意味を持っています。    
私はInterfaceAdapter層のコンポーネント名を命名するとき、できる限り~Repository等より具体的な名前を使うようにしていますが適切な名前が見つからない時はGatewayの名前を使っています。    
Gatewayは広範囲を示す名前ではありますが、プロジェクト内で乱用されるような名前ではなくそれだけでInterface Adapter層のコンポーネントだと伝わると思うので「~Managerクラス」や「~Serviceクラス」等より責務が明確で便利な単語だと思います。  

## クリーンアーキテクチャの依存ルール
クリーンアーキテクチャでの依存は外側の層から内側の層へという方向であること、また外側の層の仕様は変わりやすく内側の層の仕様は変わりづらいことを説明しました。  
つまりクリーンアーキテクチャの依存は変更されやすい外側の層から変更されにくい内側の層へ向いており、こうすることで外側の層の変更のされやすさがアプリケーションへ影響することを最小限に抑えています。  
ただ技術的に依存しているのはInfra層のはずなのに、Infra層がビジネスロジックに依存するということはどういうことなのでしょうか？  
これについてはこの後クリーンアーキテクチャのルールを守るためのテクニックという節で説明します。  

## クリーンアーキテクチャの概要を一度整理する 
ここまででクリーンアーキテクチャの特徴に一通り触れました。  
しかしレイヤードアーキテクチャの理解を前提として話を進めたため、クリーンアーキテクチャの基本的な説明をあまりしていません。        
そのためこれまでの内容と重複する部分もありますが、ここで一度クリーンアーキテクチャの原文に沿った形でその概要を整理したいと思います。  

## クリーンアーキテクチャの特徴   
クリーンアーキテクチャの記事の冒頭では、ヘキサゴナルアーキテクチャ・オニオンアーキテクチャなどのシステムアーキテクチャを紹介しています。  
システムアーキテクチャの意味は私も正確に理解しているわけではないのですが、恐らくアプリケーションの特定の領域にこだわらずシステム全体を関心の対象としているアーキテクチャという理解で大丈夫だと思います。     
クリーンアーキテクチャ原文ではそれらシステムアーキテクチャの特徴として以下の共通点があると述べています。    

1. 関心の分離  
どのシステムアーキテクチャも関心の分離を基本として、少なくともBusiness Logicとその他の2層に分けようしている  
2. UI/WebAPI/データベース/フレームワークといった外部技術が独立している  
アプリケーションのうち変更されやすいUI/Web API/データベース/フレームワーク等のコードにどこからも依存しない  
このような外部技術は便利なものの、同時に開発時の制約も発生するためこれらに依存しないようにすることで柔軟な開発が可能になる  
3. テストしやすい  
Business Logicも特定の外部技術に依存していないためテストが容易になる  
またのちに見るように層の依存関係をclassなどの実体型で実現するのではなく、プロトコルを利用した抽象型によって実現することでビジネスロジック以外の層でもテストがやりやすい  

そしてクリーンアーキテクチャの円図はこうした特徴を視覚的にまとめたものです。  

### クリーンアーキテクチャの層は4つである必要はない
クリーンアーキテクチャはDomain/Applicatoin/Interface Adapters/Framework&Driversという4つの層からなっていると説明しましたが、原文には必要であればもっと層を増やしても構わないと書かれています。  
ただ該当箇所の小見出しには「Only Four Circles?(4つの層だけ?)」と書かれており、基本的に4つの層より多くなることはあっても4つの層より少なくなるようなことはないという考えのようです。   
私も責務の分離を目的とするなら少なくともBusiness Logic/Interface Adapters/Framework&Driversの3層は必要だと考えていますし、Business Logicも設計者が層の分割を意識してるかどうかは別としてその中で責務をしっかり分けていくと実質的にはDomain/Applicationの分離が生まれてくると思うのでこの4層を基本として、必要であればそれ以上に層を分けるというスタンスで良いと思っています。    

## クリーンアーキテクチャで守るべきルール  
クリーンアーキテクチャの特徴を保つためには開発者が守らなければいけないルールがあります。  
それは大きく言って以下3点です。  

### ルール1:円の内側の層は外側の層については知らない何も知らないし、影響も受けない
Business Logicは外側の層について何も知らなくても独立して動作できるようになっている必要があります。  
それはBusiness Logic内のDomain層とApplication層に関しても同様で、内側の層であるDomainは外側のApplicationについて知っているべきではありません。  
クリーンアーキテクチャではアプリケーションとして動作するために各層は連携しつつも可能な限り関心を分離することを目的としているため、依存して良いのは外側の層から内側の層へのみとなっています。  

#### しかしInterface&nbsp;Adapters層は例外
ただこのうちInterface Adaptersは少し例外といえます。   
既に説明した通りInterface Adaptersは内側と外側の層の中継役となる層なので直接的ではなくても外側の層の事情を知ることになるからです。  
具体的に説明すると、UI側のInterface Adapters層はUIの仕様変更によって自身の入力・出力の処理も変更することになるので直接UIを知らなくても間接的にその仕様について知っていることになりますし、Infra側のInterface Adapters層も実体型としてデータベースやWebAPIを参照していなくともメソッド名やその引数から参照先がデータベースかWebAPIか等外側の層の事情はある程度把握できます。
またデータベースからWebAPIへの移行等Infra側の機構を変更した場合には、基本的にそれに関連するInterfaceAdapters層も変更が必要になります。  
  
原文の記事でも冒頭で  
>Nothing in an inner circle can know anything at all about something in an outer circle.  
>
>意訳  
>内側の層は外側の層について全く知らないこと。  

と強調しながらも、Interface Adapter層の説明でSQLデータベースを例に出しながらInterface Adapter層で外側の層を知っていることは致し方ないことだと書いています。(ただ同時に外側の層がInterface Adapter層に与える影響は必要最低限に留めることも強調しています。)
>If the database is a SQL database, then all the SQL should be restricted to this layer, and in particular to the parts of this layer that have to do with the database.
>
>意訳  
>もしデータベースがSQLならば、SQLに関するコードはInterface Adapter層の内データベースと関与する箇所のみにとどめるべきである。  

### ルール2:層をまたぐオブジェクトはシンプルなデータ構造であること
層同士で連携してオブジェクトの受け渡しを行う際には層の責務が漏出してしまう危険性があります。  
アプリケーションとして動くためには層間の連携は避けられませんが、ある層のオブジェクトが他の層に渡されることでそのオブジェクトが属する層以外で利用されることになるからです。  
クリーンアーキテクチャではこうした状況でも関心の分離を保つために、層をまたぐオブジェクトはシンプルなデータ構造であるであるべきだとしています。    

もし層をまたぐオブジェクトが複雑な処理のメソッドを持っていた場合、またいだ先の層でもそのメソッドの呼び出しが可能であるためそのメソッドを通して複雑な処理が行われて責務が他の層へ漏出していってしまう恐れがあります。  
こうした場合受け渡し元の層からメソッドを持ったオブジェクトが受け渡し先でどのように利用されるのか想定しきれないため、開発における不確実性が高まりバグの温床となります。

図
　　
それに対してこの層をまたぐオブジェクトがメソッドを持たないデータ構造である場合は、他の層ではそのデータ操作のみ可能となるため渡す側の層はそのオブジェクトが他の層へ与える影響を制御可能です。  

このように層をまたぐオブジェクトをシンプルなデータ構造にすることによって、層の責務の漏出は必要最低限かつ予測可能なものとなり関心の分離は高い水準に保たれます。 

図

ちなみにここでいうメソッドを持ったオブジェクトとは層の責務の漏出につながるようなメソッドを持っているものを指しています。  
例えばSwiftのArrayはメソッドを持っていますが、それらのメソッドは自身の操作に関するものが中心でそこから層の責務が漏出してしまう恐れはないので層の受け渡しで利用しても問題ありません。  

他にも層を跨ぐデータについてはもう少し掘り下げたい点があるため、記事の最後に[補論](#クリーンアーキテクチャにおける層を跨ぐデータ構造がシンプルであるとは)として取り上げました。  

### ルール3:データフローは一方向
これはクリーンアーキテクチャの原文に明言されているわけではないのですが、開発時には自然と守るようにしますし、またクリーンアーキテクチャに限らず設計において重要であるためルールとして加えました。  

アプリケーションのデータフローを円図に沿ってたどっていくと、入力は円の外側のUIから起こり、その処理のため内側のBusiness Logicに入りそして再びその結果は出力先であるUIに向かうため円の外->内->外と流れていて一見すると一方向になっていないように思えます。  
しかしそれはあの円がデータフローではなく依存関係に着目して作られているからであって実際のところデータフローも一方向となっています。
それを示すのがクリーンアーキテクチャの右下の図です。(実際には依存関係も示した図なのですがここではデータフローについてのみ触れます)    

図が表しているようにデータフローはContrller->UseCase(Applciation)->Presenterとなっており、これらは円図で見ると外->内->外ではありますが実際には最初に外から内へ入る時と、そのあと内から外へ出ていく時の経路が異なるため実質的にデータのフローは一方向となっているのです。  

これはMVCのControllerやMVPのPresenter等、一つのコンポーネントが画面の入出力を担当している場合も同じです。  
これらのコンポーネントでは一つの中に入出力の責務がありながらも、実際のコード上では入力と出力の責務が交わらないように設計されていることが前提となっています。 

以下イメージ図


## ルールを守るためのテクニック
クリーンアーキテクチャについていろいろと見てきましたが、最重要ルールと言える「円の内側が外側についてなにも知らない」を守りながらアプリケーションをどう実現するのかについてまだ触れていません。    
アプリケーションは技術的にInfraに依存しているはずなので円の内から外への依存がないのは不可解なことのように思えます。  
ここではこの問題をどう解決すればよいか説明していきます。  

### 依存関係逆転の原則(Dependency&nbsp;Inversion&nbsp;Principle)
これには依存関係逆転の原則(Dependency Inversion Principle)というテクニックを利用します。    
「依存関係逆転」と聞くと難しそうに聞こえるのですが、要はあるコンポーネントに依存するとき実体型ではなく抽象型(Swiftでいうプロトコル)に依存するというだけのことです。  
なぜプロトコルに依存することで層の外側から内側の依存のみになるのかというと、実体型による依存関係では利用する側(上位)の層から利用される側(下位)の層への依存となりますが<sup>[*2](#footnote2)</sup>、プロトコルを利用した依存関係の場合はそのプロトコルは利用される側の層ではなく利用する側の層に属していると考えられるからです。  
そうすると利用するコンポーネントも利用されるコンポーネントも利用する側の層にあるプロトコル依存しているため依存方向が逆転しています。  

もう少しわかりやすく説明するために以下で簡単な例を示します。  
### 依存関係逆転の例
クラスAがクラスBを利用しているとします。  
その場合それらの依存関係はA->Bとなり利用する側のAが利用される側のBに依存しています。  
図
ここでこれらに依存関係逆転の原則を適用するためクラスBの要件を満たした「BType」というプロトコルを定義し、クラスAはBクラスを直接利用するのではなくBTypeプロトコルを利用するようにします。  
この時BTypeプロトコルはBクラスの要件を全て満たしているのでAクラスはBクラスを利用していた時と同じようにBTypeプロトコルを利用できます。  
またクラスBはBTypeプロトコルに準拠するようにします。(堅苦しいですが、Swiftではある実体型にプロトコルを適用する場合「プロトコルに準拠する」とよく表現します。)  
そうなるとクラスAはBTypeプロトコルを利用しBクラスもBTypeプロトコルに準拠するため、先程のA->Bで表していた依存関係はA->BType<-Bに変化していることがわかります。(ここではプロトコルに準拠することも一種の依存であるとします)  
そしてBTypeプロトコルは利用する側であるクラスAの層に属していると捉えられているため、先ほどは利用する側から利用される側へ(A->B)の依存であった関係がプログラミング的には利用される側から利用する側への依存に逆転したことになります。  
図
これがプロトコルを利用した依存関係の構築が「依存関係逆転」と言われている理由であり、クリーンアーキテクチャではこの原則を用いて層の内から外への依存を行わないようにします。  

### プロトコルを利用することでプログラムの変更を行いやすくなる
プロトコルを利用した依存が「依存関係の逆転」と言われているから内から外の依存はないというのはただの概念的な操作であって、レトリックにしかすぎないと思う人もいるかもしれません。  
ただここでもう一度思い返して欲しいのですが、クリーンアーキテクチャで外から内への依存のみ許している理由は以下の二つです。  
- Business Logicを外側の層から切り離す
- テストを容易にする

実体型を利用した依存関係では満たすことはできない上記の要件をプロトコルを利用することによってしっかり満たすことができるようになっています。  
Infra側ではInterface Adapters層のコンポーネントが利用するのは実体型としてのInfraクラスではなくInfraの要件を満たしたプロトコルであるため、Infraそのものに依存することはなくなり実際のInfraクラスが完成していなくともプロトコルに準拠した仮コンポーネントを使ってテスト可能になります。  
UIでも同様にデザインやUIプログラムが完成していなくともコンソールなどに出力して値が正しいか確認できます。  

### 依存の方向関係なくプロトコルは積極的に利用する
内から外への依存を行いたいときのテクニックとして依存関係逆転の原則を紹介しましたが、実際には外から内への依存でも積極的にプロトコルを利用することをオススメします。  
例えばUIのテストを行いたいときなど、出力値が正しいかどうかではなく出力値を表示するレイアウトが正しいか確認したいといった場合があります。    
こうした場合にはUIからViewModelやPreseterなどの実体型に依存することなくプロトコルに依存することで仮コンポーネントを利用してテストが可能になります。  
  
このように依存の方向関係なくプロトコルを利用した依存関係を構築するとテストが行いやすくなるため積極的に使っていくことをオススメします。  
  
他にも依存とプロトコルについてはいくつか書きたいことがあったので記事最後にSwiftのプロトコルという補論を書いています。  

### 内から外へのデータフローを実現する他の方法
円の内側が外側の仕様を知らずに処理する他の方法としてクロージャを完了時の処理(completion handler)として利用する方法等があります。
しかしcompletion handlerで内から外の依存を解決可能なのはUI等外側の層から処理の呼び出しを行う場合のみであって、Application/Domain層からInfra側への呼び出し等内から外へ処理を呼び出す場合はcompletion handlerを利用したとしてもどちらにせよプロトコルを利用する必要があります。  

コード例

## クリーンアーキテクチャにある誤解
ネット上でiOSにおけるクリーンアーキテクチャを調べると大きく2点ほど誤解されている箇所があるように思います。  
クリーンアーキテクチャの説明の最後にそれらについて説明します。    

### 1. Entityに関する誤解
  
### EntityはDomain層
ネットで調べているとEntityがData層であるというような内容の記事がありますが、クリーンアーキテクチャにおけるEntityはData層ではなくDomain層です。  
EntityをData層としてしまうとあの円図の中心はData層ということになり、ビジネスロジックを他から切り離すという目的とは異なってしまいます。        
そうなると各層の質的な連続性、クリーンアーキテクチャの主張の論理的な一貫性が失われてしまいクリーンアーキテクチャが何を意味しているのかわからなくなってしまうでしょう。      
図

恐らくEntityをData層とする主張はデータベースの文脈におけるエンティティと混同しているのだと思います。  
データベースの文脈ではエンティティはデータベース上で操作するデータのまとまりを指し、恐らくこの用法がプログラミングの世界で一番広く浸透しています。    
ただ先ほどもいった通りEntityをData層と解釈してしまうと、クリーンアーキテクチャの主張と根本的に矛盾してしまうため注意が必要です。  

### Entityはビジネスルール
Entityに関してもう一つ誤解があります。  
Entityは単純なデータ型として紹介されていることがありますが、そうではなくビジネスルールを指しておりロジックを含んでいます。  
これはクリーンアーキテクチャのEntityの定義を見ればわかります。  
>Entities encapsulate Enterprise wide business rules.   
>An entity can be an object with methods, or it can be a set of data structures and functions.  
>  
>意訳  
>エンティティは事業のビジネスルールである。  
>エンティティはメソッドをもったオブジェクト、もしくはデータ構造と関数の集まりである。  

このようにクリーンアーキテクチャにおけるEntityはロジックを含んだビジネスルールをカプセル化したものです。  

この誤解を生んでしまう原因は先ほどよりも少し複雑です。         
既にクリーンアーキテクチャのEntityがなんであるかは説明できたので詳細は省きますが、クリーンアーキテクチャにおけるEntityは先程のデータベースの文脈におけるEntityに加え、ドメイン駆動開発におけるEntityともVIPERアーキテクチャのEntityとも異なるからです。  
特にクリーンアーキテクチャをiOSの開発環境で実践しやすいように最適化したVIPERアーキテクチャのEntityとクリーンアーキテクチャのEntityで意味が異なるのは誤解しやすいなと感じます。(ちなみにVIPERの
エンティティもData層ではないことは強調されており、それはクリーンアーキテクチャのEntityと同じです。)  


### 2. Interface Adapter層の誤解
次にInterface Adapter層関しての誤解を説明します。  
### Business Logic層のデータをUI層のデータ形式へ変換するのはUI側のInterface Adapters層の責務
最初にクリーンアーキテクチャにおいてApplication層であるUseCase内でTranslatorというデータ変換用のコンポーネントを利用してUI用のデータ形式に変換するという内容の記事がいくつかありますが、これは誤りだと思います。      
既に[記事内](#Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる)でも説明しましたが、Applicationのデータ形式をUIのデータ形式に変換するのはInterface Adapters層の責務だからです。    

Interface Adapter層の役割を原文に沿いながら再度説明します。  
原文のInterface Adapter層の説明では
>The software in this layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency  
>  
>意訳
>この層(Interface Adapter)はApplication層もしくはDomain層のデータを最外層に最適な形式に変換することである。
  
とBusiness Logicのデータ形式を最外層に変換するのが役割だと述べたあとに
>Also in this layer is any other adapter necessary to convert data from some external form to the internal form used by the use cases and entities  
>
>意訳  
>またこの層(Interface Adapter)では最外層のデータを内側のApplication層やDomain層に最適な形式に変換する。　　

と最外層のデータ形式をBusiness Logicに最適な形に変換するとも書かれており、その方向にかかわらず内と外の層の間のデータ形式の変換を役割としているのがわかります。      

そしてクリーンアーキテクチャではこうした異なる層へのデータ変換はInterface Adapter層に閉じ込められているべきです。(見方によればApplication層内でDomain層のデータをApplication層データに変換しているといえますが、Application層でDomainデータを直接扱うことは許容されておりここでいう「データ変換」とは明らかに異質です。)   


もしUI層へのデータ変換の責務をApplication層であるUseCase(ここでいうTranslatoor)に置いた場合、UseCaseはUIの仕様を知らないことには定義・実装できないことになりクリーンアーキテクチャの[円の内側の層は外側の層について何も知らない](#ルール1\:円の内側の層は外側の層については知らない何も知らないし、影響も受けない)というルールを破ってしまいます。  
またその場合はUIの仕様に変更があった際にはUseCase側でも変更が必要であるため**外側の層の変更の影響を内側の層は受ける**ことにもつながります。  


#### Infra層のデータをDomain/Application層のデータ形式に変換するのはInfra側のInterface Adapters層の責務
Interface Adapters層ではInfra側でもよく見かける誤解があります。
#### Infra層でDomainオブジェクト型のデータを返すのは誤り
ここで指摘しているのはInfra層であるWebAPIクライアント等でDomainオブジェクトを扱っているケースです。  
クリーンアーキテクチャの記事でDomainオブジェクトをInfraで操作する際、Infraが直接Domain層の型でオブジェクトを出力するのを時々見かけます。  
クリーンアーキテクチャのルールでは円の外側の層が内側の層を知っていること自体は問題としていませんが、それでも必要がなければ層同士の関心は切り離されていた方が良いですし、先ほども述べた通り異なる層へのデータ変換はInterface Adapter層に閉じ込められているべきです。  
実際今回指摘しているケースではInfra層とBusinness Logic層の関心の分離が守られていないためにコードが冗長化して変更に弱い設計になってしまっています。  

ここではInfra層とBusinness Logic層が分離できていないことでどういう問題が起きてしまうのか具体例を用いて説明していきます。  
#### Infra(Data)層でBusiness Logic層のデータを出力する誤った例 
前置きとして[依存関係逆転](#依存関係逆転の原則(Dependency&nbsp;Inversion&nbsp;Principle))ではプロトコルはそれを利用する側(上位)の層に属すると説明しましたが、論旨とは関係ないためここではプロトコルもそれに準拠する(利用される)側の層に属するものとして話をします。  
またInfra(Data)層でデータ操作を行うコンポーネントをデータクライアントと表現します。

ObjectAというDomain層のオブジェクトをInfraを通して操作するためにObjectARepositoryを定義しているとします。  
今回指摘しているケースはObjectARepository内で利用するデータクライアントがObjectAを返しているような設計です。  
コードでいうと以下のようになります。(ここで同期・非同期は論旨とは関係ないので、Infraが出力するデータはシンプルに返り値で返されるようにしています。)  

Data層側のコード
```
protocol ObjectADataClientType {
   func fetch() -> ObjectA
}

class ObjectADataClient: ObjectADataClientType {

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```

Repository(Interface Adapters)層側のコード
```
protocol ObjectARepositoryType {
   func fetch() -> ObjectA
}

class ObjectADataRepository: ObjectARepositoryType {

   private let dataClient: ObjectADataClientType
   
   init(dataClient: ObjectADataClientType) {
      self.dataClient = dataClient
   }

   func fetch() -> ObjectA {
      return self.dataClient.fetch()
   }
}

```

上のコード例みてみるとInterface Adapters層のObjectARepositoryだけなく、Data層であるObjectADataClientもDomain層のObjectAを返しています。  
このようにData層がDomain層のオブジェクトを返す設計だとData層はDomain層について知らなければ定義・実装できないため、クリーンアーキテクチャの[Infra層はApplication/Domain層から独立している](#クリーンアーキテクチャの特徴)という特徴を満たせていません。  

またObjectADataClientTypeとObjectARepositoryTypeを比較すると両者ともにObjectAを取得していて機能が重複しており、リポジトリはデータクライアントのメソッドを呼び出しているだけで自身は何の処理もしていないことがわかります。      
コード例


#### Data層にDomain層の事情を持ち込むことでData層が肥大化する
そして上記ような設計がアプリケーション全体に及んだ場合、Data層が肥大化します。(そもそもDomainオブジェクトと切り離されていないデータアクセス処理の集まりをData層と言って良いのかわかりませんが、ここではそういうことで話を進めます。)  
仮にあるアプリケーションでObjectA〜Zまでの26のオブジェクトをリポジトリで操作するとします。  
その場合先ほどの設計に沿った形で開発するとObjectA〜Zの一つ一つのオブジェクトに対して、リポジトリとデータクライアントの両方でプロトコルと実体型を定義・実装しなければなりません。  
またこれらのDomainオブジェクトのどれかに仕様変更が起こった場合にも両方に対して変更を適用する必要があります。  
リポジトリが実質的に何の処理を行なっていないことを考えるとこの設計はあまりにも冗長なように感じます。  
図

もちろん対応するリポジトリとデータクライアントの出力する値は必ずしも同じではないため、実際のアプリケーションが完全に上記のような構成になるとは限りません。  
ただどちらにしてもDomainオブジェクト型毎にデータクライアントクラスを定義しているとData層はBusiness Logic層から独立できておらず、複数のデータクライアントクラス(もしくはメソッド)が必要であるのは同じです。    
この冗長さを回避するためにはInfra(Data)層をBusiness Logic層から切り離す必要があります。  

#### Infra層とBusiness Logic層を切り離した設計
Infra(Data)層をBusiness Logic層から切り離すためにはまず、Data層が出力するデータ形式は基本的にSwiftのData型(そうでなければIntやString等Swiftのプリミティブ型)である必要があります。    
そうするとData-Domain間のデータ変換の役割はリポジトリが担うようになり、冗長で無意味なコンポーネントではなくなります。  

またデータクライアントは可能な限り集約するべきです。  
ここでいう「集約」とは、例えばData層でWebAPIを利用する場合にはコンポーネントを操作対象毎に定義・実装を行うのではなく汎用的なWeb通信のインターフェースに統一することを意味しています。    
データクライアントをまとめることで操作対象毎にリポジトリとデータクライアントを定義・実装する手間がなくなります。  
以下がコード例です。(この例でも論旨とは関係ないため出力するデータは返り値で返されるものとし、またメソッドのパラメーターも正確ではありません。)

Data層側のコード
```
protocol WebAPIClientType {
   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data
}

class WebAPIClient: ObjectADataClientType {

   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data {
         // 引数で指定されたURLと通信を行いデータを取得する処理
         ...
         return 通信で取得したData
    }
}

```
- データクライアントの出力をData型にして、Data層からDomain知識を切り離す
- その上でデータクライアントコンポーネントを集約化する  

以上2点を注意することで複数のリポジトリからデータクライアントを再利用する設計になるためプログラムの冗長さがなくなりました。  
またデータクライアントを利用してどのデータを操作するのかはリポジトリが呼び出し時にパラメーターを通して指定するようになるので、データクライアント自身はDomainやApplicationオブジェクトから分離されています。  

変更後の設計を図で示すとこんな感じです。  

先ほどと比べてData層のコンポーネントの数が大きく減ったのがわかると思います。  
もちろんWebAPIとデータベースなどInfraの機構毎にプロトコルを別に定義する必要がありますが、それは各Infra機構でインターフェースが異なることを考えれば致し方ありません。    

Data層ではそのビジネスロジック固有の事情から独立するように設計しましょう。  
そうすることで関心の分離が保たれて、Data層の肥大化が避けられます。  

補足:
ちなみにデータクライアントでの出力は基本Data型と述べましたが、設計次第ではDomainやApplicationオブジェクトを出力することも可能です。  
例えば以下のようにジェネリクスを利用してリポジトリ側でデータクライアントの出力型を指定できる設計であれば、データクライアントはDomainやApplication層に関知しているわけではないため問題ありません。  

コード例

RepositoryとData層に関してはもう少し取り上げたい内容があったため、記事の最後に補論RepositoryとDAOを書きました。    

## クリーンアーキテクチャについてまとめる


## レイヤードアーキテクチャ+クリーンアーキテクチャ+αで設計について考える
前回の記事からレイヤードアーキテクチャとクリーンアーキテクチャを通して設計というものをみてきました。  
ここではそれらと@を踏まえて設計についての考えをまとめたいと思います。  

### 1.設計とは関係性を構築することである
これは前回の記事で説明しました。  
アプリケーション設計とはアプリケーション内の関係を構築することであり、良い設計を考えるとは開発者にとって作業しやすい形でアプリケーション内の関係を構築することになります。  

### 2.責務によって分割し、それらを単純な依存関係により組み合わせる
関係の構築のためレイヤードアーキテクチャではアプリケーションを責務によって層として分割し、それらが単一方向の依存関係になることを定義しました。  
このように責務によって分割しそれらが単純な関係で連携し合うようにすることで、開発者はアプリケーションを特定の目的を持ったプログラムの集合体として捉えることができるため、アプリケーションコードはより具体的になります。    
また責務の分割は関連性の高いコードをまとめて(高凝集)関連性の低い(ない)コードを分離する(疎結合)ので、プログラマは自身が現在担当している責務に関係するコードにだけ集中して開発を行うことができます。(関心の分離)
### 3.データフローは一方向
データフローも開発の重要な要素です。    
データフローが一方向になっていることでプログラムの流れを追いやすくなり、コードの可読性が上がります。  
レイヤードアーキテクチャの記事ではデータフローに関して直接言及しませんでしたが、実際にはレイヤードアーキテクチャも一方向のデータフローを前提としていると思います。  

レイヤードアーキテクチャのデータフローのイメージ
### 4.開発事情を考慮する
この記事ではクリーンアーキテクチャについてみてきましたが、一言でまとめると**クリーンアーキテクチャは実際の開発事情を考慮してレイヤードアーキテクチャを再構築したもの**であると言えると思います。    
レイヤードアーキテクチャでは論理的責務の分割と単一方向依存により「UI->Application->Domain->Infra」(->は依存方向)という関係を構築しましたが、実際の開発はアプリケーション機能、すなわちApplication層とDomain層を起点に動いていくため、それらがInfraに依存しているアプリケーション構造では不都合が生じることがありました。  
クリーンアーキテクチャはこうした開発事情を踏まえアプリケーションコード側でもApplication層とDomain層が中心となるようにレイヤードアーキテクチャの再構築を行なっています。
これによってアプリケーションコードはプロダクトの仕様変更にスピーディーかつ柔軟に対応できるようになりました。  

改めて言葉にすると当たり前ではあるのですが、このように設計を考える際には現実の開発事情を踏まえた上で論理を組み立てることが重要になります。    

### 5.データフローの蓄積による状態変化に考慮する
ここが+@です。  
ここでは+@の内容を明確に言葉にするために経済学のフローとストックという概念を利用します。  
それぞれを簡単に説明すると経済学においてフローは一定期間の経済活動の成果、ストックは過去からのフローの蓄積をある時点で時点で測ったものを示しています。  
どちらも経済事象を示しているのは同じなのですが、フローは特定期間、ストックは過去からの蓄積をある時点で切り取っていてそれぞれの持つ時間次元が異なります。    
具体例を出すと四半期や通年で発表されるGDP等はフロー、国家の借金など過去からの累積額を示しているものはストックです。  

さてこのフローとストックの考え方は設計にも適用できるのですが、そうすると私たちがこれまで話してきた設計の話は全てフローについてであったことに気がつきます。  
これまでの責務の分割や依存関係は全てフロー(一つのインプットからそれに対するアウトプットまでの流れ。データフロー)を前提として話されており、ストック、つまりアプリケーション開始時からのデータフローの蓄積によって生成される状態をどう管理するのかという話が出てきていませんでした。  
その理由は恐らくレイヤードアーキテクチャやクリーンアーキテクチャが提案された当時はまだハードウェアやプロダクトの仕様の関係でアプリケーション状態の管理はアーキテクチャよりもよりミクロな問題だと捉えられていたからだと思います。  

しかし近年ではFluxやReduxなどアプリケーション状態の管理を主題としているアーキテクチャが主流となり、UXや開発効率の観点からも現代的なアプリケーションの設計の際にはデータフローの蓄積(ストック)について考えることは不可欠になりつつあります。  
そのためこの一連の記事ではフローだけでなくストックも踏まえて設計について考えていきます。  

### 設計のまとめ
設計に関する要点を5点述べました。  
アプリケーション設計を簡単に言ってしまうと、それは上記の4と5を考慮しながら1~3の作業をマクロからミクロに至るまで繰り返すことだと言えると思います。  
この作業を繰り返すことで、アプリケーションはレイヤー(層)->モジュール->コンポーネントと粒度が細かく細部にまで配慮が行き届いた開発しやすいプログラムへとなっていきます。
 

## 補論クリーンアーキテクチャにおける層を跨ぐデータ構造がシンプルであるとは
本記事内で[層を跨ぐデータ構造はシンプルである必要がある](#層をまたぐオブジェクトはシンプルなデータ構造であること)と説明しました。  
しかしそもそも何をもってシンプルであると言えるのか曖昧なためここではそれについて補足します。  
### シンプルなデータ構造とは責務が漏出しないデータ構造
結論から言うと一般的に「シンプル」であるということは余計なものがないという意味で使われますが、ここでいう「シンプル」とは層の責務が漏出してしまうようなメソッドをもっていないデータ構造を指し、データとして一切余計なものがないという意味ではありません。    

具体例を用いて説明します。      
ある写真アプリのプログラムではユーザーを示すUser型と写真を示すPhoto型を定義していて、またアプリ機能の一つとしてあるユーザーの持つ写真のタイトルをリストで表示があるとします。          
必要な部分以外省略していますが、User型とPhoto型はそれぞれ以下の通りです。  

もしこの機能をクリーンアーキテクチャに沿って開発しようとすればControllerからユーザーの写真を取得するUseCaseを呼び出しその結果をPresenterに渡すという形式になり、この場合層を跨ぐデータはContrller->UseCaseとUseCase->Presenterの2箇所に存在します。          
このうちContrller->UseCaseで層を跨ぐのはUseCaseにパラメーターとして渡すデータです。  
一般的にはこのパラメーターのデータ型はUserのID型となるでしょう。  
このパラメーターはどのUserの写真を取得するか識別するためだけに利用されるため、User型をそのまま渡す必要はなくUser.ID型で十分です。        
それに対してUseCase->Presenterで渡されるデータはPhotoの配列です。  
こちらは先程と異なりPresenterで必要なのは写真のタイトル(Photo.title)だけなのに関わらず、Photoごと配列で渡されます。  
そのためPresenterではUseCaseから渡されたPhotoの配列の内titleだけを抽出します。        

これら2つのデータを比較すると、UseCase->Presenterのデータだけが余計な情報を持っています。    
必要以上の情報を持っているということは層を跨ぐデータはシンプルであるというルールを破ってしまっているように思えますが、なぜこのような状況が起こるのでしょうか？  

その理由は先程のUseCaseをコードで見てみるとわかります。     
コード例  
先程の層を跨ぐ2つのデータはUseCaseメソッドのパラメータとその出力であり両方ともUseCase(Application層)の設計の一部です。米印    
そしてこのうちパラメーターはUseCaseが自身の処理で利用するためどの型を受け取るべきなのかはわかりますが、それに対して出力がどう利用されるのかについてはUseCase自身は把握できません。  
そのためUseCase->Presenterのデータは利用するPresenterにとって余分なデータを持っている場合がありますが、これは設計上致し方ないことです。  

もしUseCaseからPresenterに渡される全てのデータの無駄をなくそうとするならばUseCaseはUI側の仕様を把握する必要があり、クリーンアーキテクチャの外側の層の影響を受けないというルールを破ってしまいます。  
またそのような全てのUIの要求にフィットするUseCaseメソッドを一つ一つ定義・実装しようとするならば、数が膨大になり層を跨ぐデータは無駄なくあらゆる面でシンプルになるかもしれませんがApplication層全体のプログラムは複雑化、肥大化していくでしょう。    


層を跨ぐデータをシンプルにする目的は層同士の関心の分離です。  
そのことを考えると上の例を見てもわかる通り層を跨ぐデータに求められるシンプルさとは要求に対して一才無駄がないことではなく、責務が他の層に漏れてしまうような構造を指していることがわかると思います。米印  

このように「シンプル」という言葉だけに着目すると誤解してしまいそうになりますが、その背景にある「関心の分離」に注意を払いながら設計を行う必要があります。  

### 層を跨ぐデータ構造をどう設計するかはケースバイケース
ちなみに他の層へ渡すデータをどのように設計するかは個々のプロダクトや設計者によります。  
例えば先程はPhoto型の配列で渡しましたが、場合によっては以下のようにPhotoは各Userのプロパティとして生やして単体では利用しないということもありえます。  
その場合UseCase->Presenterの出力はPhotoの配列ではなくUser型になります。(その場合User.IDを引数にUserを取得するのはおかしいので全体の設計も変わるでしょう)  
このように出力されるデータ型をどうするかはそのアプリケーションの提供している機能やそれらを踏まえた設計者の判断によって異なるため、これと言った正解があるわけではありません。  

### 層を跨ぐデータ型は自身の層の仕様を元に設計されるが、Interface Adapters層は例外
しかしInterface Adapters層だけは例外です。  
その理由は[記事内](#しかしInterface&nbsp;Adapters層は例外)書いたクリーンアーキテクチャの層の中でInterface Adapters層だけは外の層の影響を受ける理由と同じです。   
[先程の例のように](#シンプルなデータ構造とは責務が漏出しないデータ構造)、通常は他の層へ渡すデータ型は出力する層自身の仕様に基づいて設計されるべきです。  
しかしInterface Adapters層は受け取ったデータ型を渡す先の層に合わせて変換・出力するためそのデータ型は出力先の仕様に基づいて設計されます。  
これはInterface Adaptersが他の層と異なり主体的な目的をもたずただ仲介役として振る舞う性質によるものです。    

## 補論2:Swiftのプロトコル
本文内でテストしやすくなるという理由で[依存方向関係なくプロトコルを使った依存を利用した方が良い](#依存の方向関係なくプロトコルは積極的に利用する)と述べました。   
ここではそれについて補足します。    
### Protocol Oriented Programming
恐らくこれに関しては「依存関係構築時のプロトコルの利用」という文脈で語るよりも、より一般的なProtocol Oriented Programming(以下POPと省略)の文脈で説明した方がわかりやすいと思うのでPOPの話から始めます。    
POPとは所謂プロトコル指向プログラミングを意味しています。  
このPOPはSwiftを特徴づける概念であるためiOS等Swiftを使っているプログラマーであればよく耳にする言葉なのではないでしょうか。        
しかしよく聞く言葉ではあるにもかかわらず、POPが具体的に何を意味しているのかについてはあまり理解されていないように思います。    
POPはただ単純に積極的にプロトコルを利用するのを推奨している概念ではありません。  
POPはSwiftで提唱された概念ですが、他の多くのプログラミング言語もSwiftのプロトコルに当たる言語機能は持っています。  
そのためPOPが積極的にプロトコルを利用するという意味だけならば、なぜ他言語でも既にあった機能を「POP」という大きな言葉を使いながら推奨しているのか説明できません。    

[このオンライン書籍](https://heart-of-swift.github.io/protocol-oriented-programming/)が説明している通りPOPは同じくよく聞く言葉であるOOP(Object Oriented Programming)と対置させるとスッキリ理解できると思います。(余談ですが[先程の書籍](https://heart-of-swift.github.io/#table-of-contents)はプロトコルの説明以外にも全編通してSwiftに関して面白い考察がなされているのでオススメです。書籍と表現していますが無料です。)  
簡単に言ってしまうとSwiftの以前の多くのプログラミング言語はOOPでありオブジェクトの継承を利用して型の抽象化、多様性を実現してきましたがSwiftではオブジェクトの継承の代わりにプロトコルを利用して型の抽象化、多様性を実現することを推奨するというのがPOPです。    
Swiftでは値型と言われる構造体を積極的に利用することを推奨していてそれらに継承機能はありません。そこでオブジェクトの継承以外で型の抽象化を実現する方法として推奨されたのがプロトコルだったわけです。  
このようにPOPとはただプロトコルを使えと言ってるわけではなく値型を積極的に利用するSwiftというプログラミング言語においてOOP同様型の抽象化を実現するためにプロトコルを利用するというプログラミングスタイルを指しています。  
参照元にも書かれているとおり公式ドキュメントにもPOPが具体的になんなのかは記されていないそうです。  
しかしわざわざOOP同列に扱われるような名前にしているところからも察する以上の理解で間違っていないと思います。  

### 依存関係でプロトコルを利用する目的
そして依存関係構築の際にプロトコルを利用するのもPOPの型の抽象化が目的です。  

より具体的にいうと以下3点になると思います。  
プロトコルによって型を抽象化する目的
1. 実体型を差し替えて実装を変更したい
2. テストを行いたい
3. 多義的な役割を担わせたい

このうち1と2は技術的には同義です。  
差し替えるコンポーネントが本番用なら1でテスト用なら2になるわけですが、これは技術的には同義でも開発的には全く異なる役割になるので分けました。  
そして本記事で紹介したプロトコルの利用方法も1と2でした。  
プロトコルという抽象型を利用して依存関係を構築するので実体型に依存していないため層の関心は分離され、またテストも容易になります。  
このようにプロトコルを利用する目的のうち1と2は既に本記事内で触れましたが3については登場していません。  
3は「多義的な役割を担わせたい」と少し難しそうに聞こえますがプログラミングでよく聞くポリモーフィズムを指しています。  
つまり3は犬、猫、鳥等の動物を表す複数の異なる実体型を動物(Animal)型と一つの型として利用したい時を意味していて、1と2とは性質が異なります。

### 依存関係でプロトコルを利用しない場合
逆にいうと上記に該当しない依存関係ではプロトコルを利用しない方が良いです。  
一般的に言えばApplication層のデータオブジェクトやDomain層のデータ・ロジックオブジェクトではプロトコルを利用しないケースが多いと思います。  
なぜならこれらApplicaton・Domain層はアプリケーションサービスのコアだからです。  
クリーンアーキテクチャの依存関係におけるプロトコルの目的の一つは状況の変化に柔軟に対応できるよう型を抽象化してコンポーネントの差し替えを可能にすることです。  
そのためアプリケーションのコアであるApplicaton・Domain層のオブジェクトまでプロトコルを使って抽象化する必要は基本的にはありません。(一部UseCaseなど外側の層から利用されるコンポーネントではプロトコルを利用します。)    
またApplicaton・Domain層以外でもその層の中だけで利用されるオブジェクトはプロトコルを利用しない場合が多いです。  

ただ上記のようなケースでも先程の3の性質が必要な場合はプロトコルを利用します。  
例えばアプリで写真を表すPhoto型(値型)があるとすると、特別な仕様がない限りプログラムではこのPhoto型を利用する際は実体型であるPhoto型を直接利用します。  
コード例
しかしもし仮にこのアプリに特定のPhotoをグルーピングしたAlbum型があり、アプリケーションの仕様上Photo型もAlbum型もユーザーに提示する一つのアイテムとして同様に扱いたい場合があるとします。  
その場合はプロトコルを利用してAlbum型とPhoto型を抽象型として扱う必要があります。
以下コード例


本記事内で書いた通り層を跨いだ依存関係では基本的にコンポーネントを差し替え可能にすることで恩恵を得られるので積極的に使って行くべきです。  
しかしそれはここで書いた通り全ての依存関係でプロトコルを使うことを推奨しているわけではありません。 
依存関係


## Repository
ここではRepositoryに関していくつか説明します。  
### Repositoryのプロトコル(インターフェース)はDomain層、実体型はData層
タイトルの通りですが、レイヤードアーキテクチャのようにクリーンアーキテクチャのInterface Adapters層のような層が存在しない場合Repositoryのプロトコル(インターフェース)はDomain層、実体型は基本的にData層です。  
RepositoryはDomainオブジェクトの操作をするコンポーネントですが、実際技術的にどのようにDomainオブジェクトを操作しているかは内部実装としてわからないようにしています。  
そのため定義上RepositoryはただDomainオブジェクトが操作できることだけ宣言してあり、RepositoryのプロトコルはDomainに属することになります。　　
それに対して実体型のRepositoryはWebAPIやデータベース等Data層のコンポーネントを利用しながら実装しているためData層に分類されます。  

### Repositoryとデータクライアントの出力で異なる場合があるのか
記事内の[Repositoryの設計に関する誤解](#Data層にDomain層の事情を持ち込むことでData層が肥大化する)を説明した箇所で、
>対応するリポジトリとデータクライアントの出力する値は必ずしも同じではない
と書きましたが、なぜこのようなことが起こるのでしょうか?
ここではそれについて説明します。  
その理由は詰まるところDomainとデータベースで設計が異なるということだと思います。  
Domain層のオブジェクトの設計の際、私たちが考えるべきことは純粋にそのサービスの視点からデータをどのような単位で扱いまたそれらをどのように繋げるかということです。  
それに対してデータベースではサービス的なことも考えながらパフォーマンス等データベース特有の事情も考えながら設計します。  
このようにDomainとデータベースでは互いに設計の基準が異なるため、結果的にDomainオブジェクトとデータベースのエンティティの単位も異なってしまいます。 
リポジトリとデータクライアントの出力する値が異なる場合があるのも同じ理由です。  
リポジトリとデータクライアントでは設計の視点が異なるため必ずしも出力が一対一で対応していることにはならず、場合によっては一つのDomainオブジェクトを取得するために複数のWebAPIを利用する必要が出てきます。  

### RepositoryとDAO
ここではRepositoryと良く似ているDAOの説明とRepositoryとDAOがどのような関係なのかを説明します。  
DAOとはData Access Object略であり、技術的な詳細は内部実装として隠蔽しながらデータを操作を行うコンポーネントを指します。  
これはData層の実装を隠蔽しながらDomainオブジェクトを操作するRepositoryと同じように見えますし、実際詳細を隠蔽しながらデータを操作するコンポーネントという意味では同じです。  
しかし設計の観点から考えるとこの2つは大きく異なります。  
簡単に言えばRepositoryはData層を意識せずDomainオブジェクトの操作を行うためのコンポーネントであるのに対して、DAOはただその詳細を隠蔽しながらデータ操作を行うコンポーネントでありDomain層やData層などは意識されていません。  
違う言い方をすればRepositoryはアーキテクチャ設計の視点から生まれたコンポーネントであるのに対して、DAOはよりミクロなデザインパターンの視点から生まれたコンポーネントであると言えます。  
このようにDAOが操作するデータはDomainオブジェクト以外にもありえるため設計によってはRepository内でDAOを利用すると言ったケースもあり得ます。  
実際にAndroidの公式ドキュメントではRepository内でDAOを使っています。  
RepositoryとDAOを併用する場合はDomainオブジェクトの操作はRepository、その他雑多なデータの操作はDAOという感じになると思います。  
ちなみにDAOをクリーンアーキテクチャで利用した場合、DAOはData層ではなくInterface Adapters層ということになるでしょう。  
その理由はRepositoryに関する誤解でデータクライアントに独自に定義した型を出力させなかった理由と同じです。  
DAOで操作するのがDomainオブジェクトでないにせよ、それで操作するデータ型が独自で定義したものである以上そのデータ型はそのサービス特有の型であるということです。  
そしてData層はそのサービス特有のデータからは切り離されているべきあるためDAOはあくまでData層ではなくInterface Adapters層一部ということになります。  

<a name="footnote1">*1</a>: この項の始めにあるFramework&Driversが外部技術であるという箇所と外部技術に依存しているという表現は矛盾しているような表現ですが、視点が異なっているだけです。  UIKitを例に出すとUIKitは内部でApple独自のレンダリング技術を使っているため外部技術に依存しているわけですが、他の層から見るとまさにそのUIKit自身が外部技術なわけです。

<a name="footnote2">*2</a>: ここでいう利用するとは実際にインスタンスを参照しているという意味であり、プロトコルに準拠していることは指していません。本来は括弧内で書いているように上位、下位と
表現することで十分だと思いますが、個人的にこれらの表現は淡白な割にどちらを上と見るかは捉え方次第で変わってしまうためあまり好きではなく利用する側、される側という表現しています。(ただ冒頭で説明したとり「利用する」とはなんであるのかも自明ではないため最適な表現ではなさそうですが...)


リポジトリとデータクライアントクラスの関係については補論RepositoryとDAOでもう少し詳しく取り上げました。  

