
# iOSアプリでスケールしやすいアーキテクチャを考えてみた②-設計を理解するためのクリーンアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)**設計を理解するためのクリーンアーキテクチャ編←本記事**  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への準備編として設計の概観を理解するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  
また本記事はレイヤードアーキテクチャの知識を前提としていますので、レイヤードアーキテクチャがわからない方は前の記事から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

### 記事内の用語の表記ルール 
#### アーキテクチャと設計
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの言葉の定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるもの  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっていることが多いと思うのでこの記事では上のように区別することとします。  
#### 各層の表記
記事内でアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。    
例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logic(層)と表記します。  
InfrastructureはInfraと省略して表記し、Infra層のうちデータ操作に関するものをData(層)、端末機能に関するものをDevice(層)と表現する場合があります。  


## 前回までの内容と本記事の内容
初回である前回の記事ではスケールしやすいアーキテクチャを考えるためにクリーンアーキテクチャを通して設計を理解することを最初の目的としました。  
そしてその準備としてクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャの理解を深めたのが前回までの内容です。

本記事ではいよいよクリーンアーキテクチャを学び、設計についてまとめたいと思います。

## クリーンアーキテクチャとレイヤードアーキテクチャの共通点/相違点
最初に前回学んだレイヤードアーキテクチャと今回学ぶクリーンアーキテクチャの共通点、そして相違点について整理することでクリーンアーキテクチャを理解するために必要なポイントをまとめます。   
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>


前回の記事でレイヤードアーキテクチャの特徴が**責務による層の分割と単一方向の依存関係による関心の分離**であることを述べました。  
クリーンアーキテクチャでもそれは変わりません。    
円の中の一つ一つの色が層を示していて、また円内側の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格はつかめているといえます。  
ただクリーンアーキテクチャではその詳細が異なります。  
なのでクリーンアーキテクチャを理解するためにその層の分割と依存関係の詳細を見ていきたいと思うのですが、これらを理解することはクリーンアーキテクチャが円である理由を理解することと同じです。  
そのため最初にクリーンアーキテクチャが円である理由を踏まえながら円の各層・依存関係について説明していきたいと思います。  

## Entities == Domain層 && Use Cases == Application層
最初にクリーンアーキテクチャが円である理由を見ていきますが、その前に前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所があるので説明します。    
結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層であり、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層と同じです。     
円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」です。  
前回の記事でDomainとは「事業の知識・ルール」を意味していることを書きましたが、ここからEntitiesがDomainと同じであることがわかると思います。    
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesに書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要でしょう。

以後EntitiesではDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため

クリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか？  
実はその答えはレイヤードアーキテクチャの記事ですでに書いています。  
レイヤードアーキテクチャの記事のPresentation Domain Separation(以下PDSと表記)の説明でビジネスロジックを「アプリケーションプログラムの機能的中心」と表現しましたが、まさにこれがBusiness LogicであるDomainとApplicationが円の中心にある理由です。  

### Business Logicを円の中心に置く3つの理由
その理由をもう少し具体的に示すと以下のようになります。  

1. サービスのアイディアを具体化したものがBusiness Logicのデータ・ロジックであり、Business Logicなしではアプリケーションは成立しない   
2. Business LogicはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. Business Logicは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

以下ではそれぞれの詳細について説明します。  
#### 1.ビジネスはアイディアから
Business Logicを円の中心に置く理由として3つ挙げましたが他の2つは副次的なものであり、これこそがクリーンアーキテクチャの中心にBusiness Logicを置く理由です。  
「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、プログラム化したものがDomain層であり、さらにそれをアプリケーションとして提供するために書かれたプログラムがApplication層です。  
UI層はそのサービスをユーザーへ提供する窓口として存在しInfra層はそのサービスの実現のための手段として必要であって、アプリケーションは必ずBusiness Logicから生まれます。      

#### 2.Business Logicは相対的に変更されづらい層
またそれはBusiness Logicがアプリケーションの中で相対的に変わりづらい箇所であることも意味しています。(ここでいう「変更」はアプリケーションの仕様変更や機能的に要求によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。)  
UIやInfraはBusiness Logicが変わることがなくてもUXや技術的なパフォーマンスの観点から変更することがあります。  
それに対してサービスの仕様が変更された場合はBusiness Logicは変更されますが、それに応じて必ずUIやInfraも変更を迫られることになります。  
このようにBusiness Logicはアプリケーションの機能的中心でサービスそのものであるため、Business Logicの定義が変わる場合はそれに応じて他の層も変更する必要があります。  

#### 3.外部技術に依存していない
これはどちらかというと「Business Logicが円の中心である理由」というよりも「Business Logicが他の層から切り離される理由」といった方が良いかもしれません。   
ただBusiness Logicが純粋なプログラミング言語の定義によってのみ構成されて外部技術に依存しないのは、結局そのサービスの核心であるため外部技術に依存していないという話につながりますし、この「外部技術に依存していない」という側面は円図を説明する上で重要な要素であるため理由の一つに加えました。       


### クリーンアーキテクチャは現実の開発状況をより反映させている
そしてこうしたDomainとApplicationを中心に据えたクリーンアーキテクチャはレイヤードアーキテクチャと比べてより現実を反映させた設計であると言えます。  

レイヤードアーキテクチャでは技術的な側面から依存関係を決定したため、技術的な基盤となるInfraをアプリケーションの支えとして捉え「UI->Application->Domain->Infra」という関係でした。  
それに対してクリーンアーキテクチャはアプリケーションの機能的中心であるBusiness Logicがアプリケーションを支えていると捉え、他の層がBusiness Logicに依存しています。  
クリーンアーキテクチャのこの構造は現実のアプリケーション開発の実態をより正確に捉えています。  
アプリケーションは技術的にはインフラに依存していますが、サービス的に依存しているのはビジネスロジックであり開発はビジネスロジックを起点に動きます。  
そのためビジネスロジックを中心として他の層と切り離すことで、実務で発生する要件に柔軟かつ迅速に対応することが可能になるのです。  
私たちの日々の業務でも技術的にはインフラであるインターネットに依存しつつもその活動はビジネス的な事柄に依存していますが、それと同じです。  

図
このようにクリーンアーキテクチャは技術的には(レイヤードアーキテクチャでは)4層の中間に位置するBusiness Logicをアプリケーションの基盤と捉えたアプリケーション設計であり、それを
図で示すために円の形となっています。  

## Framework & Drivers層とInterface Adapter層
クリーンアーキテクチャがなぜ円なのかについて理解できたところで、まだ説明されていないFrame & Drivers層とInterface Adapter層について説明していきます。  
### Framework & Drivers層
まずFrame & Drivers層から説明します。  

Framework&Driversの意味はFrameworksはフレームワーク、つまりiOSのUIKit等パッケージ化された外部技術、DriversはIT用語でシステムに装着する外部装置を意味しておりこの層はビジネスロジックをアプリケーションプロダクトとして完成させるために必要な外部技術群と指していると言えます。  
円を見てみるとこの層にはUI/Web/DataBase/Devices/External Interfacesとさまざまなものが表記されており、レイヤードアーキテクチャのUI、Infraそしてフレームワーク等がここに含まれています。  
ここではレイヤードアーキテクチャで異なる層であったUIとInfraが一つの層とされているわけですが、私たちは既に同様のケースを前回の記事でも見ています。  
PDS(以下)のPresentationです。  
PDSのPresentationにはUIのみならずInfraも含まれることを前回の記事で説明しましたが、クリーンアーキテクチャでも同様に同じ層として扱っているのはこの2つが以下の共通点を持っているためです。  
- 仕様の変更によってプログラムが変化しやすい
- 外部技術に依存している<sup>[*1](#footnote1)</sup>

こうした特徴を持った層に他の層が依存していると、変更による影響が依存している他の層にも広がってしまい柔軟な開発を行うことが難しくなります。  
そのためクリーンアーキテクチャではこれらの特徴を持ったUI/Infra層が他の層から依存されないように同じ最外層に置いているのです。

### クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない
これはこのあとのInterface Adapters層にも言えることですが、クリーンアーキテクチャの層がアプリケーションのディレクトリ構造になることは滅多にありません。    
Framework&Drivers層のUIとInfraは実際のアプリケーション開発では区別されることが多いですし、またInterface Adapters層でもPresenter等UI側のコンポーネントとRepository等Infra側のコンポーネントは区別されます。  
その理由はクリーンアーキテクチャの層の構成がディレクトリ構造の目的と合致していないからです。  
ディレクトリ構造ではそのディレクトリにどのような責務のプログラムが置かれているかを具体的に示す必要がありますが、クリーンアーキテクチャではよりメタ視点から層を捉えています。  
例えばFramework&Drivers層はBusinessLogicに対する外部プログラムであることを意味しているだけであり、UIやInfra等のように具体的にどのような責務を担っているのか示しているわけではありません。     
そのためアプリケーションのディレクトリ構造はレイヤードアーキテクチャの責務分割に沿って成り立っていることが多いです。    
このようなところからクリーンアーキテクチャとレイヤードアーキテクチャでは層を捉える視点の次元が異なることがわかります。  

図

### Interface Adapters層

さて、残る一つはInterface Adaptersです。  
Interface Adapterという言葉だけ聞くとなにやら難しく感じてしまうのですが、簡単にいえばこの層は内側のBusiness Logicと外側のFramework&Drivers層を繋ぐための仲介役を担う層です。  

円図ではこの層に該当するコンポーネントとしてController/Presenter/Gateway等が書かれていますが、基本的にこれらのうちControllerとPresenterがUIとビジネスロジックの、GatewayがBusiness LogicとInfraの仲介役を担っています。  
iOSMVCのControllerに当たるViewControllerもここに属し、円図でいうController/Presenterを担っています。  
図

#### MVCのControllerと円図にあるControllerは異なる
ややこしいのですが、MVCアーキテクチャの文脈でいうControllerと円図に書いてあるControllerは意味が異なります。  
私たちにとってはControllerというと画面の入出力処理を担うMVCアーキテクチャのControllerが馴染み深いと思いますが、ITにおける一般的なControllerは入力のみに関する処理装置を意味していて出力に関する意味は含まれていません。  
これはMVPのPresenterにも同じことが言えて、Presenterは一般的には出力のみに関する処理装置を指しておりMVPのPresenterは円図でいうControllerとPresenterの両方の責務を担っていることになります。  

#### Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる
このInterface Adapters層が担う層の仲介という責務はレイヤードアーキテクチャでは存在していませんでしたが、実際に開発で実践してみるとこの層の重要性に気づきます。  
層同士が連携して責務が混ざり合った箇所を一つの独立した層として捉えることで各層責務の純度が格段に上がるのです。  
  
レイヤードアーキテクチャの層はアプリケーションを機能によってわかりやすく分割していますが、それはあくまで理論上の話であって実際のアプリケーションでは各層が連携して一つのアプリケーションとして動作するため複数の層の責務が交わり境界が曖昧な処理が発生します。  
例えばDomain層ではビジネス的な事柄が関心の対象なので、永続化機構でデータを更新するためのURLやそのためのデータ形式の変換に関心を向けるべきではありません。  
ただ一方でInfra層ではデータを永続化するという汎用的な責務を担ってはいるものの、特定のURLやそれに関する処理はそのアプリケーション(ドメイン)固有なものなのでInfra層がその責務を負うのはおかしなことです。  
このようにレイヤードアーキテクチャによる層の分割を実践しようとするとその層の境界でどっちつかずな責務が発生してしまい、このような責務は妥協の末に基本的に利用する側(上の例ではDomainがInfraを利用するのでDomain層)に実装されるようになります。  

この問題を解決するためにクリーンアーキテクチャではレイヤードアーキテクチャの層が連携する責務も一つの独立した層として捉えました。  
こうすることで円の内側のビジネスロジックと外側のFramework & Drivers層に不純な責務を含める必要がなくなり、各層の責務の純度を高く保つことができます。   

図

#### RepositoryもInterface Adapters層
ちなみに円図では表記されていませんが、開発でよく耳にするRepositoryもこのInterface Adapters層に入ります。  
Marin Flower氏の定義を引用するとRepositoryはDomain層とData層の仲介役です。(引用文のdata mapping layersはData層を指しています。)  
>A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection  
>
>意訳
>RepositoryはDomainとData層の中立ちをし、インメモリなドメインオブジェクトコレクションのように振る舞います
円図でいうとGatewaysの中に含まれていると考えればよいと思います。   

#### Gatewayとは異なる層の中継役という意味
Gatewayという名前はクラス名としてはあまり聞き慣れないと思いますが、ネットワークの文脈では異なる層の中継役を担う装置を指しており、クリーンアーキテクチャでも同様の意味を持っています。    
私はInterfaceAdapter層のコンポーネント名を命名するとき、できる限り~Repository等より具体的な名前を使うようにしていますが適切な名前が見つからない時はGatewayの名前を使っています。    
Gatewayは広範囲を示す名前ではありますが、プロジェクト内で乱用されるような名前ではなくそれだけでInterface Adapter層のコンポーネントだと伝わると思うので「~Managerクラス」や「~Serviceクラス」等より責務が明確で便利な単語だと思います。  

## クリーンアーキテクチャの依存ルール
クリーンアーキテクチャでの依存は外側の層から内側の層へという方向であること、また外側の層の仕様は変わりやすく内側の層の仕様は変わりづらいことを説明しました。  
つまりクリーンアーキテクチャの依存は変更されやすい外側の層から変更されにくい内側の層へ向いており、こうすることで外側の層の変更のされやすさがアプリケーションへ影響することを最小限に抑えています。  
ただ技術的に依存しているのはInfra層のはずなのに、Infra層がビジネスロジックに依存するということはどういうことなのでしょうか？  
これについてはこの後クリーンアーキテクチャのルールを守るためのテクニックという節で説明します。  

## クリーンアーキテクチャの概要を一度整理する 
ここまででクリーンアーキテクチャの特徴に一通り触れました。  
しかしレイヤードアーキテクチャの理解を前提として話を進めたため、クリーンアーキテクチャの基本的な説明をあまりしていません。        
そのためこれまでの内容と重複する部分もありますが、ここで一度クリーンアーキテクチャの原文に沿った形でその概要を整理したいと思います。  

## クリーンアーキテクチャの特徴   
クリーンアーキテクチャの記事の冒頭では、ヘキサゴナルアーキテクチャ・オニオンアーキテクチャなどのシステムアーキテクチャを紹介しています。  
システムアーキテクチャの意味は私も正確に理解しているわけではないのですが、恐らくアプリケーションの特定の領域にこだわらずシステム全体を関心の対象としているアーキテクチャという理解で大丈夫だと思います。     
クリーンアーキテクチャ原文ではそれらシステムアーキテクチャの特徴として以下の共通点があると述べています。    

1. 関心の分離  
どのシステムアーキテクチャも関心の分離を基本として、少なくともBusiness Logicとその他の2層に分けようしている  
2. UI/WebAPI/データベース/フレームワークといった外部技術が独立している  
アプリケーションのうち変更されやすいUI/Web API/データベース/フレームワーク等のコードにどこからも依存しない  
このような外部技術は便利なものの、同時に開発時の制約も発生するためこれらに依存しないようにすることで柔軟な開発が可能になる  
3. テストしやすい  
Business Logicも特定の外部技術に依存していないためテストが容易になる  
またのちに見るように層の依存関係をclassなどの実体型で実現するのではなく、プロトコルを利用した抽象型によって実現することでビジネスロジック以外の層でもテストがやりやすい  

そしてクリーンアーキテクチャの円図はこうした特徴を視覚的にまとめたものです。  

### クリーンアーキテクチャの層は4つである必要はない
クリーンアーキテクチャはDomain/Applicatoin/Interface Adapters/Framework&Driversという4つの層からなっていると説明しましたが、原文には必要であればもっと層を増やしても構わないと書かれています。  
ただ該当箇所の小見出しには「Only Four Circles?(4つの層だけ?)」と書かれており、基本的に4つの層より多くなることはあっても4つの層より少なくなるようなことはないという考えのようです。   
私も責務の分離を目的とするなら少なくともBusiness Logic/Interface Adapters/Framework&Driversの3層は必要だと考えていますし、Business Logicも設計者が層の分割を意識してるかどうかは別としてその中で責務をしっかり分けていくと実質的にはDomain/Applicationの分離が生まれてくると思うのでこの4層を基本として、必要であればそれ以上に層を分けるというスタンスで良いと思っています。    

## クリーンアーキテクチャで守るべきルール  
クリーンアーキテクチャの特徴を保つためには開発者が守らなければいけないルールがあります。  
それは大きく言って以下3点です。  

### ルール1: 円の内側の層は外側の層については知らない何も知らないし、影響も受けない
Business Logicは外側の層について何も知らなくても独立して動作できるようになっている必要があります。  
それはBusiness Logic内のDomain層とApplication層に関しても同様で、内側の層であるDomainは外側のApplicationについて知っているべきではありません。  
クリーンアーキテクチャではアプリケーションとして動作するために各層は連携しつつも可能な限り関心を分離することを目的としているため、依存して良いのは外側の層から内側の層へのみとなっています。  

#### しかしInterface Adapters層は例外
ただこのうちInterface Adaptersは少し例外といえます。   
既に説明した通りInterface Adaptersは内側と外側の層の中継役となる層なので直接的ではなくても外側の層の事情を知ることになるからです。  
具体的に説明すると、UI側のInterface Adapters層はUIの仕様変更によって自身の入力・出力の処理も変更することになるので直接UIを知らなくても間接的にその仕様について知っていることになりますし、Infra側のInterface Adapters層も実体型としてデータベースやWebAPIを参照していなくともメソッド名やその引数から参照先がデータベースかWebAPIか等外側の層の事情はある程度把握できます。
またデータベースからWebAPIへの移行等Infra側の機構を変更した場合には、基本的にそれに関連するInterfaceAdapters層も変更が必要になります。  
  
原文の記事でも冒頭で  
>Nothing in an inner circle can know anything at all about something in an outer circle.  
>
>意訳  
>内側の層は外側の層について全く知らないこと。  

と強調しながらも、Interface Adapter層の説明でSQLデータベースを例に出しながらInterface Adapter層で外側の層を知っていることは致し方ないことだと書いています。(ただ同時に外側の層がInterface Adapter層に与える影響は必要最低限に留めることも強調しています。)
>If the database is a SQL database, then all the SQL should be restricted to this layer, and in particular to the parts of this layer that have to do with the database.
>
>意訳  
>もしデータベースがSQLならば、SQLに関するコードはInterface Adapter層の内データベースと関与する箇所のみにとどめるべきである。  

### ルール2:層をまたぐオブジェクトはシンプルなデータ構造であること
層同士で連携してオブジェクトの受け渡しを行う際には層の責務が漏出してしまう危険性があります。  
アプリケーションとして動くためには層間の連携は避けられませんが、ある層のオブジェクトが他の層に渡されることでそのオブジェクトが属する層以外で利用されることになるからです。  
クリーンアーキテクチャではこうした状況でも関心の分離を保つために、層をまたぐオブジェクトはシンプルなデータ構造であるであるべきだとしています。    

もし層をまたぐオブジェクトが複雑な処理のメソッドを持っていた場合、またいだ先の層でもそのメソッドの呼び出しが可能であるためそのメソッドを通して複雑な処理が行われて責務が他の層へ漏出していってしまう恐れがあります。  
こうした場合受け渡し元の層からメソッドを持ったオブジェクトが受け渡し先でどのように利用されるのか想定しきれないため、開発における不確実性が高まりバグの温床となります。

図
　　
それに対してこの層をまたぐオブジェクトがメソッドを持たないデータ構造である場合は、他の層ではそのデータ操作のみ可能となるため渡す側の層はそのオブジェクトが他の層へ与える影響を制御可能です。  

このように層をまたぐオブジェクトをシンプルなデータ構造にすることによって、層の責務の漏出は必要最低限かつ予測可能なものとなり関心の分離は高い水準に保たれます。 

図

ちなみにここでいうメソッドを持ったオブジェクトとは層の責務の漏出につながるようなメソッドを持っているものを指しています。  
例えばSwiftのArrayはメソッドを持っていますが、それらのメソッドは自身の操作に関するものが中心でそこから層の責務が漏出してしまう恐れはないので層の受け渡しで利用しても問題ありません。  

他にもこの場合におけるシンプルなデータ構造とは何を意味しているのかについてもう少し掘り下げたい点があるため、記事の最後に補論として取り上げました。  

### ルール3：データフローは一方向
これはクリーンアーキテクチャの原文に明言されているわけではないのですが、開発時には自然と守るようにしますし、またクリーンアーキテクチャに限らず設計において重要であるためルールとして加えました。  

アプリケーションのデータフローを円図に沿ってたどっていくと、入力は円の外側のUIから起こり、その処理のため内側のBusiness Logicに入りそして再びその結果は出力先であるUIに向かうため円の外->内->外と流れていて一見すると一方向になっていないように思えます。  
しかしそれはあの円がデータフローではなく依存関係に着目して作られているからであって実際のところデータフローも一方向となっています。
それを示すのがクリーンアーキテクチャの右下の図です。(実際には依存関係も示した図なのですがここではデータフローについてのみ触れます)    

図が表しているようにデータフローはContrller->UseCase(Applciation)->Presenterとなっており、これらは円図で見ると外->内->外ではありますが実際には最初に外から内へ入る時と、そのあと内から外へ出ていく時の経路が異なるため実質的にデータのフローは一方向となっているのです。  

これはMVCのControllerやMVPのPresenter等、一つのコンポーネントが画面の入出力を担当している場合も同じです。  
これらのコンポーネントでは一つの中に入出力の責務がありながらも、実際のコード上では入力と出力の責務が交わらないように設計されていることが前提となっています。 

以下イメージ図


## ルールを守るためのテクニック
クリーンアーキテクチャについていろいろと見てきましたが、最重要ルールと言える「円の内側が外側についてなにも知らない」を守りながらアプリケーションをどう実現するのかについてまだ触れていません。    
アプリケーションは技術的にInfraに依存しているはずなので円の内から外への依存がないのは不可解なことのように思えます。  
ここではこの問題をどう解決すればよいか説明していきます。  

### 依存関係逆転の原則(Dependency Inversion Principle)
これには依存関係逆転の原則(Dependency Inversion Principle)というテクニックを利用します。    
「依存関係逆転」と聞くと難しそうに聞こえるのですが、要はあるコンポーネントに依存するとき実体型ではなく抽象型(Swiftでいうプロトコル)に依存するというだけのことです。  
なぜプロトコルに依存することで層の外側から内側の依存のみになるのかというと、実体型による依存関係では利用する側(上位)の層から利用される側(下位)の層への依存となりますが<sup>[*2](#footnote2)</sup>、プロトコルを利用した依存関係の場合はそのプロトコルは利用される側の層ではなく利用する側の層に属していると考えられるからです。  
そうすると利用するコンポーネントも利用されるコンポーネントも利用する側の層にあるプロトコル依存しているため依存方向が逆転しています。  

もう少しわかりやすく説明するために以下で簡単な例を示します。  
### 依存関係逆転の例
クラスAがクラスBを利用しているとします。  
その場合それらの依存関係はA->Bとなり利用する側のAが利用される側のBに依存しています。  
図
ここでこれらに依存関係逆転の原則を適用するためクラスBの要件を満たした「BType」というプロトコルを定義し、クラスAはBクラスを直接利用するのではなくBTypeプロトコルを利用するようにします。  
この時BTypeプロトコルはBクラスの要件を全て満たしているのでAクラスはBクラスを利用していた時と同じようにBTypeプロトコルを利用できます。  
またクラスBはBTypeプロトコルに準拠するようにします。(堅苦しいですが、Swiftではある実体型にプロトコルを適用する場合「プロトコルに準拠する」とよく表現します。)  
そうなるとクラスAはBTypeプロトコルを利用しBクラスもBTypeプロトコルに準拠するため、先程のA->Bで表していた依存関係はA->BType<-Bに変化していることがわかります。(ここではプロトコルに準拠することも一種の依存であるとします)  
そしてBTypeプロトコルは利用する側であるクラスAの層に属していると捉えられているため、先ほどは利用する側から利用される側へ(A->B)の依存であった関係がプログラミング的には利用される側から利用する側への依存に逆転したことになります。  
図
これがプロトコルを利用した依存関係の構築が「依存関係逆転」と言われている理由であり、クリーンアーキテクチャではこの原則を用いて層の内から外への依存を行わないようにします。  

### プロトコルを利用することでプログラムの変更を行いやすくなる
プロトコルを利用した依存が「依存関係の逆転」と言われているから内から外の依存はないというのはただの概念的な操作であって、レトリックにしかすぎないと思う人もいるかもしれません。  
ただここでもう一度思い返して欲しいのですが、クリーンアーキテクチャで外から内への依存のみ許している理由は以下の二つです。  
- Business Logicを外側の層から切り離す
- テストを容易にする

実体型を利用した依存関係では満たすことはできない上記の要件をプロトコルを利用することによってしっかり満たすことができるようになっています。  
Infra側ではInterface Adapters層のコンポーネントが利用するのは実体型としてのInfraクラスではなくInfraの要件を満たしたプロトコルであるため、Infraそのものに依存することはなくなり実際のInfraクラスが完成していなくともプロトコルに準拠した仮コンポーネントを使ってテスト可能になります。  
UIでも同様にデザインやUIプログラムが完成していなくともコンソールなどに出力して値が正しいか確認できます。  

### 依存の方向関係なくプロトコルは積極的に利用する
内から外への依存を行いたいときのテクニックとして依存関係逆転の原則を紹介しましたが、実際には外から内への依存でも積極的にプロトコルを利用することをオススメします。  
例えばUIのテストを行いたいときなど、出力値が正しいかどうかではなく出力値を表示するレイアウトが正しいか確認したいといった場合があります。    
こうした場合にはUIからViewModelやPreseterなどの実体型に依存することなくプロトコルに依存することで仮コンポーネントを利用してテストが可能になります。  
  
このように依存の方向関係なくプロトコルを利用した依存関係を構築するとテストが行いやすくなるため積極的に使っていくことをオススメします。  
  
他にも依存とプロトコルについてはいくつか書きたいことがあったので記事最後にSwiftのプロトコルという補論を書いています。  

### 内から外へのデータフローを実現する他の方法
円の内側が外側の仕様を知らずに処理する他の方法としてクロージャを完了時の処理(completion handler)として利用する方法等があります。
しかしcompletion handlerで内から外の依存を解決可能なのはUI等外側の層から処理の呼び出しを行う場合のみであって、Application/Domain層からInfra側への呼び出し等内から外へ処理を呼び出す場合はcompletion handlerを利用したとしてもどちらにせよプロトコルを利用する必要があります。  

コード例

## クリーンアーキテクチャにある誤解
ネット上でiOSにおけるクリーンアーキテクチャを調べると大きく2点ほど誤解されている箇所があるように思います。  
クリーンアーキテクチャの説明の最後にそれらについて説明します。    

### 1. Entityに関する誤解
  
#### EntityはDomain層
ネットで調べているとEntityがData層であるというような内容の記事がありますが、クリーンアーキテクチャにおけるEntityはData層ではなくDomain層です。  
EntityをData層としてしまうとあの円図の中心はData層ということになり、ビジネスロジックを他から切り離すという目的から外れてしまいます。      
そうなると各層の質的な連続性、クリーンアーキテクチャの主張の論理的な一貫性が失われてしまうためクリーンアーキテクチャが何を意味しているのかわからなくなってしまうでしょう。      

恐らくEntityをData層とする主張はデータベースの文脈におけるエンティティと混同しているのだと思います。  
データベースの文脈ではエンティティはデータベース上で操作するデータのまとまりを指し、恐らくこの用法がプログラミングの世界で一番広く浸透しています。    
ただ先ほどもいった通りEntityをData層と解釈してしまうと、クリーンアーキテクチャの主張と根本的に矛盾してしまうため注意が必要です。  

#### Entityはビジネスルール
そしてEntityに関してはもう一つ誤解があります。  
Entityは単純なデータ型として紹介されていることがありますが、そうではなくビジネスルールを指しておりロジックを含んでいます。  
これはクリーンアーキテクチャのEntityの定義を見ればわかると思います。  
>Entities encapsulate Enterprise wide business rules.   
>An entity can be an object with methods, or it can be a set of data structures and functions.  
>  
>意訳  
>エンティティは事業のビジネスルールである。  
>エンティティはメソッドをもったオブジェクト、もしくはデータ構造と関数の集まりである。  

このようにクリーンアーキテクチャにおけるEntityはロジックを含んだビジネスルールをカプセル化したものです。  

こちらは先ほどのEntityをData層とする誤解ほど大きな影響はないですが、その原因は非常に複雑なように思います。      
既にクリーンアーキテクチャのEntityがなんであるかは説明できたので詳細は省きますが、クリーンアーキテクチャにおけるEntityは先程のデータベースの文脈におけるEntityに加え、ドメイン駆動開発におけるEntityともVIPERアーキテクチャのEntityとも異なるからです。  
特にクリーンアーキテクチャをiOSの開発環境で実践しやすいように最適化したVIPERアーキテクチャのEntityとクリーンアーキテクチャのEntityで意味が異なるのは誤解しやすいなと感じます。(ちなみにVIPERの
エンティティもData層ではないことは強調されており、それはクリーンアーキテクチャのEntityと同じです。)  


### 2. Interface Adapter層の誤解
次にInterface Adapter層関しての誤解を説明します。  
### Business Logic層のデータをUI層のデータ形式へ変換するのはUI側のInterface Adapters層の責務
最初にクリーンアーキテクチャにおいてApplication層であるUseCase内でTranslatorというデータ変換用のコンポーネントを利用してUI用のデータ形式に変換するという内容の記事がいくつかありますが、これは誤りだと思います。      
既に[本文](#Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる)でも説明しましたが、Applicationのデータ形式をUIのデータ形式に変換するのはInterface Adapters層の責務だからです。    

Interface Adapter層の役割を原文に沿いながら再度説明します。  
原文のInterface Adapter層の説明では
>The software in this layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency  
>  
>意訳
>この層(Interface Adapter)はApplication層もしくはDomain層のデータを最外層に最適な形式に変換することである。
  
またそのすぐ後の説明で  
>Also in this layer is any other adapter necessary to convert data from some external form to the internal form used by the use cases and entities  
>
>意訳  
>またこの層(Interface Adapter)では最外層のデータを内側のApplication層やDomain層に最適な形式に変換する。　　

と書かれており、その方向にかかわらず内と外の層の間のデータ形式の変換を役割としていることがわかります。  

クリーンアーキテクチャで異なる層へのデータ変換を行うのはInterface Adapter層の責務でありこの層に閉じ込められているべきです。(見方によればApplication層内でDomain層のデータをApplication層データに変換しているといえますが、Application層でDomainデータを直接扱うことは許容されておりここでの「異なる層へのデータ変換」とは明らかに異質であるためここには含みません。)   


もしUI層へのデータ変換の責務をApplication層であるUseCase(ここでいうTranslatoor)に置いた場合、UseCaseはUIの仕様なしでは定義・実装できないことになりますし、UIの仕様に変更があった場合その影響をUseCaseが受けることになるのでクリーンアーキテクチャの「外側の層の変更の影響を内側の層は受けない」という特徴を失っていることになります。  

### Infra層のデータをDomain/Application層のデータ形式に変換するのはInfra側のInterface Adapters層の責務

#### Data層でカスタムオブジェクトのデータを返すのは誤り
Infra層とBusiness Logic層のデータ変換でもInterface Adapterで変換を行わずにData(Infra)層にあたるコンポーネントがBusiness Logicに適したデータ形式を出力しているケースがあります。  
クリーンアーキテクチャでは外側の層が内側の層の仕様を知っていることは良しとしていますが、それでも必要がなければ関心を切り離すべきですし、ここで指摘しているケースではInfra層がBusiness Logic層の事情を持ち込むことによってコードが冗長化して変更に弱い設計になってしまっています。  

具体例を出して説明していきます。  
  
前置きとして[依存関係逆転](#依存関係逆転の原則(Dependency Inversion Principle))ではプロトコルはそれを利用する側(上位)の層に属すると説明しましたが、それはここでの論旨とは関係なく、またそれを踏まえると説明が冗長になってしまうため、ここではプロトコルもそれに準拠する(利用される)側の層に属することとして話をします。  
  
#### Data層でBusiness Logic層のデータを出力する誤った例
ObjectAというDomain層のオブジェクトをInfraを通して操作するためにObjectARepositoryを定義しているとします。  
私がここで指摘しているケースはObjectARepository内で利用するData層のコンポーネントがObjectAを返しているような設計です。  
コードでいうと以下のようになります。(この例では同期・非同期の話は関係ないので、出力の型は単純にしています。)

Data層側のコード
```
protocol ObjectADataClientType {
   func fetch() -> ObjectA
}

class ObjectADataClient: ObjectADataClientType {

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```

Repository(Interface Adapter)層側のコード
```
protocol ObjectARepositoryType {
   func fetch() -> ObjectA
}

class ObjectADataRepository: ObjectARepositoryType {

   private let dataClient: ObjectADataClientType
   
   init(dataClient: ObjectADataClientType) {
      self.dataClient = dataClient
   }

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```


RepositoryがDomain層のオブジェクトを返り値とするのはInterface Adapterの性質上おかしくないのですが、Data層であるコンポーネントがDomain層のオブジェクトを返すような設計だとData層はBusiness Logicに依存しており、クリーンアーキテクチャの特徴である「Infra層は独立している」を満たせていません。  

またリポジトリとデータクライアントのインターフェースが同じなのでリポジトリでは本来の責務であるデータ変換も行う必要がなく、ただデータクライアントのメソッドを呼び出して自身は何もしていないことになります。   

#### Data層にDomain層の事情を持ち込むことでData層が肥大化する
そして上記ような設計がアプリケーション全体に及んだ場合、Data層が肥大化します。(そもそもDomainオブジェクトと切り離されていないデータアクセス処理をData層と言って良いのかわかりませんが、ここではそういうことで話を進めます。)  
仮にあるアプリケーションでObjectA~Zまでの26のオブジェクトをリポジトリで操作するとします。  
その場合一つ一つのオブジェクトに対して、リポジトリクラス(プロトコル)とデータクライアントクラス(プロトコル)を定義・実装しなければなりません。  
またこれらのオブジェクトのどれかに仕様変更が起こった場合、両方に対して変更を適用しなければなりません。 
これはとても冗長で柔軟性のない設計になってしまっています。  

リポジトリクラスとデータクライアントクラスの出力する値は必ずしも同じではないため、実際のアプリケーションで上記のような構成になるとは限りません。    
ただどちらにしても上記のようにオブジェクトの型毎にデータクライアントクラスを定義しているとData層はBusiness Logicから独立できていませんし、いくつもデータクライアントクラス(もしくはメソッド)を定義する必要があるためコードが冗長になります。  
このような冗長さを回避するためにはData層をDomain層から切り離す必要があります。  


#### Infra層のデータ形式は基本Data型
ではどのように設計したら良いのかという話ですが、この場合Data層が出力するデータ形式は基本的にSwiftのData型(そうでなければIntやString等Swiftのプリミティブ型)であり、Interface AdapterであるRepositoryでData層の出力したData型をドメインオブジェクトの形式に型変換するのが正解だと思います。  

#### Data層のProtocolは集約する
またData層に対応するProtocolは可能な限り集約するべきでしょう。  
ここでいう「集約」とは、例えばData層でWebAPIクライアントを利用する場合にはそのプロトコルは操作するデータ毎に定義するのでなくWebAPIのインターフェースで統一することです。  
Data層の出力をData型にした上でプロトコルをWebAPIのインターフェースに統一するとData層からBusiness Logic層へのデータ変換は本来のInterface Adapters層の責務となります。    
以下がコード例です。(この例でもこちらの意図したい箇所と関係ないので非同期の考慮はなされていませんし、メソッドのパラメーターなども正確ではありません。)

Data層側のコード
```
protocol WebAPIClientType {
   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data
}

class WebAPIClient: ObjectADataClientType {



   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data {
         // 引数で指定されたURLと通信を行いデータを取得する処理
         ...
         return 通信で取得したData
    }
}

```

#### Data層のコンポーネントが独立することで再利用可能になる
上記のような設計でData層がBusiness Logic層から独立すると、Interface Adapters層はData層のクラスを再利用することが可能となり冗長さがなくなります。    

先ほどと比べてData層のコンポーネントの数が大きく減ったのがわかると思います。  
もちろんWebAPIとデータベースなどInfra毎にプロトコルを別に定義する必要がありますが、各Infra機構毎にメソッドのパラメーターなどが異なるのはそれは性質上致し方ないことです。  

Data層ではそのビジネスロジック固有の事情から独立するように設計しましょう。  
そうすることで関心の分離が保たれて、Data層の肥大化が避けられます。  

他にもRepositoryとData層に関してはもう少し取り上げたい内容があったので、補論RepositoryとDAOを記事の最後に書いています。  

## レイヤードアーキテクチャ+クリーンアーキテクチャ+αで設計について考える
前回の記事からレイヤードアーキテクチャとクリーンアーキテクチャを通して設計というものをみてきました。  
ここではそれらと@を踏まえて設計についての考えをまとめたいと思います。  

### 1.設計とは関係性を構築することである
これは前回の記事で説明しました。  
アプリケーション設計とはアプリケーション内の関係を構築することであり、良い設計を考えるとは開発者にとって作業しやすい形でアプリケーション内の関係を構築することになります。  

### 2.責務によって分割し、それらを単純な依存関係により組み合わせる
関係の構築のためレイヤードアーキテクチャではアプリケーションを責務によって層として分割し、それらが単一方向の依存関係になることを定義しました。  
このように責務によって分割しそれらが単純な関係で連携し合うようにすることで、開発者はアプリケーションを特定の目的を持ったプログラムの集合体として捉えることができるため、アプリケーションコードはより具体的になります。    
また責務の分割は関連性の高いコードをまとめて(高凝集)関連性の低い(ない)コードを分離する(疎結合)ので、プログラマは自身が現在担当している責務に関係するコードにだけ集中して開発を行うことができます。(関心の分離)
### 3.データフローは一方向
データフローも開発の重要な要素です。    
データフローが一方向になっていることでプログラムの流れを追いやすくなり、コードの可読性が上がります。  
レイヤードアーキテクチャの記事ではデータフローに関して直接言及しませんでしたが、実際にはレイヤードアーキテクチャも一方向のデータフローを前提としていると思います。  

レイヤードアーキテクチャのデータフローのイメージ
### 4.開発事情を考慮する
この記事ではクリーンアーキテクチャについてみてきましたが、一言でまとめると**クリーンアーキテクチャは実際の開発事情を考慮してレイヤードアーキテクチャを再構築したもの**であると言えると思います。    
レイヤードアーキテクチャでは論理的責務の分割と単一方向依存により「UI->Application->Domain->Infra」(->は依存方向)という関係を構築しましたが、実際の開発はアプリケーション機能、すなわちApplication層とDomain層を起点に動いていくため、それらがInfraに依存しているアプリケーション構造では不都合が生じることがありました。  
クリーンアーキテクチャはこうした開発事情を踏まえアプリケーションコード側でもApplication層とDomain層が中心となるようにレイヤードアーキテクチャの再構築を行なっています。
これによってアプリケーションコードはプロダクトの仕様変更にスピーディーかつ柔軟に対応できるようになりました。  

改めて言葉にすると当たり前ではあるのですが、このように設計を考える際には現実の開発事情を踏まえた上で論理を組み立てることが重要になります。    

### 5.データフローの蓄積による状態変化に考慮する
ここが+@です。  
ここでは+@の内容を明確に言葉にするために経済学のフローとストックという概念を利用します。  
それぞれを簡単に説明すると経済学においてフローは一定期間の経済活動の成果、ストックは過去からのフローの蓄積をある時点で時点で測ったものを示しています。  
どちらも経済事象を示しているのは同じなのですが、フローは特定期間、ストックは過去からの蓄積をある時点で切り取っていてそれぞれの持つ時間次元が異なります。    
具体例を出すと四半期や通年で発表されるGDP等はフロー、国家の借金など過去からの累積額を示しているものはストックです。  

さてこのフローとストックの考え方は設計にも適用できるのですが、そうすると私たちがこれまで話してきた設計の話は全てフローについてであったことに気がつきます。  
これまでの責務の分割や依存関係は全てフロー(一つのインプットからそれに対するアウトプットまでの流れ。データフロー)を前提として話されており、ストック、つまりアプリケーション開始時からのデータフローの蓄積によって生成される状態をどう管理するのかという話が出てきていませんでした。  
その理由は恐らくレイヤードアーキテクチャやクリーンアーキテクチャが提案された当時はまだハードウェアやプロダクトの仕様の関係でアプリケーション状態の管理はアーキテクチャよりもよりミクロな問題だと捉えられていたからだと思います。  

しかし近年ではFluxやReduxなどアプリケーション状態の管理を主題としているアーキテクチャが主流となり、UXや開発効率の観点からも現代的なアプリケーションの設計の際にはデータフローの蓄積(ストック)について考えることは不可欠になりつつあります。  
そのためこの一連の記事ではフローだけでなくストックも踏まえて設計について考えていきます。  

### 設計のまとめ
設計に関する要点を5点述べました。  
アプリケーション設計を簡単に言ってしまうと、それは上記の4と5を考慮しながら1~3の作業をマクロからミクロに至るまで繰り返すことだと言えると思います。  
この作業を繰り返すことで、アプリケーションはレイヤー(層)->モジュール->コンポーネントと粒度が細かく細部にまで配慮が行き届いた開発しやすいプログラムへとなっていきます。
 

## クリーンアーキテクチャにおける層を跨ぐデータ構造がシンプルであるとはどういうことか
ここに関しては他にも何を持ってデータ構造が「シンプル」であるのかという問題もあります。  
「シンプルなデータ構造」を厳密に言葉で定義しようとするとなかなか難しいのですが、ここでいうシンプルさというのは何度も言っているように層の関心を分離するためであってそれを無視して設計してしまうとおかしくなります。  
再び具体例を出すとUI側でユーザ名が必要な場合ViewModelではApplication層にユーザー名の取得を要求しますが、この時にユーザー名を含めたアプリケーションに関する全ての情報を含んだデータを渡されても完全に情報過多です。  
開発時に最初から関わっている人はその特殊な事情を知っているかも知れませんが何も知らず新しく入ってきた開発者はユーザー名の取得のためにわざわざアプリケーションに関するすべての情報を取得しあまりに多くの知識がApplication層からViewModelに漏れていることに「何か自分が理解できていないことがあるのでは？」と気を揉むことになるでしょう。    
  
また反対にユーザー名の取得のためにユーザー名のみ返す場合はそれはシンプルなデータ構造を渡しているといえますが、こうなるとユーザーの電話番号、口座番号とUI側で必要な個々の情報に応じてApplication層側に取得メソッドを定義する必要があり、それはすなわちApplication層の定義がUIの仕様に影響を受けていることになるので関心の分離ができていません。  

例に出したケースでは、基本的にはユーザー名が取得したい場合はApplcation層はユーザー情報をViewModelに渡して、ViewModel側でユーザー情報からユーザー名のみ利用するというのが正解だと思います。  
ユーザー情報はアプリケーションの仕様として一つのまとまった情報単位であることは間違いないですし、もしこのユーザー情報という単位に変更が必要な場合はそれはUI側の事情ではなくアプリケーションの事情によるものであると言って良いでしょう。

ここで出した例をもとに層をまたぐシンプルなデータ構造を持ったオブジェクトをもう少し正確に説明すると、「受け渡す二つの層のうち内側にある層の仕様を基準に設計されたシンプルなデータ構造」と言えます。  

ちなみに話が何度も逸れて申し訳ないですが、上の例でInterface Adapter層がDomain層のデータを受け取ることに違和感を持つ人もいるかも知れません。  
クリーンアーキテクチャの円図で言うとInterface Adapter層が関わるのはApplication層で直接Domain層と関わることはあり得ないからです。    
ただ実際の開発ではApplication層がInterface Adapter層にデータを渡す際にはDomain層のデータを渡すことが多いです。 
## Swiftのプロトコル
## RepositoryとDAO

<a name="footnote1">*1</a>: この項の始めにあるFramework&Driversが外部技術であるという箇所と外部技術に依存しているという表現は矛盾しているような表現ですが、視点が異なっているだけです。  UIKitを例に出すとUIKitは内部でApple独自のレンダリング技術を使っているため外部技術に依存しているわけですが、他の層から見るとまさにそのUIKit自身が外部技術なわけです。

<a name="footnote2">*2</a>: ここでいう利用するとは実際にインスタンスを参照しているという意味であり、プロトコルに準拠していることは指していません。本来は括弧内で書いているように上位、下位と
表現することで十分だと思いますが、個人的にこれらの表現は淡白な割にどちらを上と見るかは捉え方次第で変わってしまうためあまり好きではなく利用する側、される側という表現しています。(ただ冒頭で説明したとり「利用する」とはなんであるのかも自明ではないため最適な表現ではなさそうですが...)


リポジトリとデータクライアントクラスの関係については補論RepositoryとDAOでもう少し詳しく取り上げました。  

