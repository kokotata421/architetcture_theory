
# iOSアプリでスケールしやすいアーキテクチャを考えてみた②-設計を理解するためのクリーンアーキテクチャ-

この一連の論考では私的に考えたスケールしやすいアーキテクチャを紹介します。  
全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ  
(2)**設計を理解するためのクリーンアーキテクチャ←本記事**  
(3)アーキテクチャ概要    
(4)ViewController(準備中)  
(5)View/Alert/Data Source(準備中)  
(6)画面遷移(準備中)  
(7)ViewModel(Controller/Presenter)(準備中)  
(8)UseCaseとエラー(準備中)  
(9)UseCaseとアプリケーションの状態管理(準備中)  
(10)Repository(準備中)  
(11)Domain(準備中)  
(12)Web API/データベース(準備中)  
(13)その他(準備中)  

本論では本編への準備編として設計の概観を把握するためクリーンアーキテクチャを説明しますので、  
「クリーンアーキテクチャはもう知ってるよ」という人は次の概要編から読んでいただいた方が良いと思います🚅  
また本論はレイヤードアーキテクチャの知識を前提としていますので、レイヤードアーキテクチャがわからない方は前回の記事から読むことをオススメします。  

## 前提
- 本論はアプリケーション開発における設計を前提としており、ライブラリ等の開発は想定されていません。  

### 本論における用語の表記ルール 
#### アーキテクチャと設計
一連の論考では「設計」と「アーキテクチャ」という2つの言葉が頻出しますが、これらはそれぞれ異なる意味を持ちながらも日常的なコミュニーケーションではあまり差異を意識されずに使用されているように思います。  
なので不必要な混同を避けるため、本論でのそれぞれの定義を以下で明確にしておきます。  
設計・・・アプリケーションプログラムの構造を考える作業、またそこで採用されている思想。  
アーキテクチャ・・・アプリケーションプログラムの構造。MVC/MVVM/Flux/クリーンアーキテクチャ、またそれらと同列に語られるもの  

定義を明確するとはいっても、アーキテクチャには設計(思想)が含まれているため両者を厳密に区別することは難しいです。  
しかし原則として本論においては、アプリケーション構造を考える作業もしくはその際に用いる考え方を設計、その結果出来上がった具体的なプログラム構造をアーキテクチャと記します。  

### 「アプリケーション」/「アプリケーションプログラム」/「アプリケーションサービス」/「アプリケーションプロダクト」
本論では「アプリケーションプログラム」という言葉が度々登場しますが、これは「アプリケーション」と同義です。  
ただ「アプリケーション」はユーザーからみたサービス/プロダクトを指す場合もあるため、開発者からみたプログラムであることを明示、強調したい際に「アプリケーションプログラム」と表記しています。  
同様に、アプリケーションの「サービス」また「プロダクト」の側面を強調したい場合には、それぞれ「アプリケーションサービス」、「アプリケーションプロダクト」と記しています。  
単なる「アプリケーション」もしくは「アプリ」という表記は、上記に該当せず特定の意図がない、もしくは意図を明確にする必要がない、と思われる場合に用いられています。  

#### 各層の表記
本論内でアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。  
例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logic(層)と表記します。  
InfrastructureはInfraと省略して表記し、Infra層のうちデータ操作に関するものをData(層)、端末機能に関するものをDevice(層)と表現する場合があります。  

#### コンポーネント
本論ではMVPのModel/View/Presenter、FluxのView/Action/Dispatcher/Store等、アプリケーションのオブジェクトに該当するような構成要素を**コンポーネント**と表記します。  
これは構成要素と表記してしまうとアーキテクチャの各層等、アプリケーション内の次元の異なる他の構成要素と区別がつきづらくなってしまうためです。  

## 前回までの内容と本論の内容
初回である前回の論考では、スケールしやすいアーキテクチャを考えるために、クリーンアーキテクチャを通して設計を理解することを最初の目的としました。  
その準備としてクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャの理解を深めたのが前回までの内容です。  

本論ではいよいよクリーンアーキテクチャを学び、設計の基本についてその全体を整理します。  

## クリーンアーキテクチャとレイヤードアーキテクチャの共通点&#47;相違点
最初に前回学んだレイヤードアーキテクチャと今回学ぶクリーンアーキテクチャの共通点、そして相違点について整理することでクリーンアーキテクチャを理解するためのポイントを浮き彫りにさせます。       
クリーンアーキテクチャの円図を再度掲載します。  
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図">  


前回の論考で、レイヤードアーキテクチャの特徴が**責務に応じた層の分割と単一方向の依存関係による関心の分離**であることを述べました。  
クリーンアーキテクチャでもそれは変わりません。    
円の中の一つ一つの色が層を、また円の左から中心に向かって連続している矢印が依存関係を示しています。  
レイヤードアーキテクチャと同様クリーンアーキテクチャもこの2つの特徴が中心にあり、これらを理解しているだけでその理論の骨格はつかめているといえるでしょう。  
しかし、クリーンアーキテクチャではその詳細が異なっています。  
そのため本論ではそれらについて詳しく見ていきたいと思うのですが、それはクリーンアーキテクチャが円で示される理由を理解することと同じです。  
なので、まず初めにクリーンアーキテクチャが円である理由に触れながら円の各層・依存関係について説明していきたいと思います。  

## Entities == Domain層 && Use Cases == Application層
クリーンアーキテクチャが円である理由を見ていく前に、前提としてクリーンアーキテクチャとレイヤードアーキテクチャの層で変わらない箇所を説明してきます。  
結論からいうと、クリーンアーキテクチャの円の中心にあるEntitiesはレイヤードアーキテクチャのDomain層、その一つ外にあるUseCasesはレイヤードアーキテクチャのApplication層と同じです。      
円のEntitiesから線が右側に伸びてEnterprise Business Rulesと書かれていますが、これを直訳すると「事業のビジネスルール」になります。  
前回の論考でDomainとは「事業の知識・ルール」を意味していることを書きましたが、ここからEntitiesがDomainと同じであることがわかると思います。  
そしてEnterprise Business RulesがDomain層であることがわかったならば、Use Casesに書いてあるApplication Business RulesがApplication層を意味していることはもはや説明不要でしょう。  

以後EntitiesではDomain、UseCasesはApplicationとして説明します。  

## 円である理由はアプリケーション設計の中心にビジネスロジックを据えるため
クリーンアーキテクチャはこれらDomainとApplicationを中心に置いて円を構成しているのですが、その理由はなんでしょうか。   
実はその答えはレイヤードアーキテクチャの論考で既に述べています。  
レイヤードアーキテクチャの論考では「Presentation Domain Separation(以下PDSと表記)」の設計原則を参照しながら、「Business Logicがアプリケーションプログラムの核心である」と説明しました。  
アプリケーションプログラムの核心がDomain層とApplication層にあること、これこそがまさにクリーンアーキテクチャの円の中心にBusiness Logic(Domain層とApplication層)が置かれている理由です。  

### Business&nbsp;Logicを円の中心に置く3つの理由
クリーンアーキテクチャの円の中心にBusiness Logicが置かれる理由をより具体的に示すと、以下3点が挙げられると思います。    

1. Business Logicなしではアプリケーションは成立しない   
2. Business LogicはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
3. Business Logicは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  

ここでは、上記3点それぞれの詳細について説明します。　　  

#### 1.Business Logicなしではアプリケーションは成立しない   
Business Logicを円の中心に置く理由として3つ挙げましたが、実質的にはこれがクリーンアーキテクチャの中心にBusiness Logicを置く理由であり、他2つはこれを別の側面から表現しているにすぎません。  
「ビジネスはアイディアから」的な話はよく聞くと思いますが、アプリケーションも同じです。  
そのアイディアをビジネスとして具体化、さらにプログラム化したものがDomain層であり、それをアプリケーションとして提供するための定義・実装がApplication層です。  
UI層やInfra層はそのサービスをプロダクトとしてユーザーに届ける手段として必要であって、アプリケーションは必ずBusiness Logicから生まれます。      

#### 2.Business LogicはUIやInfraといったアプリケーションの他の層よりも変更されづらい  
UX、外部技術的な観点から仕様が変更される場合、プログラム上ではUI層もしくはInfra層にのみ変更が生じます。  
それに対し、サービスの仕様が変更された場合には、基本的にBusiness LogicとともにUI層/Infra層も変更を迫られます。[<sup>*1</sup>](#footnote1) [<sup>*2</sup>](#footnote2)  
Business LogicはUX、技術仕様の影響は受けず、サービスとしてのアプリケーションの仕様変更時のみ変更されます。[<sup>*3</sup>](#footnote3)  
これは端的にBusiness Logicがアプリケーションプログラムの中心であることを示しています。  
#### 3.Business Logicは純粋なプログラミング言語による定義によって成り立ち、外部技術に依存しない  
Business Logicには、外部技術が含まれておらず、そのアプリケーションがサービスを提供するための純粋なロジック・データが定義・実装されています。  
そのため、Business Logicに定義・実装されているプログラムは、アプリケーションサービスそのものだと言えます。  

### クリーンアーキテクチャは現実の開発状況をより反映させている
以上のような理由によりDomainとApplicationを中心に据えているクリーンアーキテクチャですが、これはレイヤードアーキテクチャと比べてより現実の開発を反映させた設計であると言えます。  

レイヤードアーキテクチャでは技術的な観点から依存関係を決定していたため、技術的な基盤となるInfraをアプリケーションの支えとして捉え「UI->Application->Domain->Infra」という関係が成り立っていました。    
それに対して、クリーンアーキテクチャはアプリケーションの機能的中心であるBusiness Logicがアプリケーションを支えていると捉え、他の層がBusiness Logicに依存しています。(上との対比だと「UI->(Application->Domain)<-Infra」)  
クリーンアーキテクチャのこの構造は、現実のアプリケーション開発の実態をより正確に捉えています。  
アプリケーションは技術的にインフラ依存していますが、サービス的に依存しているのはビジネスロジックであり、開発はビジネスロジックを起点に展開されるからです。    
ビジネスロジックを中心として他の層と切り離すことで、実務で発生する要件に柔軟かつ迅速に対応することが可能になります。    
これは、私たちの日々の業務が技術的にはインフラであるインターネットに依存していながらも、その活動の中心はビジネス的な事柄にあるのと同様です。  

このように、クリーンアーキテクチャは開発の実情を踏まえ、技術的には(レイヤードアーキテクチャでは)4層の中間に位置するBusiness Logicをアプリケーションの基盤に据えて再構築した設計であり、それを視覚的に示した結果、円の形となっています。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/clean_architecture_is_restructure_of_layered_architecture.png" alt="クリーンアーキテクチャはレイヤードアーキテクチャを現実の開発状況を考慮して再構築したもの" width=80%　>


## Frameworks & Drivers層とInterface Adapter層
クリーンアーキテクチャがなぜ円なのか理解できたところで、クリーンアーキテクチャの層の内まだ触れられていないFrameworks & Drivers層とInterface Adapter層について説明していきます。  
### Frameworks & Drivers層
Frameworks&DriversのFrameworksはフレームワーク、つまりiOSのUIKit等パッケージ化された外部技術、DriversはIT用語でシステムに装着する外部装置を意味しており、この層はビジネスロジックをアプリケーションプロダクトとして完成させるために必要な外部技術群を指しています。    
円図を見てみるとFrameworks&Drivers層にはUI/Web/DataBase/Devices/External Interfacesとさまざまなものが含まれており、ここからはレイヤードアーキテクチャで異なる層であったUIとInfraが一つの層とされていることが確認できます。[<sup>*4</sup>](#footnote4)  
クリーンアーキテクチャでこのようにUIとInfraを同じ層として扱うのはこれら2つに以下の共通点があるからです。  

- 仕様の変更によってプログラムが変化しやすい  
- 外部技術に依存している[<sup>*5</sup>](#footnote5)  

こうした特徴を持ったFrameworks&Drivers層に他の層が依存していると、Frameworks&Drivers層の変更による影響が広がり開発の柔軟性が落ちてしまうため、クリーンアーキテクチャでは他の層から依存されないように同じ最外層に置いています。  
そして、お気づきの人もいると思いますが、上記のFrameworks&Drivers層の特徴はクリーンアーキテクチャがBusiness Logicを中心に置く理由と表裏一体です。  
クリーンアーキテクチャでは、Business Logicに変更されやすい外部技術に依存したプログラムを置かない代わりに、それらをFrameworks&Drivers層に実装しています。  
  
ただ一点留意しておきたいのが、プロジェクトでクリーンアーキテクチャを採用した場合にも、ディレクトリ構造上はUIとInfraは区別されることが多いということです。    
クリーンアーキテクチャのディレクトリ構造については本論とは直接関係ないためここでは省略しますが、[補論](#補論1クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない)にて簡単に説明しています。  
### Interface&nbsp;Adapters層
さて、次はInterface Adaptersです。  
Interface Adaptersという言葉だけ聞くとなにやら難しく感じてしまうのですが、簡単にいえばこの層は、内側のBusiness Logicと外側のFramework&Drivers層を繋ぐ仲介役を担う層です。  

円図ではこの層に該当するコンポーネントとしてController/Presenter/Gateway等が書かれていますが、基本的にこれらのうちControllerとPresenterがUIとBusiness Logicの、GatewayがInfraとBusiness Logicの仲介役を担っています。  
iOSMVCのControllerに当たるViewControllerもここに属し、円図でいうController/Presenterを担っています。(UIKitフレームワークに依存しているViewControllerがなぜInterface Adapters層に位置するのかは[後](#クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想)に説明します。)  

#### MVCのControllerと円図にあるControllerは異なる
ややこしいのですが、MVCアーキテクチャの文脈でいうControllerと円図に書いてあるControllerは意味が異なります。  
私たちにとってはControllerというと画面の入出力処理を担うMVCアーキテクチャのControllerが馴染み深いと思いますが、ITにおける一般的なControllerは入力処理のみを責務としており出力処理の意味合いは含んでいません。     
これはMVPのPresenterにも同じことが言えて、Presenterは一般的には出力のみに関する処理装置を指しておりMVPのPresenterは円図でいうControllerとPresenterの両方の責務を担っていることになります。
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/2つのController(MVCとCA).png" alt="MVCとクリーンアーキテクチャのController" width=55%>

#### Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる
このInterface Adapters層が担う「層の仲介」という責務はレイヤードアーキテクチャでは存在していませんでしたが、実際に開発で実践してみるとこの層の重要性に気づきます。  
層同士が連携して責務が混ざり合ってしまう箇所を一つの独立した層として捉えることで、各層の責務の純度が格段に上がるのです。  
  
レイヤードアーキテクチャの層はアプリケーションを機能によってわかりやすく分割していますが、それはあくまで理論上の話であって、実際のアプリケーションでは各層が連携して一つのアプリケーションとして動作するため層の責務が交わり、境界が曖昧な処理が発生します。  
例えば、Domain層ではビジネス的な事柄が関心の対象なので、永続化機構でデータを更新するためのURLやそのためのデータ形式の変換に関心を向けるべきではありません。  
ただ一方で、Infra層ではデータを永続化するという汎用的な責務を担ってはいるものの、特定のURLやそれに関する処理はそのアプリケーション(ドメイン)固有なものであり、Infra層がその責務を負うのもおかしいです。  
このようにレイヤードアーキテクチャによる層の分割を実践しようとすると層の境界でどっちつかずな責務が発生してしまいます。[<sup>*6</sup>](#footnote6)  

この問題を解決するために、クリーンアーキテクチャではレイヤードアーキテクチャの層が連携する責務も一つの独立した層として捉えました。  
こうすることで円の内側のBusiness Logicと外側のFramework&Drivers層に強引な形で不純な責務を含める必要がなくなり、各層の責務の純度を高く保つことができます。   

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/interfaceadapters_roll.png" alt="Interface Adapters層は各層の純度を高くしてくれる" width=55%>  

> 補足:  
>「Interface&nbsp;Adapters層は各層の責務の純度を高くしてくれる」と言いながら、Domain機能であるプログラムがInterface Adapters層に置かれているのはおかしいと思う人もいるかと思います。  
> これに関しては簡潔な言葉で表現しようとするとどうしても矛盾しているように思える箇所が出てきてしまうのですが、ここで私が責務の純度があがると言ってるのはあくまでコード上の話です。  
> 確かに概念上Domain機能のものであればDomain層に置いた方が純度が高いと言えるかもしれません。  
> ただ実際のプログラムでは機能上はDomainでもInfraのコードが混ざっている等のケースが多く、そうした雑多なコードをInterfaceAdapters層に置くことで各層の責務の純度が上がります。  
> また後ほど[補論](#補論4Repository)にて触れますが、上の図に関しては他にも「Infraを利用したDomain層」はインターフェース上はDomain層である等、図では示せていないこともあるのであくまでイメージとして捉えてください。  
> とりあえずここで述べたいのはクリーンアーキテクチャでは「層の連携」というそれまで責務の境界の曖昧であった処理をInteraface Adapters層として扱うことで、各層のコードが区別されより明白になったということです。  

#### RepositoryもInterface Adapters層
円図では表記されていませんが、開発でよく耳にするRepositoryもこのInterface Adapters層に入ります。  
[Marin Flower氏の定義](https://martinfowler.com/eaaCatalog/repository.html)を引用すると、RepositoryはDomain層とData層の仲介役です。(引用文のdata mapping layersはData層を指しています。)  
>A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection  
>
>意訳:  
>RepositoryはDomainとData層の中立ちをし、インメモリなドメインオブジェクトコレクションのように振る舞います  

円図でいうと、Gatewaysの中に含まれていると考えればよいと思います。   

#### Gatewayは「Business LogicとInfraの中継役」
ちなみにGatewayという名前はクラス名としてはあまり聞き慣れないと思いますが、クリーンアーキテクチャにおいてはBusiness Logicと最外層(主にInfra)の仲介に入り、データ変換を行うコンポーネントを指しています。  
私はInterfaceAdapters層のコンポーネントに命名するとき、できる限り「~Repository」等より具体的な名前を使うようにしていますが適切な名前が見つからない時は「~Gateway」と命名します。      
Gatewayは広範囲を示す名前ではありますが、プロジェクト内で乱用されるようなものではなく、クリーンアーキテクチャのコンテクストが共有されていればそれだけでInterface Adapters層のコンポーネントだと伝わるので、「~Managerクラス」や「~Serviceクラス」等より責務が明確で便利な単語だと思います。  

## クリーンアーキテクチャの依存ルール
クリーンアーキテクチャの特徴には、責務の層の他に依存関係がありました。  
その[依存方向が外側の層から内側の層へということ](#クリーンアーキテクチャとレイヤードアーキテクチャの共通点相違点)、[クリーンアーキテクチャの外側の層の仕様は変わりやすく内側の層の仕様は変わりづらい性質](#BusinessLogicを円の中心に置く3つの理由)は既に述べた通りです。    
つまり、クリーンアーキテクチャにおいてその依存方向は変更されやすい外側の層から変更されにくい内側の層へ向いており、それによって変更されやすい外層のアプリケーションへの影響を最小限に抑えています。 

しかし、技術的に依存しているのはInfra層であるはずなのに、Infra層がビジネスロジックに依存するということはどういうことなのでしょうか。  
これについては後述の[クリーンアーキテクチャのルールを守るためのテクニック](#ルールを守るためのテクニック)で説明しています。    

## クリーンアーキテクチャの概要を一度整理する 
ここまででクリーンアーキテクチャの特徴には一通り触れました。  
しかしレイヤードアーキテクチャの理解を前提として話を進めていたため、クリーンアーキテクチャの基本的な説明をあまりしていません。        
そのため、これまでの内容と重複する部分もありますが、ここで一度[クリーンアーキテクチャの原文](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)に沿ってその概要を整理していきたいと思います。  

## クリーンアーキテクチャの特徴   
クリーンアーキテクチャ原文の冒頭では、ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等のシステムアーキテクチャを紹介しています。  
システムアーキテクチャは、アプリケーションの特定領域にこだわらずシステム全体を関心の対象としているアーキテクチャのことを指しています。[<sup>*7</sup>](#footnote7)  
原文では、それらシステムアーキテクチャの特徴として以下の共通点があると述べています。    

1. **関心の分離**  
どのシステムアーキテクチャも関心の分離を基本として、少なくともBusiness Logicとその他の2層に分けようしている  
2. **UI/WebAPI/データベース/フレームワークといった外部技術が独立している**   
変更されやすいUI/Web API/データベース/フレームワーク等のプログラムにはどこからも依存しない  
このような外部技術は便利なものの同時に制約も発生させるため、これらに依存しないようにすることで柔軟な開発が可能になる  
3. **テストしやすい**  
Business Logicは、特定の外部技術に依存していないためテストが容易である  

### クリーンアーキテクチャの層は4つである必要はない
クリーンアーキテクチャはDomain/Applicatoin/Interface Adapters/Framework&Driversという4つの層からなっていると説明しましたが、原文には必要であればもっと層を増やしても構わないと書かれています。  
ただ該当箇所の見出しには「Only Four Circles?(4つの層だけ?)」と書かれており、基本的に4つの層より多くなることはあっても4つの層より少なくはならないという考えのようです。   
私も、責務の分離を目的とするなら少なくともBusiness Logic/Interface Adapters/Framework&Driversの3層は必要であり、Business Logicも設計者が適切に責務を分けていけば、たとえ層の分割を意識していなくとも実質的にDomain/Applicationという分離が生まれるはずなので、この4層を基本として、必要であればそれ以上に層を分けていくというスタンスで良いと考えています。      

## クリーンアーキテクチャで守るべきルール  
クリーンアーキテクチャの以上の特徴を保つためには開発者が守らなければいけないルールが3つあります。    

### ルール1&#58;円の内側の層は外側の層については知らない何も知らず&#12289;影響も受けない
クリーンアーキテクチャの各層は、自身の外側の層について何も知らなくても独立して動作できるようになっている必要があります。  
クリーンアーキテクチャでは、各層は連携しつつも可能な限り関心を分離することを目的としているため、許容されている依存方向は外側の層から内側の層のみとなっています。  
もし内から外への依存が必要な場合は、後述する[依存関係逆転の原則](#依存関係逆転の原則DependencyInversionPrinciple)を適用します。  

#### Interface&nbsp;Adapters層は例外
ただ技術的な依存は上述の「依存関係逆転の原則」の適用によって解決されますが、概念的な依存(外の層の仕様に内側の層が影響を受ける)に関してはInterface Adapters層において例外があります。  
既に説明した通り、Interface Adapters層は内側と外側の層の中継役なので直接的ではなくても外側の層の仕様の影響を受けます。  
例えば、UI側のInterface Adapters層は、UIの仕様変更によって自身の入力・出力の処理も変更することになるので、直接UIを知らなくても間接的にその仕様の影響を受けることになります。  
また、Infra側のInterface Adapters層も実体型としてデータベースやWebAPIを参照していなくとも、それにアクセスするメソッドのインターフェースはデータベースかWebAPIで大きく異なるため、Infraの仕様による影響は避けられません。  
 
原文の記事でも、冒頭で  
>Nothing in an inner circle can know anything at all about something in an outer circle.  
>
>意訳:  
>内側の層は外側の層について全く知らないこと。  

と強調しながらも、Interface Adapters層の説明では、SQLデータベースを例に出しながら、Interface Adapters層が外側の層について知っていることは致し方ないことだと書かれています。(ただ同時に外側の層がInterface Adapter層に与える影響は必要最低限に留めることも強調しています。)  
>If the database is a SQL database, then all the SQL should be restricted to this layer, and in particular to the parts of this layer that have to do with the database.
>
>意訳:  
>もしデータベースがSQLならば、SQLに関するコードはInterface Adapters層の内データベースと関与する箇所に限定すべきである。  

### ルール2&#58;層をまたぐオブジェクトはシンプルなデータ構造であること
層間でオブジェクトの受け渡しを行う際には、層の責務が漏出してしまう危険性があります。  
アプリケーションとして動くためには層間の連携は避けられませんが、ある層のオブジェクトが他の層に渡されることで、本来属する責務ではない層において使用されることになるからです。  
クリーンアーキテクチャではこうした状況でも関心の分離を保つために、層をまたぐオブジェクトはシンプルなデータ構造であるべきだとしています。    
#### 層を跨ぐデータにより責務が他の層に漏出する場合
もし層をまたぐオブジェクトが複雑な処理のメソッドを持っていた場合、跨いだ先の層でもそのメソッドの呼び出しが可能であるため、メソッドを通して責務が他の層へ漏出していってしまう恐れがあります。  
この場合、オブジェクトが受け渡し先でどのように使用されるのか想定しきれないため、プログラムにおける不確実性が高まりバグの温床となってしまいます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/clean_architecture_responsibility_leak.png" alt="層を跨ぐデータにより責務が漏出してしまう場合" width=50%>  

#### データが層を跨いでも責務が他の層に漏出しない場合
それに対して、層を跨ぐオブジェクトがメソッドを持たないデータ構造である場合は、受け渡し先の層ではデータ操作のみ可能であるため層を跨いでも責務が漏出する恐れはありません。[<sup>*8</sup>](#footnote8)  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/clean_architecture_responsibility_not_leak.png" alt="層を跨ぐデータで責務が漏出しない場合" width=50%>  

ちなみに、本項冒頭の「メソッドを持ったオブジェクト」とは、正確には「層の責務の漏出につながるようなメソッドを持っているオブジェクト」を指しています。  
例えば、SwiftのArray型はメソッドを持っていますが、それらのメソッドは自身に関するデータの取得、またデータ操作を行う処理であり、そこから層の責務が漏出してしまう恐れはないため、層間で受け渡されても問題ありません。  

層を跨ぐデータについては、[補論](#補論1クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない)でも取り上げています。  

### ルール3:データフローは一方向
このルールはクリーンアーキテクチャの原文には明言されていませんが、クリーンアーキテクチャに限らず設計において重要であるため追記しました。     

アプリケーションのデータフローをクリーンアーキテクチャの円図に沿ってたどっていくと、まず入力が円の外側のUIで起こり、それを処理するため内側のBusiness Logicに入って、そしてその結果は再び出力先であるUIに向かっていきます。  
そのためデータは円の外->内->外と流れていて、一見すると一方向になっていないように思えますが、これは円図がデータフローではなく依存関係に着目して作られているからであって、実際のところデータフローも一方向です。  
クリーンアーキテクチャの右下の図でもその様子が示されています。[<sup>*9</sup>](#footnote9)  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/クリーンアーキテクチャの右下の図.png" alt="クリーンアーキテクチャの右下の図" width=30%>  

図が表しているようにデータフローはContrller->UseCase(Applciation)->Presenterとなっており、これらは円図で見ると外->内->外ではありますが、実際には外から内へ入る時と内から外へ出ていく時の経路が異なるためデータのフローは一方向となっています。    

これはMVCのControllerやMVPのPresenter等、一つのコンポーネントが画面の入出力を担当している場合も同じです。  
こうしたコンポーネントでは一つの中に入出力の責務がありながらも、プログラム上では入力と出力の責務が交わらないような設計が前提となっています。 

以下イメージ図を載せておきます。(あくまで一例でありデータフローが一方向である設計が必ずこのような構造になっているわけではありません)  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/データフローは一方向な例.png" alt="データフローは一方向な例" width=50%>  

## ルールを守るためのテクニック
クリーンアーキテクチャに関して色々と説明してきましたが、最重要ルールと言える「円の内側が外側についてなにも知らない」を守りながらアプリケーションをどう実装するのかについてまだ触れていません。    
アプリケーションは技術的にInfraに依存しているにも拘らず、円の内から外へ依存をしてはいけないというのは一見不可解であるように思えます。  
そのため、ここではこの内側から外側への依存をどう解決すればよいか説明していきます。  

### 依存関係逆転の原則&#40;Dependency&nbsp;Inversion&nbsp;Principle&#41;
これには依存関係逆転の原則(Dependency Inversion Principle)を適用します。    
「依存関係逆転」と聞くと難しそうに聞こえるのですが、要はあるコンポーネントに依存するとき実体型ではなく抽象型(Swiftでいうプロトコル)を使用するというテクニックを指します。          
なぜプロトコルに依存することで層の外側から内側の依存のみになるのかというと、通常実体型による依存関係では上位(利用する側)の層から下位(利用される側)の層への依存となりますが、プロトコルを使用した依存関係の場合、そのプロトコルは下位の層ではなく上位の層に属していると考えられているからです。  
そうすると上位コンポーネントも下位コンポーネントも上位の層にあるプロトコル依存していることになるため依存方向が逆転します。    

もう少しわかりやすく説明するために以下で簡単な例を示します。  
### 依存関係逆転の例
クラスAがクラスBを利用しているとします。  
その場合、それらの依存関係はA->Bとなり上位のAが下位のBに依存しています。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/プロトコルを利用しない依存関係.png" alt="プロトコルを利用しない依存関係" width=50%>  
ここで、これらに依存関係逆転の原則を適用するため、クラスBの要件を満たした「BType」というプロトコルを定義し、クラスAはBクラスを直接依存するのではなくBTypeプロトコルに依存するようにします。  
この時BTypeプロトコルはBクラスの要件を全て満たしているので、AクラスはBクラスに依存していた時と同じようにBTypeプロトコルを使用できます。  
またクラスBはBTypeプロトコルに準拠するようにします。(堅苦しいですが、Swiftではある実体型にプロトコルを適用する場合「プロトコルに準拠する」とよく表現します。)  
```
// class Aはclass Bに依存せず、同じ要件を満たしたBTypeプロトコルに依存する
class A {
   let b: BType
   
   func hogeA() {
      b.hogeB()
   }
}

//　BTypeプロトコルはclass Bの要件を全て満たしている
protocol BType {
   func hogeB()
}

// class BはBTypeプロトコルに準拠している
class B: BType {
   ...
   func hogeB() {
      ...
   }
}

```
そうなるとクラスAはBTypeプロトコルに依存しBクラスもBTypeプロトコルに準拠するため、先程のA->Bで表していた依存関係はA->BType<-Bに変化します。(ここではプロトコルに準拠することも一種の依存としています)  
そしてBTypeプロトコルは使用する側であるクラスAの層に属していると捉えられているため、先ほど上位から下位への依存であった関係が下位から上位への依存に逆転したことになります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/プロトコルを利用した場合の依存関係.png" alt="プロトコルを利用した場合の依存関係" width=50%>  
これがプロトコルを使用した依存関係の構築が「依存関係逆転」と言われている理由であり、クリーンアーキテクチャではこの原則を用いて層の内から外への依存を行わないようにします。  

> 補足:  
> 本例でBTypeプロトコルがクラスAの層に属すのは、プロトコルはあくまで依存するコンポーネントの層で使用されるインターフェースとしてみなされるからです。  
> 例えば、MVVMアーキテクチャにクリーンアーキテクチャの設計思想を取り入れた場合、UI層(Frameworks&Drivers層)のAViewコンポーネントが使用するAViewModelのインターフェースは、AViewコンポーネントが使用するプロトコル(AViewModelType)としてUI層に定義します。  
> しかし、実際のAViewModelクラスでは、その実装においてApplication層(UseCases層)のコンポーネントを使用するため、UI層ではなくInterface Adapters層のコンポーネントとして扱われます。  
> 同様にリポジトリは機能(概念)的にドメインオブジェクトの操作であるため、プロトコルはDomain層として扱われますが、 実体型ではWeb APIもしくはデータベースを使用するためInterface Adapters層のコンポーネントとなります。  

### プロトコルを利用することでプログラムの変更を行いやすくなる
プロトコルを使用した依存が「依存関係の逆転」と言われているから内から外の依存はないというのは、「ただの概念的な操作であって、ただのレトリックにしかすぎない」と思う人もいるかもしれません。  
ただここでもう一度思い返して欲しいのですが、クリーンアーキテクチャで外から内への依存のみを許容している理由は以下2点です。  
- Business Logicは外層(外部技術)から独立している
- テストを容易にする

そして、実体型を用いた依存関係では満たせていなかった上記の要件は、プロトコルを使用することによってしっかりと満たせるようになっています。     
例えば、Interface Adapters層コンポーネントがInfra層コンポーネントを使用する場合、依存するのはInfraクラスではなくInfraの要件を満たしたプロトコルであるため、プロトコルに準拠したコンポーネントであればInterface Adapter層側のコードを書き換えることなく実体型を差し替えることができ(外部技術から独立している)、また仮コンポーネントを使ったテストも容易に行えます。    
UIでも同様に、デザインやUIプログラムが完成していなくともコンソールなどに出力して値が正しいか確認できるようになります。    

### 依存の方向関係なくプロトコルは積極的に利用する
内から外への依存を行いたいときのテクニックとして依存関係逆転の原則を紹介しましたが、実際にはテストの観点から外から内への依存でも積極的にプロトコルを利用することをオススメします。  
例えばUIテストを行う時、出力値が正しいかどうかではなく出力値を表示するレイアウトが正しいかどうか確認したい場合があります。  
この場合、UIからInterface Adaptes層への依存においてプロトコルを利用することで、仮コンポーネントを使用したテストが可能になります。  

他にも依存とプロトコルについては補論[Swiftのプロトコル](#補論3Swiftのプロトコル)で説明をしています。    

## クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想
以上でクリーンアーキテクチャの基本的な説明は終わったのですが、全体を振り返って改めて強調したい点があります。  
それはクリーンアーキテクチャはあくまで**保守・開発しやすいプログラムのための設計思想**であり、実際の開発ではこれを原則としながらも状況に合わせて柔軟に対応していく必要があるということです。   
例えば、iOSMVCにおいてViewControllerは機能的には間違いなくInterface Adapters層(Contrller/Presenter)に該当すると同時に、技術的にはUIKitフレームワークに依存していてFrameworks&Drivers層に当たりますが、この場合は、クリーンアーキテクチャの原則に反していても、ViewControllerをInterface Adapters層として扱うのが妥当だと思います。  
ここで強引にViewControllerをFrameworks&Drivers層に置く設計にするならば、クリーンアーキテクチャの原則に適応した代償としてプログラムが冗長になり、本末転倒になってしまいます。(ましてやiOSアプリをUIKitで開発するならば、クリーンアーキテクチャの原則厳守のためにViewControllerなしで設計するなんて考えられません。[<sup>*10</sup>](#footnote10))[<sup>*11</sup>](#footnote11)     
またWebフレームワークやデータベース系ライブラリでも、Domainオブジェクトに制約をかけることでデータベース操作における恩恵を得られる技術は数多く存在します。      
クリーンアーキテクチャはいかなるアプリケーション開発にも通用する基本的な考えを提示していますが、外部技術によってはその採用で得られる強力な機能のために、クリーンアーキテクチャのいくつかの原則を局所的にせよ破らざるをえないかもしれません。  
設計者はこうしたトレードオフの中、柔軟にプロジェクトで採用する技術や設計を選択していく必要があります。      

## クリーンアーキテクチャにある誤解
さてここからは、ネット上で見かけるクリーンアーキテクチャ(特に「iOS クリーンアーキテクチャ」で調べた場合)の誤解を2点ほど説明したいと思います。  
### 1. Entitiesに関する誤解
### EntitiesはDomain層
ネットで調べているとEntitiesがData(Infra)層であるというような内容の記事がありますが、クリーンアーキテクチャにおけるEntitiesはData層ではなくDomain層です。  
EntitiesをData層としてしまうと円図の中心にはData層があることになり、ビジネスロジックを他から切り離すというクリーンアーキテクチャの本来の目的を読み取れず、その意図がわからなくなってしまいます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/EntityがData層だった場合.png" alt="EntitiesがData層だった場合" width=80%>  
<sup>*図ではEntitiesの解釈に焦点が当たっているため、DomainではなくEntitiesと表記しています。</sup>  


恐らくこのEntitiesをData層とする主張は、データベースの文脈におけるEntityと混同しているのだと思います。  
データベースの文脈でEntityはデータベース上で操作するデータのまとまりを指し、プログラム開発で一般的にEntityというとこの意味で使われます。    
しかし先ほども述べた通り、EntitiesをData層と解釈してしまうと、クリーンアーキテクチャの主張と根本的に矛盾してしまいます。    

### Entitiesはビジネスルール
Entitiesに関しては、もう一つ誤解があります。  
それはEntitiesが単純なデータ型ではなく、ビジネスルールを指しておりロジックを含んでいるという点です。  
ネット上ではEntitiesをデータ型として紹介しているクリーンアーキテクチャの記事を時々見かけますが、クリーンアーキテクチャのEntitiesの定義を読むと、それが単純なデータ型を指していないことがわかります。      
>Entities encapsulate Enterprise wide business rules.   
>An entity can be an object with methods, or it can be a set of data structures and functions.  
>  
>意訳:  
>エンティティは事業のビジネスルールを含んでいる。    
>エンティティはメソッドをもったオブジェクト、もしくはデータ構造と関数の集まりである。  

このようにクリーンアーキテクチャにおけるEntitiesはロジックを含んだ「ビジネスルール」をカプセル化したものです。  
そのためビジネスロジックを持っていない単純なデータオブジェクトは、Entitiesを構成する一要素ではありますがEntitiesそれ自体ではありません。  

この誤解は先ほどのデータベースの文脈におけるEntityに加えて、ドメイン駆動開発におけるEntity、VIPERアーキテクチャのEntityとも混同しているため生じていると思われます。  
特にクリーンアーキテクチャをiOSの開発環境で実践しやすいように簡易化させたVIPERアーキテクチャのEntityと、クリーンアーキテクチャのEntitiesで意味が異なるのは誤解を招きやすいと思います。(ちなみにVIPERのエンティティもData層ではないことは強調されており、その点はクリーンアーキテクチャのEntitiesと同じです。)  

> 補足:  
> 上記の説明をみると、ドメイン駆動開発(以下DDD)におけるEntityとクリーンアーキテクチャ(以下CA)のEntityの違いもわかると思います。    
> 両者の違いを説明する際にしばしば識別子(identifier)の有無が注目されますが、そもそもDDDのEntityは「モノ」であるのに対してCAのEntitiesは「ルール」であって、両者は識別子の有無という差異以前にその存在における質から異なります。  
> DDDのEntityの識別子はそれが「モノ」であるからこそ必要なのであって、「ルール」であるCAのEntitiesにはインスタンスを区別するための識別子が原理的に必要ありません。  

### 2. Interface Adapters層の誤解
次にInterface Adapters層の誤解についてです。    
### Business Logic層のデータをUI層のデータ形式へ変換するのはInterface Adapters層の責務
クリーンアーキテクチャにおいて、Application層であるUseCase内でTranslatorというコンポーネントを利用してデータをUI用の形式に変換するという内容の記事を見かけますが、これは誤りです。        
既に[本論](#InterfaceAdapters層は各層の責務の純度を高くしてくれる)でも説明しましたが、Application層のデータをUI層の形式に変換するのはApplication層ではなくInterface Adapters層の責務だからです。  

Interface Adapters層の役割を原文に沿いながら再度説明します。  
原文のInterface Adapters層の説明では  
>The software in this layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency  
>  
>意訳:  
>この層(Interface Adapters)はApplication層もしくはDomain層のデータを最外層に最適な形式に変換することである。
  
Business Logic(Application/Domain)層のデータをFrameworks&Drivers層に適した形式に変換すると述べたあとに、
>Also in this layer is any other adapter necessary to convert data from some external form to the internal form used by the use cases and entities  
>
>意訳:  
>またこの層(Interface Adapters)では最外層のデータを内側のApplication層やDomain層に最適な形式に変換する。　　

最外層のデータをBusiness Logic層に最適な形式に変換するとも述べています。    
つまり、ここから、Interface Adapters層は、その方向にかかわらず内層(Business Logic)と外層(Frameworkds&Drivers)間のデータ形式の変換を役割としていることがわかります。  

であるならば、クリーンアーキテクチャでは関心の分離を保つために、こうしたBusiness Logic-Frameworks&Drivers間のデータ変換をInterface Adapter層に閉じ込めるべきです。

もしUI層へのデータ変換の責務をApplication層であるUseCaseに置いたならば、UseCaseはUIの仕様なしでは定義・実装できないため[円の内側の層は外側の層について何も知らない](#ルール1円の内側の層は外側の層については知らない何も知らず影響も受けない)というクリーンアーキテクチャのルールを破ってしまうことになります。    

### Data層のデータをBusiness Logic層のデータ形式に変換するのはInterface Adapters層の責務
Interface Adapters層ではData側でもよく見かける誤解があります。
#### Data層でDomainオブジェクト型のデータを返すのは誤り
クリーンアーキテクチャの記事でData層がDomain層の型でオブジェクトを出力しているケースを見かけますが、これも先ほどと同じくInterface Adapters層以外でデータ変換を行なっているため誤りとなります。  
この設計ではInterface Adapters層でデータ変換を行わないため、クリーンアーキテクチャの「[Infra(Data)層がApplication/Domain層から独立している](#クリーンアーキテクチャの特徴)」の特徴を満たせず、コードが冗長化して変更に弱いプログラムになってしまいます。  
ここではData層とBusinness Logic層が分離されていないことで、どのような問題が起きてしまうのか具体例を用いて説明します。 
#### Data層でBusiness Logic層のオブジェクトを出力する誤った例 
前置きとして[依存関係逆転](#依存関係逆転の原則DependencyInversionPrinciple)ではプロトコルは上位の層に属すると説明しましたが、論旨とは関係ないためここではプロトコルも下位の層に属するものとして話をします。(プロトコルは上位、その実体型は下位として扱うと説明が複雑になってしまうので)
またData層でデータ操作を行うコンポーネントをData Clientと表現します。  

それでは例を見ていきましょう。  
ObjectAというDomain層オブジェクトをData層を通して操作するObjectARepositoryが定義されているとします。    
そして今回問題として指摘しているのは、このObjectARepository内で使用するData ClientがObjectAを返り値とするインターフェースを持っている設計です。  
<a name="Data層がBusinessLogic層に依存した実装">コードは以下のようになります。(ここでは同期・非同期は論旨とは関係がないため、Infraが出力するデータはシンプルに返り値で渡されることとします。)</a>      

Data層側のコード  
```
protocol ObjectADataClientType: class {
   func fetch() -> ObjectA
}

class ObjectADataClient: ObjectADataClientType {

   func fetch() -> ObjectA {
      // Web APIもしくはデータベースからObjectAを取得する処理
      // ...
      return ObjectAのインスタンス
   }
}

```

Repository(Interface Adapters)層側のコード
```
protocol ObjectARepositoryType: class {
   func fetch() -> ObjectA
}

class ObjectADataRepository: ObjectARepositoryType {

   private let dataClient: ObjectADataClientType
   
   init(dataClient: ObjectADataClientType) {
      self.dataClient = dataClient
   }
   // Repositoryはデータクライアントクラスのメソッドを呼び出しているだけで、自身で独自の処理は何もしていない
   func fetch() -> ObjectA {
      return self.dataClient.fetch()
   }
}

```

##### Data層がアプリケーションから独立しておらず、Repository(Domain)と役割が重複している
上記のコードをみるとInterface Adapters層のObjectARepositoryだけでなく、Data層であるObjectADataClientもDomain層のObjectAを返しているのがわかります。  
このようにData層がDomain層のオブジェクトを返す設計であると、Data層はDomain層の知識を知らなければ定義・実装できないため、クリーンアーキテクチャの「[Infra(Data)層はApplication/Domain層から独立している](#クリーンアーキテクチャの特徴)」という特徴を満たせません。  

またObjectADataClientTypeとObjectARepositoryTypeの定義を比較すると、両者ともにObjectAを返していて機能が重複しており、RepositoryはData Clientのメソッドを呼び出しているだけで自身では独自の処理を全く行なっていません。    

##### Data層が肥大化する
こうした設計がアプリケーション全体に及んだ場合、Data層はとても肥大化してしまいます。(そもそもDomainオブジェクトと切り離されていないデータアクセス処理の集まりをData層と言って良いのかわかりませんが、ここではそういうことで話を進めます。)  
仮に、あるアプリケーションでObjectA〜Zまでの26のオブジェクトをRepositoryで操作するとしましょう。  
その場合、先ほどの設計に沿って開発すると、ObjectAからZまで各々のオブジェクトに対してRepositoryとData Clientのプロトコル・実体型を定義、実装しなければならず、またこれらのDomainオブジェクトに仕様変更が起こった場合にも、RepositoryとData Clientの両方に対して変更を適用する必要があります。  

Repositoryが実質的に何の独自処理も行なっていないことを考えると、この設計はあまりにも冗長であるように感じます。  
<img name="Data層がBusinessLogic層に依存した設計図" src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/Data層とBusinessLogicが切り離されていない設計.png" alt="Data層とBusiness Logicが切り離されていない設計" width=65%>  

もちろん、対応するRepositoryとData Clientの出力する値が必ずしも同じとは限らないため、実際のアプリケーションが上図のような構成になるとは限りません。  
しかし、どうであれData層がBusiness Logic層から独立できていない限り、多くのData Clientコンポーネント(もしくはメソッド)が必要になってしまいます。                  
こうした冗長さを回避するためには、Data層をBusiness Logic層から切り離す必要があります。  

#### Infra層とBusiness Logic層を切り離した設計
Infra(Data)層をBusiness Logic層から切り離すために、2点の変更を行います。  

1. Data Clientの出力をData型(もしくはIntやString等Swiftのプリミティブ型)にする
2. Data Clientコンポーネントを集約する  

##### 1. Data Clientの出力をData型(もしくはIntやString等Swiftのプリミティブ型)にする
Infra層が出力するデータ形式をData型を代表とするSwiftのプリミティブ型とすることでInfra層からBusiness Logic層へのデータ変換をInterface Adapters層であるRepositoryが担うようにします。  
こうすることで、RepositoryはただData Clientの出力を垂れ流すコンポーネントではなくなります。  

##### 2. Data Clientコンポーネントを集約する  
Data Clientコンポーネントを操作対象であるオブジェクト毎ではなく、WebAPIやデータベース等データアクセス機構毎に定義・実装することを意味しています。    
この集約によってData Clientを再利用することができ、プログラムの冗長さがなくなります。  

#### Infra層とBusiness Logic層を切り離した実装例
それでは、上記2点の変更点を踏まえた上で、[先程のObjectAをRepositoryで操作するプログラム例](#Data層でBusiness Logic層のオブジェクトを出力する誤った例)を考えていきます。  
以下では、Data ClientとしてWeb APIを使用していると仮定した上で、Data ClientとRepositoryを実装しています。(このコード例でも論旨とは関係ないため出力するデータは返り値で渡されるものとし、メソッドのパラメーターも簡略化しています。)  

Data層側のコード
```
protocol WebAPIClientType {
   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data
}

class WebAPIClient: ObjectADataClientType {

   func request(url: URL,
                headers: [String: String],
                parameters: [String: String],
                method: HTTPMethod,
                body: Data?) -> Data {
         // 引数で指定されたURLと通信を行いデータを取得する処理
         ...
         return 通信で取得したData
    }
}



```

Repository(Interface Adapters)層側のコード
```
protocol ObjectARepositoryType: class {
   func fetch() -> ObjectA
}

class ObjectADataRepository: ObjectARepositoryType {

   private let dataClient: WebAPIClientType 
   
   init(dataClient: WebAPIClientType) {
      self.dataClient = dataClient
   }
   // RepositoryではObjectAのデータを取得するためのパラメーターをデータクライアントクラスのメソッドに渡し、またData型からObjectA型への変換を行なっている
   func fetch() -> ObjectA {
      // ObjectAのデータを取得するためにData Clientメソッドのパラメータを指定する
      let data: Data = self.dataClient
                           .request(url: ...,
                                    headers: ...,
                                    parameters: ...,
                                    method: ...,
                                    body: ...)
      // 取得したData型をObjectA型に変換(*ObjectAはDecodableに準拠してるものとします)                      
      return JSONDecoder().decode(ObjectA.self, from: data)

   }
}

```  
上記の実装を[変更前の実装](#Data層がBusinessLogic層に依存した実装)と比較すると、変更前にはObejctA専用のDataClientとして定義されていた`ObjectADataClientType`が`WebAPIClientType`に置き換わり、DataClientが抽象化され汎用性を持っているのがわかります。      
またRepositoryの実装においても、変更前にはData Clientからデータを垂れ流すだけであったのに対し、今回はRepository側で取得したいデータを`WebAPIClientType`メソッドのパラメータとして指定した上で、その出力データをDomainオブジェクトに変換する役割を担っています。    

#### Infra層とBusiness Logic層を切り離した設計図
次に先ほどData層が肥大化してしまった[ObjectA〜Zまでの26のオブジェクトをRepositoryで操作するプログラム例](#Data層が肥大化する)に、2点の変更を適用してみましょう。  
変更を適用した設計図を以下に示します。    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/Data層とBusinessLogicが切り離されている設計.png" alt="Data層とBusiness Logicが切り離されている設計" width=65%>  

[変更前の設計図](#Data層がBusinessLogic層に依存した設計図)と比べると、Data ClientがBusiness Logic層から独立することで、Data Clientコンポーネントが一つに集約され、全体のコンポーネント数が大きく減ったのがわかります。  
もちろん、変更後の設計でもWebAPIやデータベース等データアクセス機構毎にData Clientを定義・実装する必要はありますが、それは各機構毎にインターフェースが異なることを考えれば致し方ありません。    

Data層はそのBusiness Logicから独立するように設計しましょう。  
そうすることで関心の分離が保たれて、Data層の肥大化が避けられます。  

```
補足:
データクライアントでの出力は基本Data型と述べましたが、設計次第ではDomainやApplicationオブジェクトを出力することも可能です。  
例えば以下のようにジェネリクスを利用して指定した型をデータクライアントが出力できる設計です。  
この場合、型変換の責務はあくまで呼び出す側であるリポジトリにあり、データクライアントはDomain/Applicationから独立しているため問題ありません。    


//パラメーターは本来のURLリクエストよりも簡略化させています。
protocol WebAPIClientType {
   func request<Object: Decodable>(url: URL,
                                   headers: [String: String],
                                   parameters: [String: String],
                                   method: HTTPMethod,
                                   body: Data?) -> Object
}

class WebAPIClient: ObjectADataClientType {

   func request<Object: Decodable>(url: URL,
                                   headers: [String: String],
                                   parameters: [String: String],
                                   method: HTTPMethod,
                                   body: Data?) -> Object {
      ...
   }
}



```

## レイヤードアーキテクチャ+クリーンアーキテクチャ+@で設計についてまとめる
前回の論考から、レイヤードアーキテクチャとクリーンアーキテクチャを通して設計というものをみてきました。  
ここでは、これまでの内容と+@を踏まえて設計を考えるとはどういうことであるのか総括したいと思います。  

### 1&#46;設計とは関係を構築することである
これは前回の論考で説明しました。  
アプリケーション設計とはアプリケーション内の関係を構築することであり、良い設計を考えるとはこの関係を開発者にとって作業しやすいように構築することです。    

### 2&#46;責務によって分割し、それらを単純な依存関係により組み合わせる
そうした開発しやすい関係の構築のために、レイヤードアーキテクチャではアプリケーションプログラムを責務によって層に分割し、それらが単一方向に依存するよう定義しました。  
プログラムを責務によって分割し、それらが単純な関係になるよう連携させることで、開発者はアプリケーションを特定の目的を持ったプログラムの集合体として捉えます。    
このように責務の関連性が高いコードをまとめられた状態を「高凝集」、関連性の低い(ない)コードが分離させられた状態を「疎結合」といい、これによりプログラマは自身が担当している責務に関連したコードのみに集中して開発を行うことができます。(関心の分離)
### 3&#46;データフローは一方向 
データフローが一方向になっていることでプログラムの流れを追いやすくなり、コードの可読性が上がります。  
### 4&#46;開発事情を考慮する
本論ではクリーンアーキテクチャについて説明してきましたが、それを要約すると**クリーンアーキテクチャは実際の開発事情を踏まえてレイヤードアーキテクチャを再構築したもの**であるということです。  
クリーンアーキテクチャはサービス仕様に該当するビジネスロジックをプログラムの中心に置くことで、サービスの変化に柔軟に対応できるようにしています。    

レイヤードアーキテクチャはプログラムの構造を論理的に洗練させたものでした。  
クリーンアーキテクチャは、レイヤードアーキテクチャの構造を基盤としながら、実際の開発事情を考慮して再構築した設計理論です。  

### 5&#46;データフローの蓄積による状態変化に考慮する
設計についてまとめるに当たり、1~4の内容に加えてあと一つ考慮しなければいけない点があると思います。  
それは**データフローの蓄積**です。  
ここまでの設計に関する話ではデータフローについては深く取り上げず、入力から出力までのデータの流れにだけ着目して設計の話をしていました。  
しかし実際のアプリケーションはいくつものデータフローの積み重ねによって成立しており、設計の際にもそれらのデータフローの蓄積を踏まえることは重要になります。        

私たちの身近なところでこれを実践しているのはFlux、Reduxでしょう。    
FluxやReduxといったアーキテクチャではActionとStore(State)コンポーネントを利用することで、データフローの蓄積によって生成される状態の管理を可能にしています。    

一般的にも理論を構築する際には、**フロー**だけでなくその**蓄積**を踏まえるのが妥当です。    
例えば、経済学では経済的事象を一定期間の経済活動を指すフローとフローの蓄積を表すストックという二つの視点から説明しています。[<sup>*8</sup>](#footnote8)     

それにも拘らず、クリーンアーキテクチャにおいてデータフローの蓄積の視点が取り入れられていない原因は、恐らくクリーンアーキテクチャ提唱時(2012年)の開発環境にあったと思います。    
クリーンアーキテクチャ登場時には、Web・モバイルアプリケーションの規模やハードウェア(特にモバイル)のメモリの容量も今ほど大きくなかったため、状態の管理はアプリケーションレベルで考えるものではなく画面単位もしくは局所的に行うのが基本だったのではないかと推測しています。(またWebにおいて画面単位の設計を超えたSPAのアプリ設計が主流になり始めた時期とクリーンアーキテクチャが提唱された時期は重なっており、クリーンアーキテクチャではSPAの設計は考慮されなかったと思われます。)      
しかし現代的なアプリケーションは規模が当時と比べて非常に大きく、多くのデータフローが行き交っており、そうした個々のデータフローを俯瞰して捉える視点はプログラムの品質を大きく向上させます。  
そのため本論では、データフローの蓄積も踏まえてアプリケーション設計を考えていきます。  

### アプリケーション設計とは
設計に関する要点を5点述べました。  
以上の内容を踏まえるとアプリケーション設計は(1) **関係の構築であり**、具体的には(3)**一方向のデータフロー**、(4)**開発事情**、(5)**データフローの蓄積**を考慮しながら、(2)**責務による分割とそれらの関係の構築**をアプリケーションのマクロからミクロに至るまで繰り返すことだと言えます。  
この作業を繰り返すことで、アプリケーションは層(レイヤー)->モジュール->コンポーネントと粒度を細かくしていき、細部にまで配慮が行き届いた開発しやすいプログラムになっていきます。    

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/アプリケーション設計.png" alt="アプリケーション設計" width=100%>  

### スケールしやすいアーキテクチャ
アプリケーション設計が具体的にどのような作業であるか説明しましたが、本論が目指す「スケールのしやすい」アーキテクチャとは一体なんなのでしょうか。  
[先程の説明](#アプリケーション設計とは)」に沿うならば、それはアプリケーションの枠組み(つまり層・モジュール)においてできる限り破壊的な変更を起こすことなく開発を続けられるようなアプリケーションプログラム構造であると言えます。      
長期的なプロジェクトであればなにから何まで当初の計画通りに開発が進むことはまずありえません。  
アプリケーションはどこかのタイミングで予測できない機能変更、機能追加によって既存のプログラムを変更(破壊)を迫られます。  
ただ、このようなアプリケーション機能の予測不可能性は、アプリケーションプログラムの基本的な性質を理解することを通して、ある程度プログラム構造においては予測の範疇に収めることが可能です。  
本論においてここまで学んだレイヤードアーキテクチャ、クリーンアーキテクチャの目的はまさに、そのようなプログラムの基本的な性質を理解し、変更に強いプログラム構造を構築することでした。  

継続的に開発を続けなければいけない中、アプリケーションの枠組みから設計し直すのは開発のコストだけではなく開発者の心理的に大きな負担にもなります。    
そのため効率的な開発を目指す上では、アプリケーションの枠組みにあたるレイヤー(層)・モジュールにおいて破壊的な変更が起こらないような設計が重要になってきます。  

この観点から言えば、ここまで論じられてきた内容はレイヤードアーキテクチャとクリーンアーキテクチャを通して**設計の概要**と同時に**アプリケーションのレイヤー(層)の構造**であると言えます。  
次章以降では、ここまでの知識を前提としながら、一般的にアプリケーションに求められるであろう機能とiOSの開発環境を照らし合わせてモジュールとコンポーネントの設計について考えていきます。  

> 補足:  
> 設計を学ぶ意義もこの「アプリケーションの枠組みにおいて破壊的な変更を起こすことなく開発を続けられるプログラム構造を構築すること」にあります。  
> しばしばプログラミングにおいて設計に熱中することは批判の対象となりますが、その理由のほとんどはMVVM/レイヤードアーキテクチャ/クリーンアーキテクチャ/Flux/Reduxといったアーキテクチャの形式に溺れてしまい、本来「手段」であるはずの種々のアーキテクチャを学ぶことが「目的」になってしまっているからだと思います。  
> しかし、これらのアーキテクチャを統合的に理解してアプリケーションプログラムを鮮明に捉えることができるようになれば、それはプログラミングをする上で大きな強みになります。  
> 確固とした設計理論を身につければ、自信を持ってプログラムの方針を決めることができますし、そのようにして構築されたプログラムでは破壊的な変更が起こらないため開発者は一段とコーディングに集中でき、ただ機能を実現するだけでなく質の伴ったアプリケーションを追求できます。    
  
## 本論のまとめ
- クリーンアーキテクチャとは技術的な依存によって成り立っていたレイヤードアーキテクチャの構造を、開発の実情を考慮して再構築した設計。
- アプリケーション設計とは、一方向のデータフロー・開発事情・データフローの蓄積を考慮しながら、プログラムを責務によって分割しそれらの関係を構築していく作業。 
- スケールしやすい設計とは枠組みにおいて破壊的な変更が起こらない(起こりにくい)アプリケーションプログラムの構造を指す。

## 補論1&#58;クリーンアーキテクチャの層とアプリケーションのディレクトリ構造は同じではない
クリーンアーキテクチャの層がそのままアプリケーションのディレクトリ構造になることは滅多にありません。  
Framework&Drivers層のUIとInfra、またInterface Adapters層のPresenter等UI側とRepository等Infra側は実際のアプリケーション開発では区別されます。    
その理由はクリーンアーキテクチャの層の構成がディレクトリ構造の目的と合致していないからです。  
ディレクトリ構造ではそのディレクトリにどのような責務のプログラムが置かれているかを具体的に示す必要がありますが、クリーンアーキテクチャではよりメタ視点から層を捉えています。  
例えばFramework&Drivers層はBusinessLogicに対する外部プログラムであることを意味しているだけであり、UIやInfra等のように具体的にどのような責務を担っているのか示しているわけではありません。     
そのためアーキテクチャとしてクリーンアーキテクチャを採用していても、アプリケーションのディレクトリ構造はレイヤードアーキテクチャの責務分割に沿ってなされているケースが多いと思います。        
こうした点からみるとクリーンアーキテクチャとレイヤードアーキテクチャでは層の分け方だけでなく、層を捉える視点の次元も異なっているのがわかります。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/クリーンアーキテクチャのディレクトリ構造.png" alt="MVCとクリーンアーキテクチャのディレクトリ構造" width=80%　>

## 補論2:クリーンアーキテクチャにおける層を跨ぐデータ構造がシンプルであるとは
本論において[層を跨ぐデータ構造はシンプルでなければならない](#ルール2層をまたぐオブジェクトはシンプルなデータ構造であること)と説明しました。  
ここではこの層を跨ぐデータ構造の「シンプルさ」についてもう少し論じたいと思います。     
### シンプルなデータ構造とは責務が漏出しないデータ構造
本論においても述べられた通り、データ構造がシンプルでなければならない理由は**層の責務が漏出させない**ことにあり、そのためトートロジーになりますが、ここで求められる「シンプルさ」とは責務が漏出しないデータ構造を指しています。  
以下では具体例を用いながら「責務を漏出させないシンプルなデータ構造」が実際のプログラムにおいてどのような意味を持っているのかを詳しく説明していきます。  

### 層を跨ぐデータ設計の例
ある写真アプリのプログラムにはユーザーを示すUser型と写真を示すPhoto型が定義され、ユーザーが所持する写真のタイトルをリストで表示する機能があるとします。            
User型とPhoto型はそれぞれ以下の通りです。(必要な箇所以外省略しています)  

```
struct User {
   struct ID { ... }
   let id: ID
   ...
}

struct Photo {
   let title: String
   ...
}
```
#### 層を跨ぐ2つのデータ型
この機能をクリーンアーキテクチャに沿って開発しようとするとControllerからユーザーの写真を取得するUseCaseを呼び出しその結果をPresenterに渡すという処理の流れになり、この場合、層を跨ぐデータはContrller->UseCaseとUseCase->Presenterの2箇所で発生します。  
このうちContrller->UseCaseで層を跨ぐのはUseCaseにパラメーターとして渡すデータです。  
一般的にこのパラメーターのデータ型はUserのID型となるでしょう。このパラメーターはどのUserの写真を取得するか識別するためだけに利用されるため、User型をそのまま渡す必要はなくUser.ID型で十分だからです。        
それに対してUseCase->Presenterで渡されるデータは恐らくPhotoの配列になると思います。こちらではPresenterで利用するのは写真のタイトル(Photo.title)だけですが、一般的にはPhotoごと配列で渡されます。  
そのためPresenterではUseCaseから渡されたPhotoの配列をPhoto.titleの配列へと変換します。            
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/層を跨ぐ2つのデータの非対称性.png" alt="層を跨ぐ2つのデータの非対称性" width=55%>  

こうして層を跨ぐこれら2つのデータを比較するとUseCase->Presenterのデータだけが余計な情報を持っていることがわかりますが、なぜUserCase->Presenterに渡すデータはUI側の要求に沿ってPhoto.titleではないのでしょうか。  
#### 層を跨ぐデータは共にUseCase層の設計
その理由は先程のUseCaseのコードを見てみるとわかります。(論旨とは関係ないため、コード例では非同期は考慮されていません。)          
```
class FetchUsersPhotosUseCase {
   func execute(userID: User.ID) -> [Photo] {
      ...
   }
}
```
先程の層を跨ぐ2つのデータはUseCaseメソッドのパラメータとその出力で、ともにUseCase(Application層)の設計の一部です。  
そして、この内メソッドのパラメーターに関してはUseCase自身の処理内容に応じてそのデータ型を無駄なく設計できるのに対して、自身の出力がPresenterからどういう目的で利用されるのかについてはUseCaseの設計の対象外であるため関知できません。  
そのため、今回の例のように、PresenterがUseCaseから受け取るデータ型は自身の要求に合致しているとは限らないわけです。(ただ合致していなくとも要求は満たしている必要があります)  

これは設計上致し方ないことです。  
もしUseCaseからPresenterに渡される全てのデータの無駄をなくそうとするならばUseCaseはUI側の仕様を把握する必要があり、クリーンアーキテクチャの外側の層の影響を受けないというルールを破ってしまうことになります。  
またそのように全てのUIの要求に合致するUseCaseメソッドを一つ一つ定義・実装しようとするならば、層を跨ぐデータは無駄なくあらゆる面でシンプルになるかもしれませんがUseCaseの数が膨大になりApplication層全体のプログラムは複雑化、肥大化していくでしょう。  

### 層を跨ぐデータをシンプルにする目的は関心の分離
層を跨ぐデータをシンプルにする目的は層同士の関心の分離です。  
そうした本来の目的を考えると、先の例で示したように、層を跨ぐデータに求められるシンプルさとは要求に対して一才無駄がないことではなく、責務が他の層に漏れてしまわないような構造を意味しているのがわかるのではないでしょうか。  


### 層を跨ぐデータ構造をどう設計するかはケースバイケース
先程はUseCase->PresenterでPhoto型の配列で渡しましたが、場合によっては以下のようにPhotoは各Userのプロパティとして生えており単体では利用しないということもあり得ると思います。    
その場合UseCase->Presenterの出力はPhotoの配列ではなくUser型になります。(その場合User.IDを引数にUserを取得するのはおかしいので全体の設計も変わるでしょう)  
このように他の層への出力データ形式はあらかじめ決まっているわけではなく、個々のプロダクトや設計者の判断によって変わります。    
```
struct User {
   struct ID { ... }
   let id: ID
   let photos: [Photo]
   ...
}
```


## 補論3&#58;Swiftのプロトコル
本文内でテストしやすくなるという理由で[依存方向関係なくプロトコルを用いて依存した方が良い](#依存の方向関係なくプロトコルは積極的に利用する)、と述べました。   
ここではそれについてもう少し説明します。    
### Protocol Oriented Programming(POP)
最初にProtocol Oriented Programming(以下POPと省略)の話から始めます。    
POPとは所謂プロトコル指向プログラミングを意味しています。  
Swiftを特徴づける概念でありiOS等Swiftを使っているプログラマーであればよく耳にする言葉なのではないでしょうか。        
しかしよく聞く言葉あるにもかかわらず、それが具体的に何を意味しているのかについてはあまり理解されていないように思います。    
POPはただ積極的にプロトコルを利用することを推奨している概念ではありません。  
Swiftで提唱されたPOPですが、Swiftのプロトコルに当たる言語機能は他の多くのプログラミング言語も既に持っています。  
そのためただ積極的にプロトコルを利用するという意味だけならば、なぜ他言語でも既にあった機能をわざわざPOPという大きな概念を用いて推奨しているのか十分に説明できません。[<sup>*9</sup>](#footnote9)  

### POPとはSwiftにおけるポリモーフィズム実現の手段
ではPOPとはどういう意味なのかというと、私は[このオンライン書籍](https://heart-of-swift.github.io/protocol-oriented-programming/)の説明がすごいわかりやすいと思います。  
該当箇所を簡単に説明するとPOPはOOP(Object Oriented Programming)と対置関係にある概念です。  
複数の型を同様に扱いたい等、型を抽象化したい(ポリモーフィズム)場合、OOPではクラスの継承によって実現していました。  
しかしSwiftはクラスではなく値型と言われる構造体や列挙型を積極的な利用を推奨しており、この値型には継承機能はありません。  
そのためSwiftではポリモーフィズムを実現する方法としてクラスの継承の代わりにプロトコルを提案しています。    
つまり、POPとはクラスではなく値型を主軸に考えるSwiftにおいて、プロトコルを利用してポリモーフィズムを実現するプログラミングスタイルを指しています。[<sup>*10</sup>](#footnote10)[<sup>*11</sup>](#footnote11)  

### 依存関係でプロトコルを利用する目的
そして依存関係においてプロトコルの利用をすることもPOPの一部であり、その目的は同様に型の抽象化です。    

その目的を具体的に示すと以下3点になると思います。  
1. 開発時、実体型を差し替えて実装を変更したい
2. テストを行いたい
3. プログラム実行中、多義的な役割を担わせたい

このうち1と2は概念的に関心の分離を意味しており、技術的にも同義です。      
差し替えるコンポーネントが本番用なら1、テスト用なら2になるわけですが、これらは概念的、技術的には同義でも開発の文脈では役割が異なるため別個に表記しています。    
本記事で紹介したプロトコルの利用方法もこの1と2です。  
  
3に関しては本記事では触れられていません。
しかし一般的に私たちがプロトコルを使う理由で一番多いのはこの3ではないでしょうか。  
このケースに当てはまる例は例えば、犬、猫、鳥、等複数の異なる実体型を動物型のように一つの型として利用したい場合です。  
このように複数の型に共通の性質・振る舞いを持たせたい場合にはプロトコルを適用することで実現できます。  
```
// 犬も猫も鳥も同じ動物としてプログラミングで扱いたい

protocol Animal {}

struct Dog: Animal {}

struct Cat: Animal {}

struct Bird: Animal {}

struct Person {
   // Animal型であるpetにはDog,Cat,Bird型のどのデータも代入できる
   let pet: Animal 
}
```

### 依存関係でプロトコルを利用しない場合
逆にいうと上記に該当しない場合の依存関係においてプロトコルを利用しても意味がありません。  
むしろ必要のないプロトコルを定義し、利用することでプログラムの意図が曖昧になって可読性が落ちてしまいますし、パフォーマンスにも悪影響なので利用しない方が良いでしょう。  
具体的にプロトコルを利用する必要のないケースとして以下2点が挙げられると思います。    
- 各層のデータオブジェクト
- Domain層のオブジェクト  

ただ先ほど挙げた[依存関係でプロトコルを利用する目的](#依存関係でプロトコルを利用する目的)の
>3. プログラム実行中、多義的な役割を担わせたい  

に該当するならば上記のケースでもプロトコルは必要です。  

ちなみにここでのデータオブジェクトとは振る舞い(メソッド)を持たないオブジェクトを指しています。    

以下それぞれの詳細を説明します。  
#### 各層のデータオブジェクト
依存関係においてプロトコルを利用する主な目的は**層の関心分離**と**コンポーネントの差し替えを容易にする**ことです。  
しかしクリーンアーキテクチャの思想に沿って設計している限り、外から内への依存はなく、また基本的にFrameworks&Drivers層とBusinness Logic(Domain/Application)層のデータオブジェクトはそれぞれInterface Adapters層において遷移先のデータ形式に変更されます。  
そのためデータオブジェクトを具象型として利用しても特に関心の分離が破られることはありません。             
また同時にデータオブジェクトは振る舞いを持っていないためプロトコルを用いた差し替えもする必要もなく、実装を変更したい時には具象型のコードをそのまま書き換えて問題ないでしょう。  
  
例えば以下のようなPhoto型を利用してテストを行いたい場合は値にテスト用のものを代入すれば十分であり、わざわざプロトコルを利用して具象型を差し替える必要はありません。  

```
struct Photo {
    
    let id: String
    let createdAt: Date
    let width: Int
    let height: Int
    let description: String?
    let urls: PhotoImageUrls
    let altDescription: String?
    let likes: Int
    let likedByUser: Bool
    let user: User
    
}
```


#### Domain層オブジェクト
一般的にDomain層では全てのオブジェクトでプロトコルを利用する必要はありません。  
その理由を端的に表現するのは少し難しいのですが、以下3つを要点として挙げます。    
- Domainは円の中心にあり外側の層から依存されない
- Domainは他の本番用コンポーネントと差し替える必要はない
- Domainをテストコンポーネントとして利用しない

##### Domainは円の中心にあり外側の層から依存されない
Domainは円の中心にあるため外層からしか依存されず、プロトコルを利用しなくともクリーンアーキテクチャの依存ルールを破る恐れはありません。  

##### Domainは他の本番用コンポーネントと差し替える必要はない
一般的に本番用で具象型を差し替える必要があるコンポーネントは外部技術を利用しています。  
「機能は変更しないけど、他の外部技術を利用して実現したい」という場合にプロトコルを使うことで自身に依存しているコンポーネントに影響を与えずにプログラムを変更することができるわけです。      
ただDomainは外部技術には依存せず、純粋なプログラミング言語でのみ実装しているため、コンポーネントを差し替えて実装の変更を行う意味が特にありません。  
言い換えると、純粋なプログラミング言語で規定されるDomainオブジェクトを差し替えたい場合、それは何らかのDomainルールの変更を含んでいるはずです。  
そのため、Domain実装の変更を行いたい場合はプロトコルによる抽象化など行わず、具象型をそのまま書き換えれば良いと思います。 

##### Domainをテストコンポーネントとして利用しない
Domainに関連してテストを行うコンポーネントとしてUseCaseとUI(Presenter)が想定されますが、その両者のテストにおいてDomainをテストコンポーネントとして利用する必要はありません。  
###### UseCaseのテスト
UseCaseはその性質から自身のテストを行う必要は基本的にはありません。  
クリーンアーキテクチャのUseCaseの説明を見てみるとそのことがよくわかると思います。  

>These use cases orchestrate the flow of data to and from the entities, and direct those entities to use their enterprise wide business rules to achieve the goals of the use case.
>
>意訳  
>UseCaseはEntityを組み合わせて自身の目的を達成する  

上記の説明にある通りUseCaseの役割は他コンポーネントを組み合わせることであり自身は複雑なロジックを抱えていません。      
そのためUseCase自身のテストの必要性は低く、テスト用Domainオブジェクトを準備する必要もないと考えられます。        
```
補足:  
UseCaseによっては特有の事情によってテストを行いたいという場合もあるかもしれません。  
ただその場合もDomainコンポーネントをわざわざテスト用に差し替える必要はないでしょう。  
```


###### UI側のテスト
通常UIテストを行いたい場合はPresenterをテストコンポーネントに差し替えれば十分なはずですが、中にはPresenterのテストするためにBusiness Logicのテストコンポーネントが必要だという場合があると思います。  
しかしこの場合もUseCaseをテストコンポーネントに差し替えるだけでUI側の要件は達成できるため、Domainのテストコンポーネントまで準備する必要はありません。    


```
// お会計の表示のレイアウトが期待通りになっているか確認したい

protocol CalculateTheBillUseCaseType {
   func execute(items: [Item]) -> Int
}

// テスト用のUseCaseコンポーネントを作りたい場合、
// テストしたい値をUseCase自身で生成すれば良いのでDomain用のテストコンポーネントまで作成する意味はない
class TestCalculateTheBillUseCase: CalculateTheBillUseCaseType {
   func execute(items: [Item]) -> Int {
      return 15000
   }
}


class BillingPresenter {
   let calculateTheBill: CalculateTheBillUseCaseType
   ...
}

```

```
補足:  
他にも外部技術は利用していないけどDomainが抱えているロジックが複雑、等の理由でプロトコルを利用したいという場合もあるかもしれません。    
ただ私は最初に挙げた「実行時に多義的な役割を担わせたい」という理由を除いてDomainではプロトコルを利用すべきではないと考えています。  
Domainはクリーンアーキテクチャの円の中心であるようにアプリケーションプログラムの核となる部分です。  
そのようなアプリケーションの屋台骨となるロジックやデータを扱うオブジェクトをプロトコル型を使って抽象化するということは  
プログラムの核心部分の設計が定まっていないということであり、プログラムとして不健全だと思います。  
人で例えるなら素晴らしい信念を掲げつつも、その内実は全く定まっておらず時代や状況に応じて都合よくその内容を変えていっているような感じでしょうか。  
私はDomainの実装が定まっていないのならば、プロトコルで抽象化してしまうのではなく自信のあるものできるまで向き合うべきだと考えます。  
```

### 補論3の補論:「型としてのProtocol」よりも「制約としてのProtocol」を優先する
補論から少し話が逸れてしまいますが、プロトコルを用いたプログラミングの重要な指針となるため取り上げます。  
補論3でHeart of Swiftという書籍を紹介しましたが、その[Protocolの章](https://heart-of-swift.github.io/protocol-oriented-programming/)の要約の一つとして以下の一文があります。  
> プロトコルを「型として」ではなく「制約として」使用することを優先する  

これは技術的に言い変えると、「プロトコルは型よりもジェネリクス(ジェネリクス型、Protocolのassociatedtype、Opaque Result Type)で使用しよう」という主張となりますが、どうしてプロトコルを型よりも制約として使用するべきなのでしょうか。  
#### 制約としてProtocoを使用するとパフォーマンスが向上する
それは簡単にいえばプロトコルを制約として使用することで用途が限定されるためコンパイル時に最適化が図られ、パフォーマンスが向上するからです。  
##### 「型としてのProtocol」と「制約としてのProtocol」の例
例えばProductというProtocol型があると想定してください。  
```
protocol Product {
   ///...
}
```
その場合、以下のようにProductを型のように使用した場合メソッドを定義すると、コンパイルでは「いかなる(Any)Product型も引数として受け取るメソッド」と解釈されます。      
```
func buy(product: Product) { //... }
```
それに対して、Protocolをジェネリクス型の制約としてメソッドを定義すると、コンパイルでは「ある(Some)Product型も引数として受け取るメソッド」と解釈されます。      
```
func buy<P: Product>(product: P) { //... }

```
つまり、人間からしたら違いがよくわからない上記2つのメソッドですが、機械であるコンパイラにおいては後者のPを「Productプロトコルに準拠した特定の具象型」と判断し、実際にプログラム上でその箇所においてどのような型が使用されているか特定した上で最適化を行うため、前者(型としてのプロトコル)において発生するような抽象化によるオーバーヘッドを回避することができます。(これは最適化の一種で特殊化という技術です。詳しくは[先程のHeart of Swift](https://heart-of-swift.github.io/protocol-oriented-programming/)をお読みください。)  

#### プロトコル使用法の優先度をつけることで、コードの意図が明確に
またこうしてパフォーマンスの観点からプロトコルの用法に優先度をつけることで、両者のプログラムの意図も明確になります。  
制約としてプロトコルを使用した方がパフォーマンスは優れる、それが開発において共有されたプロダクトにも拘らず型としてプロトコルを使用されているということはその箇所で何かしら柔軟性を重視しなければいけない事情を示唆しています。(先ほども示した通り、型としてのプロトコルは「Some」ではなく「Any」扱いとなり、パフォーマンスのアドバンテージを失う代わりに、より柔軟なプログラムが可能にします。こちらも詳しくは[書籍](https://heart-of-swift.github.io/protocol-oriented-programming/protocols-as-types-or-constraints)の方をお読みください。)  


## 補論4&#58;Repository
ここではRepositoryに関していくつか説明します。  
### Repositoryのプロトコル&#40;インターフェース&#41;はDomain層&#12289;実体型はData層
Repositoryは一般的にWebAPI、データベースを利用しますが、それらは内部実装の話でありインターフェース上では意識されません。  
そのため定義上においてはRepositoryはただDomainオブジェクトを操作するコンポーネントであり、プロトコル上はDomain層に属することになります。  
それに対して実体型のRepositoryはその実装においてWebAPIやデータベースを利用するため、Data層に分類されます。  

### なぜRepositoryとData Clientの出力が異なる場合があるのか
記事内の[Repositoryの設計に関する誤解](#Data層が肥大化する)を説明した箇所で、
>対応するリポジトリとデータクライアントの出力する値は必ずしも同じではない  

と書きましたが、なぜこのようなことが起こるのでしょうか?
  
その理由は詰まるところ、Domainとデータベースの設計の違いにあります。    
Domain層のオブジェクトを設計する際、私たちは純粋にそのサービスの観点からデータをどのような単位で扱い、またそれぞれをどのように関連させるかを考えます。    
それに対して、データベースの設計ではサービスの観点に加えてパフォーマンス等データベース特有の事情も考える必要があります。      
そのため実体としては同じデータを扱っているのにも拘らず、Domainとデータベースで扱う単位が異なるケースが発生します。    

リポジトリとデータクライアントの出力する値が異なるのも同じ理由です。  
両者は設計の視点が異なるため必ずしも出力が一対一で対応していることにはならず、場合によってはRepositoryの出力値を取得するため複数のWebAPIを利用する等の必要があります。  

### RepositoryとDAO 
DAOとはData Access Object略であり、技術的な詳細を内部実装として隠蔽しながらデータを操作を行うコンポーネントを指しています。  
Repositoryも同様に詳細を隠蔽しながらデータを操作するコンポーネントです。  
この意味でDAOとRepositoryは同じ役割を担っているのですが、以下2点の理由により、設計におけるRepositoryとDAOは異なります。      　    
- RepositoryはDomainオブジェクトを操作対象としているのに対して、DAOはデータ全般を操作対象としている
- RepositoryはDomain層とData層を切り離すことを目的としていてアプリケーションの層を意識したコンポーネントであるのに対して、DAOはデータ操作とそのメカニズムを切り離すことを目的としておりアプリケーションの層は意識していない  

もちろん実際の開発ではDAOを利用することで「データ操作とそのメカニズムを切り離す」と同時に「層も切り離す」こともあり得ます。  
ただ少なくとも概念上のDAOの関心は「データ操作の技術」であり、「アプリケーションの層分離」ではありません。  

また、そもそもRepositoryはアーキテクチャ設計、DAOはデザインパターンと、それぞれが登場する文脈が違います。  
そのため、両者は機能的に似ていますが(もしく同じ)、異なる目的で利用されます。  

これは言い換えると、RepositoryとDAOが共存できることを意味しています。  
例えば、先ほどの[Repositoryとデータクライアントの出力で異なる場合があるのか](#Repositoryとデータクライアントの出力で異なる場合があるのか)では、Repositoryの出力値を取得するために複数のWebAPIを利用する場合があると述べましたが、この時にRepository内でDAOを利用して複数のデータ操作し、最終的に一つのDomainオブジェクトを操作するということがありえます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/RepositoryとDAOの共存.png" alt="RepositoryとDAOの共存" width=65%>  
実際、[Androidの公式ドキュメント](https://developer.android.com/jetpack/guide?hl=ja#addendum)ではRepository内でDAOを使っています。  

### DAOはInterface Adapters層 
ちなみにDAOをクリーンアーキテクチャで利用した場合は、Data層ではなくInterface Adapters層に属することになると思います。(Domainオブジェクトの操作はRepositoryで行っていて、Domainオブジェクト以外のデータ操作をDAOで行なっていると仮定した場合)    
その理由は[本文「Repositoryに関する誤解」](#Data層でDomainオブジェクト型のデータを返すのは誤り)で述べた通り、Data層はアプリケーション特有の事情から独立しているべきだからです。  
RepositoryでDomainオブジェクトの操作を行なっているならばDAOで操作するデータオブジェクトはDomain層とは異なりますが、それでもそのオブジェクトは間接的にせよアプリケーションサービスと関係しています。  
そのためDAOはData層ではなくInterfaceAdapters層の扱いになるべきだと思います。[<sup>*12</sup>](#footnote12)  
ただ[補論冒頭](#RepositoryのプロトコルインターフェースはDomain層実体型はData層)で述べたRepositoryと同様、概念上はData層に当たらなくとも実体型ではWebAPIやデータベースを利用するためData層に含まれます。[<sup>*13</sup>](#footnote13)  


## 補論5: データフローの蓄積の視点をアプリケーションレベルで設計に取り入れる
ここでは[本記事](#5データフローの蓄積による状態変化に考慮する)内で触れたデータフローの蓄積を踏まえた設計について、それがアプリケーションへ与える影響をもう少し詳しく説明します。    

### データフローの蓄積の視点を取り入れるメリット
私はデータフローの蓄積の視点をアプリケーションレベルで設計に取り入れることによるメリットは具体的に以下2点だと思います。        
1. 複数画面での状態の共有が容易になる
2. アプリケーション全体のデータフローがシンプルになる
  
#### 複数画面での状態の共有が容易になる
これはFluxやReduxを知っている人ならすぐにイメージできるのでないでしょうか。  
状態を画面毎に管理するような設計では複数画面において状態を共有するために画面間でデータの受け渡しを行う必要があります。  
それに対して、FluxやReduxのようにアプリケーションレベルで状態管理を行なっている場合には、画面間でデータの受け渡しを行わずとも各画面からApplication層で管理している状態にアクセスすれば良いため状態の共有が容易です。            
そして、こうした複数画面における状態共有の容易化は、ローカル上の最新状態を画面に反映できるようになるためUXが向上、データフローの集約化にも繋がっていきます。[<sup>*14</sup>](#footnote14)   
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/複数の画面で状態を共有する.png" alt="複数の画面で状態を共有する" width=55%>  
[<sup>*15</sup>](#footnote15)  
もちろんこうしたApplication層を利用した状態管理は特定データに対してのみ局所的に行うことも可能です。    
しかしアプリケーションレベルで行うことで全体のデータフローの整合性は高くなり、既存のデータを複数画面で共有する等の仕様の変更にも対応しやすくなります。  

#### アプリケーション全体のデータフローがシンプルになる
また、データフローの蓄積を考慮して設計することで、煩雑なデータフローも回避できるようになります。  
ここでは「ページネーションのあるデータの取得」の機能を例にとり、データフローについて考えていきます。  
##### 画面毎に状態を管理する場合
もし画面毎に状態を管理する設計であった場合、その取得するデータとページネーションの管理はUI側であるPresenterの責務になります。      

それによって発生するPresenterの処理は命令的プログラミングで実装すればそこまで複雑にはならないと思います。    
ただ、先の例で見たようにその状態を複数画面で共有しようとすれば、画面間でページ情報とデータの受け渡しを行う必要がありますし、またそもそも概念的にはページネーションとデータの管理はApplication層、もしくはBusiness Logicの責務であるため、それをPresenter側で処理することで本来よりもデータフローが複雑になってしまうことは間違いありません。[<sup>*16</sup>](#footnote16)  
また、RxSwift等、個々のデータフローを明確に区別するリアクティブプログラミングで実装しようとした場合にはさらに複雑なデータフローとなってしまいます。  

##### アプリケーションレベルで状態を管理する場合
もしこの機能をアプリケーションレベルからデータフローの蓄積も考慮して設計したならば、上記で述べたデータとページングの管理はApplication層で行うことになります。[<sup>*17</sup>](#footnote17)     
そうなるとPresenterでのデータとページングの管理や複数画面で共有する際の画面間でのデータの受け渡しも必要なくなるため、この機能に関する全体のデータフローの複雑さは軽減されます。  
そしてその結果、Presenterは本来の「Business Logicへの処理命令とBusiness LogicデータをUI用に変換する」の責務を担う機構へと純化されることになります。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/データフローがシンプルになる.png" alt="データフローがシンプルになる" width=60%>  

##### データフローの蓄積も考慮するということは、より俯瞰的な視点からアプリケーションを捉えること
当たり前ですが、データフローの蓄積も考慮するということは、より俯瞰的な視点からデータフローの設計を行うということです。  
そのためそれまで別個に扱っていたデータフローが集約される箇所が少なからず出てきます。　　  

上で紹介した例はサンプルプロジェクトで遭遇したケースを簡略化したもので、実際にはPresenter(サンプルプロジェクトではViewModel)は複数の経路からデータを取得し、さらにプルリフレッシュ、追加取得等、より複雑なロジックを抱えていました。  
しかしその後、データとページネーションの管理をApplication層側に委譲することで、Presenterの複雑さを解決できました。  

また他にもReduxのようにStoreにデータフローを集約させ、複数の画面がStateによって状態を共有するといった機構も、このデータフローの蓄積の視点をより発展させたモノだと考えることができます。    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter2(クリーンアーキテクチャ)/Images/Reduxのデータフロー.png" alt="Reduxのデータフロー" width=60%>  

### データフローの蓄積の視点を取り入れるデメリット
最後に設計にデータフローの蓄積の視点を取り入れる際のデメリットについて記します。          
これはやはり設計のコストが高くなってしまうことだと思います。    
恐らくデータフローの蓄積の視点を設計に取り入れる一番身近な方法はFlux・Reduxといった既存のアーキテクチャの採用ですが、その場合でさえそれぞれのアプリケーションサービスの要件に合わせて自身で設計を考えなくてはいけない箇所が出てくるはずです。(さらにアーキテクチャに対する理解をチームで共有する必要もあります。)  

設計にデータフローの蓄積の視点を取り入れるということはアプリケーションの個々のデータフローをまとめ上げることを意味しています。  
そのため個々のデータフローにのみ着目する場合に比べて設計コストが高くなってしまうのはある程度致し方ないことです。    

しかしその反面、一度汎用性のある設計が出来上がると、長期のプロジェクトにおいても一貫性を保ちながら開発を続けることができるため開発効率は大きく上がります。  
なのでスケールしやすいアーキテクチャを考える本記事では、この視点を踏まえながら設計を考えていきます。  

  
## 参考文献：  

### 書籍  
- [ドメイン駆動設計](https://www.amazon.co.jp/エリック・エヴァンスのドメイン駆動設計-Architects’Archive-ソフトウェア開発の実践-エリック・エヴァンス/dp/4798121967/ref=asc_df_4798121967/?tag=jpgo-22&linkCode=df0&hvadid=295719984664&hvpos=&hvnetw=g&hvrand=3926308388276309968&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=1009283&hvtargid=pla-525481409888&psc=1&th=1&psc=1)  

### Web
- [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)([日本語訳](https://blog.tai2.net/the_clean_architecture.html))
- [Repositoryの定義](https://martinfowler.com/eaaCatalog/repository.html)
- [VIPER](https://cheesecakelabs.com/blog/ios-project-architecture-using-viper/)
- [リポジトリとDAOの棲み分け方](https://blog.fukuchiharuki.me/entry/use-repository-and-dao-according-to-the-purpose)
- [Android公式アーキテクチャガイド](https://developer.android.com/jetpack/guide?hl=ja#addendum)
- [まだMVC,MVP,MVVMで消耗してるの？ iOS Clean Architectureについて](https://qiita.com/koutalou/items/07a4f9cf51a2d13e4cdc)
- [Heart of Swift](https://heart-of-swift.github.io/protocol-oriented-programming/)


## 注釈
<a name="footnote1">*1</a>: ここでいう「変更」はアプリケーションの仕様変更によるプログラムの変更であり、リファクタリングによるプログラムの変更は含んでいません。  
<a name="footnote2">*2</a>: 既存のビジネスルールの詳細を変更した場合も、大抵の場合その旨をユーザーに通知するためUI上にも何かしらの変更が行われるはずです。  
<a name="footnote3">*3</a>: 極めて抽象的に考えるとサービスは技術による影響を受けており、その意味でBusiness Logicはサービスの影響のみ受け、技術の影響を受けないというのは違和感を持つ人がいるかもしれません。しかしここで技術の変更というのは、既存の技術的枠組みは同様のままディティールによる変更を指しています。例えばデータの管理をデータベースからWebAPIへ変更するいった場合です。そのため、その枠組み自体が変わるような技術革新をここでは想定していません。ただ、クリーンアーキテクチャによる設計の視点から言えば、そうした技術革新があった場合も、まずサービス仕様が変更され、追随する形で技術仕様が変更されると捉えるべきでしょう。  

<a name="footnote4">*4</a>: UIとInfraを同様に扱う、これは前回の論考で説明したPDSのプレゼンテーションと同じ考え方です。  
<a name="footnote5">*5</a>: この項冒頭の、Framework&Driversが外部技術であるという説明とFramework&Driversは外部技術に依存しているという定義は一見矛盾しているように思われますが、視点が異なっているだけです。UIKitを例に出すと、UIKitは内部でApple独自のレンダリング技術を使っているため外部技術に依存しているわけですが、他の層から見るとまさにそのUIKit自身が外部技術なわけです。  
<a name="footnote6">*6</a>: こうした境界が曖昧な責務は基本的に妥協の末に利用する側(この例ではDomainがInfraを利用するのでDomain層)に実装されるようになります。  

<a name="footnote7">*7</a>: wikipediaで[システムアーキテクチャ](https://en.wikipedia.org/wiki/Systems_architecture)を調べると様々な定義がされているとようですが、概要としてはここで示した意味で間違っていないはずです。  

<a name="footnote8">*8</a>: ここでは層の責務を、その層がするべき仕事(Do)と定義しています。そのため、ある層のオブジェクトが他の層に渡されることで層の知識(What)が漏出してるとは言えますが、層の責務(Do)が漏出したとはみなしていません。アプリケーションとして動くためには各層の連携は不可欠なため、層間のデータ(知識)の移動さえ責務の漏出とみなす考え方は現実的ではありません。  

<a name="footnote9">*9</a>: 実際には依存関係についても示している図なのですが、ここではデータフローについてのみ触れています。  
<a name="footnote10">*10</a>: ここではUIKitを使用することを前提としています。もちろん現在ではSwift UIを採用してUIKit(ViewController)自体を使用しないという手段もあります。
<a name="footnote11">*11</a>: UIKit(外部技術)に依存したViewControllerをInterface Adapters層として扱うのはMVCにクリーンアーキテクチャを取り入れることを前提としている場合です。現実的に新しくアプリ設計をする場合には、MVCではなくMVVMを採用してInterface Adapters層にViewModelを置き、ViewControllerはUI層として扱う等といった方法をとるのが妥当であると思います。


<a name="footnote12">*12</a>: 他にも言語学の用語である「共時」「通時」という概念は人文系全般でよく利用されています。  
<a name="footnote9">*9</a>:  個人や小さな組織が提唱しているのであれば、ただ流行らしたい(バズる！！！)等の理由で概念化している可能性もあると思います。しかしAppleのようなパブリックな影響力のある企業がそのような単純な理由で新しい技術的概念を提唱することは考えづらいと思います。 

<a name="footnote10">*10</a>: ただ一方で、Swiftは構造体で積極的に定義していくプログラミング言語ではありますが、結果的にクラスで定義するコンポーネントの方が数が多くなることもあり得ます。     
<a name="footnote11">*11</a>: 参考元ではSwiftの公式ドキュメントには何がProtocol-oriented Programming なのか明確には述べられていないと書かれており解釈の一つとして紹介されていますが、POPがOOPを意識して生まれた概念であることはその名前からも明らかでありPOPの概要がここで記した意味であることは間違いないと思います。  
<a name="footnote12">*12</a>: レイヤードアーキテクチャでいえば、DAOはBusiness Logic(Application or Domain)ということになるでしょう。ただ直接的にDomainと関わるRepositoryと間接的にDomainに関わるDAOでプロジェクト内で区別する必要はあるでしょう。  
<a name="footnote13">*13</a>: 本文で述べた通りData層は固有のアプリケーションからは独立している。しかしRepositoryやDAOの実装はData層である。これはつまりData層にはアプリケーションから独立した真性のData層とアプリケーション要件と交わるData(Application/Domain)層が存在することになります。後者に関してはあくまで「アプリケーションサービスに関わる」という性質に重きが置かれると思うのでApplication/Domain(Data)層と表現した方が良いかもしれません。  
<a name="footnote14">*14</a>: 厳密に言えばFluxやReduxのように最新状態を即時共有するためにはObserverパターンが必要ですが、それでもその根底にデータフローの蓄積を考慮する視点があることは変わりません。  
<a name="footnote15">*15</a>: 仕様によってはアプリケーションレベルで状態管理を行なっても、状態を共有するために識別子となるIDに当たるデータを画面間で受け渡す必要があります。しかしその場合も共有したい情報を直接受け渡すよりは容易なはずです。 

<a name="footnote16">*16</a>:「ページネーションとデータの管理」はView(Presenter)側の責務で良いのでは、と思う方もいると思います。しかしPresenterはそもそもBusiness Logicのデータ形式をViewの形式に変換する等、Business Logic層とView層の狭間にある簡易的なロジックを責務としている層であり、今回のようなデータとページネーションの管理はPresenterの責務の範囲外であるように思われます。また今回の例のように「ページネーション付きのデータの管理」は特定画面(View)に限定されないケースもあり、そうなるとやはり本質的にはBusiness Logic側の責務として扱った方が適切であると考えています。  

<a name="footnote17">*17</a>: ここではモバイルアプリの一般的な仕様を前提としています。モバイルアプリの場合ページネーションはスクロールと連携して実装されることが多く、ページは1ページ目から2ページ目、2ページ目から3ページ目と連続して変化していくため(プルリフレッシュを除く)、Applcaition層側でページを管理しているならばPresenter側で管理する必要はありません。しかしWebアプリの場合はページの変化は非連続的で、さらに各画面は特定ページのデータのみ表示するためPresenter側でページの管理を行う必要があると思います。  

