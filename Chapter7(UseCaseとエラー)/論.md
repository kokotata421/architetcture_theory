
## 補論4&#58;Application層のインターフェースに求められる具体性
ここでは本論で述べた「Application層の主な役割は、そのアプリケーションが提供するサービスを**具体的**に示すこと」について詳しく論じたいと思います。  
### 具体性を求められているのはApplication層の「インターフェース」
まず前提として注意しておきたいのが、ここで求められているのはApplication層の具体性というよりもその「インターフェース」の具体性です。  
本論では「Application層の主な役割は、そのアプリケーションが提供するサービスを**具体的**に示すこと」だと述べましたが、これはApplication層を使用する側(呼び出す側)の視点から説明されていたからであり、技術的に厳密になれば、ここで言及されているのは「Applicatoin層のインターフェース」の設計となります。  
使用する側からすると、Application層はアプリケーションのサービスを提供するプログラムであり、そのインターフェースはユーザー等、開発者でなくともアプリケーションを知っている人間にとってわかりやすいものである必要があります。  
そうすることでUI側のプログラムは、プログラム内部の詳細な事情がわからなくても、Application層のプログラムを直感的に使用することができるからです。  
### Application層のインターフェースの2つの側面
開発者でなくともそのアプリケーションを知っている人なら理解できる、ここで求められるApplication層インターフェースの「具体性」はそのような要件を満たしていなければならないことを確認しました。  
そしてそのような「具体性」を考えるため、ここではApplication層インターフェース設計を「命名」と「粒度」という2つの視点から捉えます。    
#### Application層インターフェースの命名
使用者(呼び出し側)にわかりやすいプログラムを目指す上で、インターフェースの命名は重要です。  
いくら実装が素晴らしいものであっても、その命名がわかりづらければそのプログラムを使用する開発者を混乱させてしまいます。  
#### Application層インターフェースの粒度
「インターフェースの粒度」とはApplication層が提供するインターフェース、つまりメソッドを定義する単位です。  
このメソッドを定義する単位によってApplication層が提供するメソッドの数が異なり、それはプログラムの使いやすさに影響します。  

### 「命名」と「粒度」によってApplication層インターフェースは決定される
Application層インターフェース設計はこれら「命名」と「粒度」の2つの視点によって決定されます。  
これは既に「[補論1:アプリケーション設計における関係とは](#外部設計における関係)」でも述べていますが、粒度によってパラメーターと出力データが定まり、それに命名することでインターフェースが決定されることを考えれば理解できると思います。  
そしてApplication層では基本的にインターフェースとして変数を定義しません。  
そのため実質的にApplication層インターフェースとはApplcation層が外部に公開しているメソッド群を指します。  

### 「命名」と「粒度」からApplication層インターフェースの「具体性」を考える
Application層インターフェースの設計が「命名」と「粒度」という2つの視点から構成されていることがわかりました。  
次に、それらの2つの視点からApplication層インターフェースに「具体性」を持たせることの難しさを説明したいと思います。  
なぜ2つの視点から「具体性」ではなく「具体性の難しさ」を説明するのかというと、後に述べるようにApplication層の性質上そのインターフェース設計を一般的に定式化することは不可能であるからです。  
そのためこの補論では、Application層の「具体性」を「できること」からではなく「できないこと」から読み解いていきます。  

### Application層インターフェースの「命名」の難しさ
補論冒頭でも述べた通り、Application層の設計を考える上で、具体的なインターフェースは重要です。    
UI層からApplication層を呼び出すというのは、いわばスマホ画面からサービスの機能にアクセスしているのと同じであって、その意味でApplication層のインターフェースにはBusiness Logicの内部事情を知らなくても理解できるようなわかりやすさが必要だからです。  
ただ実際の設計において、そのようなインターフェースの命名を一般的に定義しようとするといくつかの問題に出くわします。  
それは、「ユーザーの視点」と「サービスの具体性」の一般的な言語化の難しさです。  
#### 命名における&#12300;ユーザーの視点&#12301;の言語化の難しさ
ある銀行アプリの画面Aでアカウントの現在の預金額のデータを表示すると想像してください。  
この要件を満たすApplication層メソッドの命名をする際に先の「ユーザーにもわかる具体性」を愚直に実践しようとするならば、そのメソッド名は`fetchDepositForScreenA`等となると思います。  
ただ、すでに多くの方はお分かりだと思いますが、このメソッド名には大きな問題があります。  
Application層のインターフェース名は「ユーザーにもわかる具体性」を持っているべきではありますが、同時に関心の分離に沿ってApplication層のインターフェースとUI層を切り離す必要があるからです。  
そうでなければApplication層のインターフェースの汎用性は著しく落ちてしまいます。  
もしこの設計方針で仮に画面B等その他の画面においても預金額を取得するならば、`fetchDepositForBView`メソッド等も定義する必要が出てきてApplication層のプログラムはいたずらに肥大化していくでしょう。    
今回の例ではその改善のため、`fetchDepositForAView`ではなく`fetchDeposit`メソッド等と定義してどの画面からも使い回すことができるような命名にしたらとりあえず解決されるように思われます。  
しかし、このUI層から切り離された「ユーザー視点」の一般的な定義はそれほど単純に言語化できるものではありません。  
これについては、また後ほど詳細に説明します。  
#### 命名における「サービス機能の具体性」の言語化の難しさ
また「ユーザー視点」に加えて、「サービス機能の具体性」自体の定義にも難しさもあります。  
これは、この後の「『粒度』を決める難しさ」にも繋がってきますが、一言で言えば具体と冗長/汎用のトレードオフの問題です。  
メソッド名は具体的であればあるほど、同時に冗長になりその汎用性も落ちてしまいます。  
特に命名の場合は、汎用性が落ちてしまうのはその状況が限定されているならば問題ありませんが、その名前が冗長になってしまうのは避けなければなりません。    
インターフェースに具体性を求めるのは「わかりやすさ」のためであり、その名前が長すぎるならば、いくらそれが具体的であろうとわかりづらいメソッド名になってしまうからです。  
またこの「具体と冗長/汎用のトレードオフ」の問題と連続して、名前の「わかりやすさ」が状況に依存する不定性の問題があります。  
例えば画像を取得するApplication層メソッドに条件や目的があったならば、そのメソッドを`fetchImageForAIfB`等と事細かに定義するのが適切であるかどうかはその状況によって異なります。    
状況として目的や条件が自明であるにもかかわらずこのような詳細な定義をしてしまえば、その具体性はわかりやすさための逆効果となってしまうでしょう。        
これらの「具体と冗長/汎用のトレードオフ」の問題と「わかりやすさ」が状況によって異なる不定性を踏まえると、インターフェースの命名における一般的な「サービス機能の具体性」の定式化は不可能だということがわかると思います。        
### Application層インターフェースの「粒度」を決める難しさを
Application層インターフェースの命名の難しさを「ユーザーの視点」と「サービス機能の具体性」の言語化の難しさから説明しました。  
しかし、「[ユーザー視点](#命名におけるユーザーの視点の言語化の難しさ)」の定義の難しさの説明が途中で終わってしまっています。      
そのため、ここではその話と接続しながらインターフェースの「粒度」における「ユーザーの視点」と「サービス機能の具体性」の定義の難しさも説明していきます。
#### 粒度における&#12300;ユーザーの視点&#12301;の言語化の難しさ
先の[命名における&#12300;ユーザーの視点&#12301;の言語化の難しさ](#命名におけるユーザーの視点の言語化の難しさ)では、預金額の情報を取得したい場合のApplication層のメソッドの定義において特定画面に依存した`fetchDepositForAView`という名称ではなく画面に依存していない`fetchDeposit`と命名することを提起しましたが、そのあとに「しかし『ユーザー視点』の一般的な定義はそんな単純なものではない」など匂わせる表現を残して終わっています。  
このように中途半端な文になった理由は、Application層に求められる「具体性」の難しさの本質が「粒度」にあるためです。    
##### UI層から切り離す難しさ
先のApplication層メソッド`fetchDepositForAView`は、`fetchDeposit`に命名し直すことで特定画面に依存せずに複数画面から再利用することができるようになりました。  
ただここでの目的は、Application層メソッドを特定画面から切り離すことではなくUI層全体から切り離すことです。  
`fetchDeposit`は特定画面には依存しなくなりましたが、UI層に依存していないと言えるのでしょうか。  
結論から言うと、この問いに答えることは原理的に不可能です。  
なぜならあらゆるApplication層のあらゆる出力データは、最終的にはUI層において画面に表示するための情報です。  
そのため、あるインターフェースの設計(粒度の単位)がApplication層に関係しているからと言って、それが即ちUI層には依存していないという排他的な論理機序は成立しません。  
先の例で言えば、`fetchDeposit`は確かに預金額の取得のためのApplication層メソッドであると言えますが、ただ同時に「預金額を取得する」というメソッドの定義はUI層に依存していないと言い切ることは不可能だということです。    
少し話が抽象的になってきました。  
ここでもう一度話を具体に戻すべく、「粒度における『サービス機能の具体性』の言語化の難しさ」に移りましょう。  
> 補足:  
> 「`fetchDeposit`メソッドがUI層に依存しているか判断するのは原理的に不可能」という主張に納得できていない可能性があると思うので、それについて説明します。    
> 恐らく違和感を覚える一番の理由は上記の主張と「関心分離」の原理が矛盾しているように思えるからだと思いますが、この両者のテーマは地続きではあるものの一義的に問われている次元が異なります。  
> 難しい表現になってしまいますが、具体的には前者で問われているのは次元は「実際における実質的な意味」であり、それに対して後者は「概念における形式的な意味」が問われています。  
> 

### 粒度における「サービス機能の具体性」の言語化の難しさ
ここでは先に例に出した預金額の情報がアカウント(Account)型のプロパティとして定義されていると仮定します。  
Account型のデータ構造は以下の通りです。(Accountの定義は必要な箇所以外省略しています。)  
```
struct Account {
   let deposit: Int 
   let name: String
   ...
}
```

先の設計ではApplication層はAccount型のdepositプロパティ取得のために`fetchDeposit`メソッドを定義していますが、もしこの論理をプログラム全体で一貫させようとするならば、`fetchAccountName`等Account型の他のプロパティを取得するメソッドをApplication層に定義する必要があります。    
もちろん必ずしもそうしなければいけないというわけではありません。  

しかし設計においては、論理的に一貫していることが理解のしやすさ、延いてはプロジェクトチームへの浸透のためのとても重要です。  
`fetchDeposit`メソッドがあるにもかかわらず、ある画面において必要なアカウント名`Account.name`の取得のために`fetchAccountName`を定義しないならば、その設計は判断基準がどこにあるのかわからず読み書きしづらいプログラムになってしまいます。        
ただ今回の場合は、たとえそのように一貫した基準で設計したとしても、各Application層、Domain層のオブジェクトのプロパティ毎にApplication層メソッドを定義しなければならず、Application層が肥大化してしまうのは半ば必然です。  
論理的に一貫させないとわかりづらいプログラムになってしまい、それを正そうと論理的に一貫させるとプログラムは肥大化していく、このジレンマに思える状況の中で私たちはどう対処するのが正解なのでしょうか。   

#### Business Logic層のデータ構造設計を尊重する  
私は、今回のケースでは、`fetchDeposit`や`fetchAccountName`といったプロパティ単位では定義せずオブジェクト単位、つまり`fetchAccount`メソッドを定義してそこからアカウント情報に関するあらゆるデータを取得するべきだと思います。  
Account型を含めたBusiness Logic層(Application/Domain)で定義されたデータ構造は、それぞれApplication層、Domain層において最適だと判断された上で設計されてるはずです。        
そのためApplication層のインターフェースの粒度およびその出力データも、Business Logic層で定義されたデータ構造を基に設計されるべきです。  
もし仮に預金額のデータがUI的観点ではなくBusiness Logic的にも本当に重要ならば、ただ`fetchDeposit`メソッドを定義するのではなく、Account型に関連するデータ構造に間違いがあると考えてそこから見直した方が良いと思います。  

### 改めて、Application層のインターフェースに求められる具体性とは
#### Application層のインターフェース非決定性
「預金額を取得する」というケースからApplication層のインターフェースに求められる具体性とはなんであるのか考えてきました。  
補論を通してみてきたように、本論で述べた「Application層における具体性を保つべくユーザー目線で機能を定義すること」はとても重要ではありますが、そのようなApplication層のインターフェースを求めるための明確な設計の方法論や十分条件は存在しません。    
これはApplication層の性質上、その輪郭を一般的に明示することは原理的に不可能だからです。  
先の例を参考にすればユーザー目線で定義するのは重要ですが、かといって愚直にユーザーから見た通り画面Aで表示する預金額を取得するメソッドを`fetchDepositForAView`と定義するとApplicationが特定画面に依存したのインターフェースとなり、UI層に依存した冗長な設計となってしまいます。  
またUI層に依存せずに具体的に定義するといっても、そもそも画面に表示するための預金額情報を取得する`fetchDeposit`メソッドを定義すること自体が画面(UI)の仕様にひきづられた設計であるのかどうかはこのメソッドからだけでは原理的に判断がつきません。  
そのためApplication層のインターフェースの設計はApplication層とDomain層を総合的に踏まえて決定する必要がありますが、Application層とDomain層の内実はそのサービス内容のモデリングや需要によって常に形が変化していきます。    
このように、本質が常に形を変えていくApplication層、Domain層に依存しているApplication層のインターフェースを形式的に決定することは本質的に不可能です。    
#### Domain/Application層のデータ構造という軸
ただ同時に今回の補論では、「Application層のインターフェースに求められる具体性」の必要条件として「Domain層とApplication層のデータ構造に合わせる」ということを挙げました。  
すでに述べたように、Domain層とApplication層のデータ構造の設計には必ず理由があるはずであり、それらのデータを出力するApplication層のインターフェースはその構造を尊重して設計されるべきです。  
「Application層のインターフェースに求められる具体性」を明確に言語化することが不可能であるなか、この「Domain層とApplication層のデータ構造に合わせる」という条件は、唯一客観的に明確な判断基準であり、設計を考える上でとても有効な足場となります。  
以上の補論の内容を要約すると、曖昧な表現にはなってしまいますが、「Application層インターフェースで追求すべき具体性」とは、「Domain層とApplication層のデータ構造」を軸としながらできる限りユーザー目線にたってプログラムの意図が伝わるような定義ということなると思います。    
もしこの方針でプログラムの意図がわかりやすいインターフェースを設計できないのならば、その時は「Domain層とApplication層のデータ構造」から見直していく必要があります。    

