
# iOSアプリでスケールしやすいアーキテクチャを考えてみた(準備の準備編)

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。(全部書いてから一気にあげようと思ったけど予想以上の大変で無理でした。😅)  
(1)**設計を理解するためのレイヤードアーキテクチャ編 <-本記事**  
(2)設計を理解するためのクリーンアーキテクチャ編(執筆中)  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への(準備の)準備編として設計の概観を理解するためレイヤードアーキテクチャを説明しますので、  
「レイヤードアーキテクチャはもう知ってるよ」という人は次のクリーンアーキテクチャ編へ🚅、  
「レイヤードアーキテクチャもクリーンアーキテクチャもわかってるし」という方は概要編から読んでいただいた方が良いと思います。✈️  



## 始めに  
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの言葉の定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物。  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるようなもの。  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっていることが多いと思うのでこの記事では上のように区別することとします。  
また文章が進むにあたって他にも言葉の定義を明確にすることがありますが、その都度このように補足を書いていると話が逸れてわかりづらくなってしまうと思うので以後必要になりそうな細かい補足はすべて脚注として記事の終わりにまとめて記載し、関連箇所に脚注へのリンクを添える形式とします。  
ただ記事の構成上必要だと思われるようなものは補足的な内容でも本文内に記します。  



## 目的(本記事で書かれていること)
現在モバイルアプリの開発ではMVCを始め、MVP・Flux・クリーンアーキテクチャやその他様々なアーキテクチャが採用されています。  
これらのアーキテクチャはアプリケーション開発を行う際にとても有効で、作業をする上で大きな指針を開発者に示してくれますし、コミュニケーション時の共通言語としても役立ちます。  
ただこうしたアーキテクチャはアプリケーション構造の概観を提示してくれてはいますが、詳細についてまでは言及していません。  
その結果アプリケーションの最終的な品質は個々の設計者・実装者に大きく左右されることになり、本来問題解決のために利用されているはずのアーキテクチャの中で別の問題を引き起こしてしまうということがあります。  
巷でよくいうFatViewController、FatViewModelといった問題ですね。  
またそれぞれのアーキテクチャはいずれも特定の問題領域に注目して作られているためそこには少なからず視点の偏りがあります。  
このような状況もあり、私は個々のアーキテクチャを学んでもアプリケーション設計について理解できている感じがしませんでした。  
それぞれのアーキテクチャの形式やメリットは理解できても、それらが設計全体において何を意味しているのかイマイチ良くわからなかったのです。  
このような曖昧な理解は、先ほどのFatViewControllerのようにアーキテクチャの中でまた新しい問題を作ってしまう原因になりえます。  
なので今回、設計を俯瞰的に理解するために様々なアーキテクチャを参考にしながらそこで得られたエッセンスだと思う要素とiOSアプリの構成を照らし合わせて、自分が保守・変更しやすいと思えるようなアプリケーション開発における雛形のようなものを考えてみました。  
本記事を含めた一連の記事で書かれていることはそのアーキテクチャの説明とそこに至るまでに得られた知見をまとめたものです。  
## 前提
・SwiftUIは扱いません。  
・作成したサンプルアーキテクチャはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
・FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルアーキテクチャでは採用されていません。  


## 設計を理解するためのクリーンアーキテクチャ

「設計を俯瞰してみる」ということを最初の目的として記事を進めていこうと思いますが、なんの手がかりもなしに理解することは難しいです。  
なのでまずクリーンアーキテクチャを通して設計を理解していきたいと思います。  
既存のアーキテクチャの中からクリーンアーキテクチャを選んだのは、クリーンアーキテクチャの以下の特徴が理由です。  
1. 具体的なコンポーネント<sup>[*1](#footnote1)</sup>に依存しておらず、設計の思想を提唱している  
2. アプリケーション全体を主要な関心の対象としている  
3. 1と2の特徴を持ったアーキテクチャを総括してまとめたものである  


それぞれの詳細について簡単に説明しますと、  
1に関してはクリーンアーキテクチャにはMVPのPresenterやFluxのStoreのようにアプリーケーションに必ず含まなければいけないコンポーネントは存在しないということです。  
クリーンアーキテクチャはそのような具体的なコンポーネントには依存せず、アプリケーションを責務や性質により複数のグループに分割しそれらのグループがどのように連携するのかという考えを提示しています。  
2についてはMVC・MVP・MVVM等のアーキテクチャは一般的にGUIアーキテクチャ<sup>[*2](#footnote2)</sup>と言われ、主にアプリケーションのUIとその他を分離することに注目していますが、クリーンアーキテクチャはアプリケーション全体を主要な関心対象としています。  
3はそのままなのですが、1と2の特徴を持ったものとして他にもレイヤードアーキテクチャ・ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等があるなか、クリーンアーキテクチャはこれらのアーキテクチャを総括したような立ち位置にあるアーキテクチャです。  

クリーンアーキテクチャの以上のような特徴が設計を考える上で何を意味しているのかということは後ほど説明しますが、これらのことを簡単にまとめると「クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想」であるということです。  
これは「設計を俯瞰して理解する」という私たちの目標と完全に合致しています。  
ということでまず最初の目標としてクリーンアーキテクチャを通してアプリケーション設計への理解を深め、私たちの設計に関する共通認識を作っていきたいと思います。  

## クリーンアーキテクチャへの障壁
ただクリーンアーキテクチャと言えばこの円図が有名ですが、これが非常にとっつきづらいです。　　
![クリーンアーキテクチャ円図](https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg)  
<sup>参考: [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)</sup>  

図が丸いのでどこからどう読んでいけばよいかわかりませんし、そもそもなぜ円なのかもよくわかりません。  
クリーンアーキテクチャを理解するためにはまず内容以前にその背景にあるコンテクストを理解する必要があります。  
なので本記事ではこの円図の背景にある考えを理解するためにクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャから学んでいきたいと思います。

## クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ

レイヤードアーキテクチャはアプリケーションを責務によって複数のグループに分割します。  
これは先ほどクリーンアーキテクチャの特徴として紹介しましたが、レイヤードアーキテクチャも同じ特徴を持っています。  
そして分割された複数のグループが単一方向にのみ依存するような関係性を持っており、アプリケーション全体が複数のグループが積み重ねられて層をなしているかのような構成に思えるためレイヤードアーキテクチャ(layered architecture)なわけです、そのままですね。  
レイヤードアーキテクチャの目的はこの責務による分割と単一方向の依存関係によってそれぞれの層の関心を分離することにあります。  
これによって開発者は開発時に常にアプリケーション全体に注意を向ける必要がなくなり、自分が担当している責務の層に集中することができるようになります。  
何層に分けるかについてはいくつか考え方があるのですが、私はアプリケーション設計を理解するという目的においては以下に示すように4つの層に分けるのが良いと考えているので今回はそれを紹介します。  

## レイヤードアーキテクチャの概要
レイヤードアーキテクチャの概要は以下の通りです
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/レイヤードアーキテクチャの概要.png" alt="レイヤードアーキテクチャの概要" width=70%　>

```
補足  
レイヤードアーキテクチャの層であるUI/Application/Domain/Infrastractureという言葉は色々な用法で利用されます。  
なので以後、アーキテクチャにおける層を指す場合は英字で、より一般的な文脈で使われる場合はカタカナで表記することとします。  
例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等 
 
またInfrastructureはInfraと省略して表記します。  
```

### Domain層とApplication層
各層の内容はだいたい上の図に書かれている通りですが、Domain層とApplication層については少しわかりづらく、また両者の区別もしづらいと思うので説明します。


#### Domain層

まずDomain層から説明します。  
ここでのドメインとはそのアプリケーションが現実で従事する業務領域を指し、Domain層にはその業務に関する知識やルールを表現したクラスやメソッドが含まれます。    
例えば銀行アプリのドメインは銀行業務全般であり、Domain層には取引の際のルール、顧客の口座等を表現する知識やロジックが定義されます。  

#### Application層
Application層の定義は少し長くなるのですが、「そのアプリケーションの機能、またビジネスロジックの内ドメインとは関係しないものを定義・実装する場所」だと思ってください。  
もう一度銀行アプリを例に説明すると、そのアプリに「取引履歴をエクセル形式で出力する」機能があるとします。  
この「取引履歴をエクセルで出力する」機能は「そのアプリケーションの機能」にあたるのでApplication層に定義しますが、その処理は大きく「取引履歴データの取得」と「取得したデータのエクセルファイル形式への変換」に分けられます。  
このうち「取引履歴データの取得」は銀行業務に該当するのでDomain層に定義されますが、「取得したデータのエクセルファイル形式への変換」は銀行業務ではないためApplication層に定義します  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Application層の説明(取引履歴データをエクセル形式で出力する例).png" alt="Application層の説明(取引履歴データをエクセル形式で出力する例)" width=50%　>  

#### Domain層とApplication層の関係
上の例のようにApplication層には「取得したデータのエクセルファイル形式への変換」など一部具体的な処理が定義されることもありますが、基本的にはDomain層では**アプリケーションサービスのビジネス的詳細が定義**され、Application層では**ユーザー目線でそのサービスが提供している機能を定義**している層だと言って良いでしょう。  
レイヤードアーキテクチャの目的である層同士の関心の分離はApplication層とDomain層の関係にも当てはまり、Domain層がApplication層にどう利用されているかは意識されるべきではありません。  
しかしこの二つの層は概念的に切り離すのが難しく、レイヤードアーキテクチャの中でも他の組み合わせと比べて密接な関係性にあります。  

### ビジネスロジックとは
先ほどの[Application層](#Application層)の説明の中で「ビジネスロジック」という言葉が使われていますが、この言葉は「ビジネス」と「ロジック」という日常的によく使う単語を組み合わせたものであるためなんとなく使われることが多いと思うので説明します。  
[wikipedia](https://ja.wikipedia.org/wiki/ビジネスロジック)にはビジネスロジック に関して明確な定義はないとしながらも、「実世界のビジネスオブジェクトをモデル化したもの」と紹介しています。  
違う言い方をするとアプリケーションに関する仕様書をデザイン/ビジネス/技術の3つにカテゴライズした場合にビジネス仕様書に含まれるものを指していると言っても良いと思います。  
アプリケーションに関する仕様のうちビジネスチームが関わるロジックであるためビジネスロジックなわけです。  
これをレイヤードアーキテクチャに当てはめるとちょうどApplication層とDomain層を合わせたものをビジネスロジックと表現していることになります  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/アプリケーションの仕様書とレイヤードアーキテクチャの関係.png" alt="アプリケーションの仕様書とレイヤードアーキテクチャの関係" width=50%　>   
このようにこのAppplicationとDomainの2つの層を一括りにして表現している「ビジネスロジック」という言葉が開発において頻繁に使われているということからもこの2層が密接に関係していることが伺えます。  
レイヤードアーキテクチャには4層ではなく3層構造で捉える見方もあるのですが、その場合はこのApplicationとDomainが一つにまとまった形になっています。  
ネットで調べているとこの3層構造のレイヤードアーキテクチャのApplicationとDomainをまとめた表現として"Application"だったり"Domain"などが使われているのですが、そうすると4層構造におけるApplicationとDomainと混同してしまうので私はBusiness Logicと表現するのが良いと思っています。
のちに紹介する私が作成したサンプルプロジェクトでもディレクトリ名としてBusiness Logicを使っています。  

### レイヤードアーキテクチャの依存関係

#### 依存は一方向のみ
レイヤードアーキテクチャは層の分割に加えてそれぞれの層の関係性の定義も記しています。  
それは最初にレイヤードアーキテクチャの図でも説明されていますが、それぞれの層を  
UI-Application-Domain-Infra  
という順番に並べた場合、依存方向は左から右への一方向のみであるというルールです  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/レイヤードアーキテクチャの依存ルール.png" alt="レイヤードアーキテクチャの依存ルール" width=50%>  

#### 層を跨いだApplication層からInfra層への依存
しかし例外というわけではないのですが一つ注意しておきたいのがDomainをまたがずにApplication->Infraという依存関係もありえます。  
これは実際のアプリの機能を考えてみればわかりますが、例えばアプリのログイン状態はDomainとは関係ないのでApplication層のデータですがこのログイン状態は次回起動時も引き続き利用するべき状態なのでInfra層の永続化機能で保存する必要があります。  
このようにアプリケーションにおいてはApplication層のデータをInfra層を使って操作することは少なからずあるのでApplication->Infraという依存関係は自然と発生します。 
しかしこの場合も依存方向が一方向であるということは同じです。  

#### Application層からInfra層への依存以外で層を跨いだ依存はない
ここで一つ疑問に思うのが、「Application->Infrastractureという依存関係がありえるのならば論理的にはUI->Domain/Infraというケースもあるのでは？」ということです。  
しかしこのような依存関係は実際の開発ではありえません。  
なぜならApplication層は先ほども言った通り「ユーザー目線でそのサービスが提供している機能」を定義している場所であり、言い換えるとアプリケーションにおいてこのApplication層が複数の内部処理を連携させてユーザーにとって意味のあるものにしているからです。  
そのためUI層がApplication層を飛び越えてDomain/Infra層にアクセスする場合、Domain/Infra層の処理を連携させる責務はUI層が担うことになり、結果UI層がApplication層の知識を知ることで関心の分離が破られコードが肥大化・複雑化していきます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/レイヤードアーキテクチャ依存関係%7EUIからDomain:Infraを利用した場合%7E.png" alt="Application層からDomain/Infra層を利用した場合" width=50%>  


ケースによってはApplication層の実装が冗長に感じる場合はあるかもしれませんが、ここでApplication層を省略してUI->Domainの依存を許容してしまうとアプリケーション全体でUI->ApplicationとUI->Domainの二つのフローを想定しなければならないため結果としてApplication層省略することによるコストカット以上に設計・開発の複雑さが増してしまうことになります。  
このようにApplication層が存在するにも関わらずUI->Domain/Infraという依存関係を構築してもアプリケーションの開発になんのメリットももたらさず、むしろ複雑にしてしまうだけであるためUI->Domain/Infraという依存関係は実際の開発ではあり得ないと考えてもらって大丈夫だと思います。  
これら4層の依存関係で少し変わったケースがあるのはここで説明したApplication->Infraのみです。  

以上でレイヤードアーキテクチャの基本的な説明は終わりですが、クリーンアーキテクチャへ進む前にレイヤードアーキテクチャについて何点か考えることで設計への理解を深めたいと思います。  

## レイヤードアーキテクチャの層の分割は4つが適切か？

レイヤードアーキテクチャの説明の冒頭で分ける層は4つで良いと書きましたが、本当に4つで良いんでしょうか？  
ここでは4つの層が適切であるという私なりの根拠をアプリケーションの層を一つ一つ分割していきながら説明していきたいと思います。  

### アプリケーションをビジネスロジックとビジネスロジック以外に分ける

まずアプリケーションを「ビジネスロジック」と「ビジネスロジック以外」というように分割します。  
アプリケーション設計には[Presentation Domain Separation(プレゼンテーションとドメインの分離)](https://bliki-ja.github.io/PresentationDomainSeparation/)(以下PDSと表記)という考え方がありますが、これはアプリケーションをビジネスロジックとその他に分けるものです。  
なぜ最初にビジネスロジックが抜き出されるのかというと、やはりアプリケーションの核心といえる機能に関する定義・実装がここにされているからだと思います。  
ビジネスロジックを他と切り離すことで再利用が可能になりまたテストもしやすくなります。  


#### プレゼンテーションとドメインの分離(Presentation Domain Separation)についての補足
PDSについては2点ほどわかりづらいところがあると思うので補足します。  
##### 1 ドメイン=ビジネスロジック
まず最初にPDSのドメインをビジネスロジックと置き換えていることからもわかる通り、ここでのドメインは実質的にはApplication層とDomain層を含んでいます。  
実質的にはというのは概念的な意味としてはこのドメインはレイヤードアーキテクチャでのドメインと同じ「業務領域」を指していると思いますが、そもそもPDSは設計原則であってアーキテクチャではありません。
そしてPDSのドキュメントを読むにその主な主張はアプリケーションの機能に関するロジックと他の部分を切り離すことにあると考えられるので、ここでのドメインをレイヤードアーキテクチャの文脈に照らし合わせるとApplication層を含めたビジネスロジックと捉えた方が正確だと思います。

##### 2 プレゼンテーションとはUIを含めたドメインと連携する全ての機構を含む
次にプレゼンテーションという言葉は一見UIを想起させますが、ここにはInfraも含まれます。[PDSのドキュメント](https://bliki-ja.github.io/PresentationDomainSeparation/)には最後に補足のような形で以下のように書かれています。  

>人間ではなく、コンピュータ相手の Web Services だって、プレゼンテーション部分です。  
>ですから、ドメイン部分のコードと Web Services 部分のコードをごちゃまぜにしてはいけないのです。  
>外部APIにしてもそうです。  

どうやらここでいうプレゼンテーションとはUIのみを指しているわけではなくドメインと連携する外部機構全てを指していると捉えた方が良さそうです。  
この意味でPDSという概念はプレゼンテーションよりもドメインにより重きが置かれているように思います。  

### ビジネスロジック以外をUIとInfraに分ける
これは特に説明不要でしょう。  
PDSではこの2つはドメインに対する外部機構ということでまとめられましたが、一般的にユーザーとの接点であるUIと永続化機構や端末機能を含むInfraが別物であることに異論はないと思います。  
ただUIとInfraを区別することに違和感がなくても、永続化機構や端末機能をInfraと一つにまとめることには違和感がある人がいるかもしれません。  
確かに永続化機構や端末機能は役割が異なる部分があり、場合によってはそれぞれをData、Deviceと区別します。  
しかしどちらもアプリケーションの機能を技術的に裏で支えているということは共通しており、また設計上でもUIとDomainの関係性は「UI->Domain」となりUIからDomainを呼び出す形になりますが、Data/Deviceに関しては「Domain->Data/Device」となりDomainから呼び出されるのでアプリケーション構造上での立ち位置は同じです。  
そのため設計の概観を捉える上ではこれらは一つにまとめた方がわかりやすいと思っています。  
なのでこの記事でも必要であればData/Deviceと区別して表現しますが、そうでなければInfraと表現します。  

### ビジネスロジックをApplicationとDomainに分ける

最後にビジネスロジックをApplicationとDomainに分けます。  
この2層は既に説明した通り非常に密接に関わっていますがDomain層にはアプリケーションサービスのビジネス的詳細が定義され、Application層ではユーザー目線でそのアプリケーションが提供している機能を定義されており、やはり責務が異なります。  
また設計論においてもFlux/Reduxを筆頭に近年Application層の状態を管理することを目的としたアーキテクチャが注目されており、
ドメイン層に注目した開発・設計論であるドメイン駆動開発はその提唱以来多くの人に支持されています。  
このような事情からもApplication層とDomain層は個々の設計論がアーキテクチャを語る上で重要な存在となるほど、それぞれが設計において大きな課題を持っていることがわかると思います。
そのためアプリケーション設計を理解する上でも、Application層とDomain層は独立した2つの層として捉えた方が良いと考えています。

### この4層によってアプリケーションの提供元である企業から提供先であるユーザーまでしっかり捉えている

さて、アプリケーションの層をその必要性も考えながら一つ一つ分けていったのですが、私がこの4層が最適だと思う理由はこれによってアプリケーションの端から端までをしっかりと表現できるようになっているからです。  
端から端までとはアプリケーションの提供先であるユーザーとの接点となるUIと提供元となる企業もしくは事業のことです。  
UIに関しては説明するまでもないと思いますが、企業(事業)について少し説明するとDomainとは業務領域と説明しましたが別の言い方をするとその企業がアプリケーションを通して提供している事業の知識・ルールを記述している箇所であるともいうことができます。  

このように4つに分割することでアプリケーション上でその提供先であるユーザーとの接点になるUIと提供元となる企業(事業)をしっかりと表現することができるようになりました。  
もしこれより少ない層にしてしまうとUIとInfraをPresentationとしてまとめたり、ApplicationとDomainをBusiness Logicとしてまとめたりとアプリケーション開発において異なる問題を抱える責務を一緒くたにしてしまうことにより開発における問題をうやむやにしてしまう可能性があります。  
また逆にこれ以上層を分けていっても詳細に立ち入りすぎてアプリケーションの概観を理解するという点においては必要以上に複雑になりすぎてしまうと考えています。


## アプリケーション設計においてレイヤードアーキテクチャからわかること
本記事の最後にアプリケーション設計においてレイヤードアーキテクチャから学べることを考えていきたいと思います。

### 設計とは関係性を構築することである
これに関していろいろと意見はあると思うのですが、ここで私が書きたいことはレイヤードアーキテクチャは「設計とはアプリケーションにおいて開発しやすい関係性を構築すること」であるということを示してくれているということです。  
レイヤードアーキテクチャではアプリケーションをその責務や性質の違いから4つのカテゴリに分類しました。この一番のメリットは「関心の分離」です。  
レイヤードアーキテクチャではそれぞれの層が他の層に影響を与えるのは自身が返り値として出力するデータのみです。(メソッドの返り値ではなく、他の方法でデータを異なる層へ出力している場合もあります。)    
そのため、それぞれの関心が分離され、各層の変更によるアプリケーション全体への影響は非常に限定されます。  
そしてそれぞれの層の依存関係は単一方向なので、4つの層が連携することでプログラムが複雑になってしまう恐れもありません。  
このようにレイヤードアーキテクチャでは責務によってアプリケーションを分割しそれをシンプルな関係性によって構築することによってアプリケーションの構成がより具体的でわかりやすいものになり、開発のさまざまな面で予測しやすくなるため開発効率が大きく上がります。  
また開発者の心理面から言っても今までアプリケーションと漠然と捉えていたものをUI/Application/Domain/Infraというより具体的な責務の集まりと捉えることによってアプリケーション開発に対する見通しがよくなり開発に対する心理的負担はだいぶ軽減されると思います。    
  
ここでは記事の都合上レイヤードアーキテクチャの流れから「設計とは関係性を構築すること」だと話していますが、これはなにもレイヤードアーキテクチャに限ったことではありません。  
MVCはアプリケーションをModel-View-Controllerの構成と捉えた上でそれらの関係性を定義しているということができますし、他のアーキテクチャも同様です。  
また、よりミクロな観点で言えばデザインパターンはアプリケーションにおける特定機能の実現のためのパターン(関係性)を提示おり、SOLID原則はその関係性が適切に保たれているかどうかの判断基準であるということもできます。  

### 関係性の複雑さ=アプリケーションの複雑さ

このようにアプリケーション設計のマクロレベルからミクロレベルに至る全ての概念やテクニックは「関係性」を定義しているといって良いと思いますが、これほどまでに関係性が重要な理由はそれがアプリケーションの複雑さを直接的に決定しているからです。  

いくつか具体例を出して説明します。

### Fat ViewControllerの問題

レイヤードアーキテクチャはUI-Application-Domain-Infraという構成であるということを説明しましたが、これらをMVCアーキテクチャの文脈に当てはめるとUIを除くApplication/Domain/Infraは全てModelに分類されます。

```
補足
・iOSのMVCにおけるControllerであるViewControllerはUIKitに含まれていることからわかる通り、
  Viewの操作を行う役割を担いUIの仕様を把握しているのでレイヤードアーキテクチャではUI層に該当します。
  
・MVCにおいて厳密にInfraがModelに分類されるのかは個人的に疑問なのですが、
　少なくともネットでMVCの概要を調べるとInfraをModelに含めてる記事は散見していますし、
　何よりMVC(Model-View-Controller)のどれかに分類するなら消去法でModelしかないのでここではそういうことで話を進めます。
```
そうするとレイヤードアーキテクチャにおいて異なる階層に属していたApplication/Domain/Infra層のクラスは全てModelという一つのカテゴリーの中に並列に並べられることになり、iOSのMVCでいうと以下のような構成が成立するように思えます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/問題のあるMVC.png" alt="Modelを深く考えず設計した時に起こりうるMVCの構成" width=70%> 

このような構成は図でみると一見問題ないようにみえますが、実際の開発では大きな問題を生み出します。  
その主な原因はController(ViewController)とModel間の関係性の曖昧さです。  
Application/Domain/Infraと役割の異なるコンポーネントを全てModelとしてしまったために、ViewControllerにとってModelがどのような役割なのかはっきりとせず、その結果各Modelクラスの責務が曖昧になってしまうのです。(Modelの役割が曖昧だからController-Modelの関係がわかりづらいともいえます。)  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Modelの責務の曖昧化.png" alt="Modelの責務の曖昧化" width=50%> 

そしてそのようなModelクラスの曖昧さを解決するのは、結果的にViewControllerの責務となります。  
どんなにViewController-Model間で問題を抱えていてもViewではユーザーに適切な形で情報を表示しなくてはなりません。  
そのためViewController-Model間で問題を抱える問題をViewControllerで全て解決してから本来の責務であるViewの操作を行うことになるため、ViewControllerの責務は膨れ上がりコードが肥大化していきます。  
こうして生まれるのが俗にいうFatViewControllerです。

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/FatViewController.png" alt="FatViewController" width=60%> 

もちろんこれはiOSのMVCの理想的な形ではありません。[Appleのドキュメント](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)にもViewControllerのデータの操作は最小限にするべきと記されています。  
ただそうだとしてもApplication/Domain/Infraを全て一緒くたにしたModelがControllerから利用されるという、MVCが示すシンプルな関係性の構図のみではこのような問題は必然的に起こってしまうものだと思います。  
MVCは概念としてはシンプルでわかりやすいのですが、実際の開発を考えるとApplication/Domain/InfraをModelという一言で済ましてしまうのは言葉足らずな感じがします。  

#### レイヤードアーキテクチャを取り入れたMVC

次に先程のMVCの構成にレイヤードアーキテクチャの考え方を加えてみます。  
図にすると以下のような感じです。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/レイヤードアーキテクチャを取り入れたMVC.png" alt="レイヤードアーキテクチャを取り入れたMVC" width=70%> 

上の図をみただけで、先ほどよりもわかりやすくなったのがわかるのではないでしょうか？  
ViewControllerから利用するモデルクラスはレイヤードアーキテクチャでいうApplication層モデルのみとなり、Controller-Model間の関係性が非常にわかりやすくなりました。  
そして既に説明した通りApplication層は「ユーザー目線でそのサービスが提供している機能」を定義しているため、Application層モデルのメソッドの返り値はユーザーの要求に直接対応しているはずです。  
そのためModelからの返り値をViewに表示するための ViewControllerの処理は必要最低限のものになり、ViewControllerで複雑なデータの操作を行う必要はなくなります。  
(ここでいう必要最低限の処理というのはInt型で返された時間を人が認識できる形式に変更したり、ログインしているかどうかというBool型を"ログイン中"という文字に変換する等です。Model(Application)はViewの仕様を知っているべきではありません。なのでApplication層のModelの返り値がユーザの要求に直接対応していたとしても例に出したようにコンピュータにとって都合の良いデータ形式を人間に都合の良いデータ形式に変換する作業は必要になることがあります。)  
このようにMVCのModelをレイヤードアーキテクチャによって再考することによって、Controller-Modelの関係性がシンプルでわかりやすくなり、またViewControllerで複雑なModelの操作を行う必要がなくなったためViewControllerの責務が肥大化することがなくなりました。  

#### MVCとMVC+レイヤードアーキテクチャの比較
単純なMVCとレイヤードアーキテクチャを採用したMVCを比較すると、レイヤードアーキテクチャを採用しているMVCの方が責務をより細かく分ける傾向にあるためコードやコンポーネントの量は多くなると思います。  
しかしそれでもレイヤードアーキテクチャを採用している方が各コンポーネントの責務がはっきりしているため、自身がどこから利用されまたまたどのコンポーネントを利用するのか悩む必要はありません。  
このようにそれぞれの責務・関係性が明瞭になることで開発者はどうコードを書くべきか考えるコストが減り、またチーム開発でのタスクの分担も行いやすくなるなど開発効率が大きく上がります。  
そしてこうした設計による開発効率へのポジティブな効果はそのプロジェクトの規模が大きくなればなるほど高くなっていきます。  

## if文ネスト構造によるコンテクストの複雑化

プログラミングをやっていると「(if文の)ネスト構造を深くすることは避けろ」ということをよく耳にすると思います。  
ネスト構造が否定的に捉えられている理由はif文が入り組むことによりコードの流れを追うのが難しくなること、また一つ一つのif文がコンテクストを提供しているのでそれらが入れ子になった結果全体のコンテクストが複雑になってしまうことにあることだと思います。  
そのような複雑なコンテクスト内では、内側のif文を読むためその外側のif文のコンテクストを把握しなければならず開発者は常に目の前のコード以外の事にも注意を払っていなければならないので認知負荷がとても高くなってしまいます。  
そしてネストが深くなるといういうのは関係性が複雑になっているということでもあります。

**ネストが深くなったif文の複雑さを示すためのコード例を差し込む
  
このように関係性の複雑さによってプログラムの流れは入り組んだものとなり、開発者はいくつもの状況を考えながら作業をしていかなければいけないためアプリケーション開発に大きな影響を及ぼします。  

### アプリケーションの関係性を考えることで適切な設計を見つける

関係性がアプリケーションに与える影響が大きい説明を二つのケースを例に説明しました。  
他にも該当するケースはいくつもあり挙げていけばキリがないですが、ここで私が関係性ということについて言及したのはこれが設計を考える上での思索や議論の滑り止めになると考えているからです。  
私たちがコードの設計について考えるときにとりうるアプローチは数多くあり、その中には互いに反対の方向性を持ったものもあります。  
あるケースではコードの重複を減らすために複数のコンポーネント分けて考えていたものをまとめて一つにするのが良いかもしれませんし、別のケースでは反対に責務の複雑性を回避するためあるコンポーネントから特定責務を取り出して別コンポーネントとした方がわかりやすくなるかもしれません。  
私たちはこうしたさまざまな解決方法の中から適切なものを選んでいく必要がありますが、その時にそのコンポーネントの背後(周辺)にある関係性を考えることが大きな助けとなります。  

### 関係性を考えなかった結果失敗したViewModelの設計

ここではその関係性を考えずに設計を行った結果失敗した経験を紹介し、アプリケーション設計において関係性を考えることの重要性を示したい思います。  
私はこのあとの記事で紹介するサンプルプロジェクトの作る際、ViewModelの設計を画面機能ごとにまとめようと考えました。  
画面機能毎にprotocolとその既定実装を書くことで再利用できるようにしてコード量を減らそうと考えたのです。  
しかしその結果ViewModelはとんでもなく複雑で、開発しづらいものになりました。  
その理由は今から考えればとても馬鹿馬鹿しいと思うのですが、ViewModelが「ViewのModel」だからです。  
ViewModelの中心にあるのはあくまで「View」であって「Viewの機能」ではありません。  
ViewModelの設計の根幹に「View」ではなく「Viewの機能」を据えてしまったことで、ViewModelの責務はそのViewModelクラスに書かれたコードとそのViewModelが適応するいくつものProtocolに散在することになりました。  
そのためViewModelの責務を理解するためにはいくつものファイルに書かれたProtocolを参照しながらそれらを頭の中でまとめあげ、さらにそこにViewModelクラス自体書かれている責務を加えなければなりませんでしたが、いくつもファイルを跨いでるうちに初めの方に読んだコードを忘れてしまうので全てのファイルを読んだ後もどこか理解が曖昧になってしまいます。  
このように本来一つのViewに関するものである情報がさまざまな箇所に散らばることで、プログラムを把握することが難しくなり仕様の追加・変更によりコードを変更した時にどこに影響が出るのかもよくわからなくなってしまいました。  
こうした複雑さViewModel全体に広がりViewModelのコードはまさにカオスで、開発の度にコードを読み直す必要がありました。  
そしてprotocolの既定実装では格納プロパティを持てないため、仕様の追加・変更によっていつこの設計が崩壊してもおかしくありません。  
今回のケースではどんなにコードの重複を減らせたとしても、ViewのModelであるViewModelはView毎に責務をまとめる必要がありました。  
これはアプリケーションにおけるViewModelの立ち位置を考えず、コードの重複を減らすことだけに目がいってしまったがための失敗です。  
このように設計を行う際はコンポーネントのアプリケーションにおける立ち位置や関連するコンポーネントとの関係を考えなくてなりません。  
そうすることで数ある中からその開発により適切なアプローチを選び出すことができるようになります。  

### この一連の記事で書かれていることも全て関係性についてである

これはコインの裏表ですが、設計を考える際に関係性を考えなくてはいけないということはいかなる設計論の背後には関係性が提示されているということができます。  
設計論ではマクロからミクロに至るまでさまざまな技術やパターンそして概念が登場し、それら全てを別個のものとして理解していてはあまりに情報量が多く目が眩んでしまいます。  
しかしそうした中それらの全ての背後の核心にあるのが関係性であることを把握していれば詳細に圧倒されることなく、設計論の概念を理解する助けになると思います。  
この一連の記事でもこのあとアプリケーションのさまざまな箇所についてさまざまな視点からスケールしやすい設計を考えていきますが、そこで書かれていることは全てあるコンポーネントを理解しその責務と他のコンポーネントとの関係性を見つけるための作業、もしくは一つのアプローチということになります。  
補足：コンポーネントが先にあってそれから関係性を構築するのか、関係性を構築するためにコンポーネントを作るのかというのはケースバイケースだと思うのですが、これまでのプログラミングの歴史におけるアーキテクチャの探究の中でアプリケーションにとって大事なコンポーネントはほとんど出揃っていると考えています。  
また既存で普及しているコンポーネントから考えた方が私も作業しやすいし、皆さんも理解しやすいと思います。  
なので基本的にこの記事では既存のコンポーネントを利用しながらそれらの関係性を考えていくというスタイルで話を進めます。  

## 準備の準備編(本記事)のまとめ
-クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想である
-レイヤードアーキテクチャはクリーンアーキテクチャの原型ともいえ、その主な目的はアプリケーションをUI/Application/Domain/Infraという責務の集まりと捉えることによって開発時にそれぞれの責務の関心を分離することである。
-設計とはアプリケーションにおいて開発しやすい関係性を構築することである


<a name="footnote1">*1</a>: ここでいうコンポーネントとはアプリケーションの構成要素のことを指しており特に特別な意味はありません。MVPでいうところのModel/View/Presenter、FluxでいうところのView/Action/Dispatcher/Store等です。   
「構成要素」と書いても良いのですが、漢字だと画数が多く記事内での頻出単語でもあるため文章がガチャガチャした感じになるので「コンポーネント」と表現します。

<a name="footnote2">*2</a>: GUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」にあるとしましたが、GUIアーキテクチャと関連する概念であるPresentation Domain Separationと照らし合わせると自分の理解に少し曖昧な点があるのでもしかしたら少し正確さに欠ける表現かもしれません。  
とはいえ大筋では合っているのは確かですし、記事の内容には影響はありません。  
曖昧に思われる点についての詳細は補論「GUIアーキテクチャとPresentation Domain Separation」に記しました。
