
# iOSアプリでスケールしやすいアーキテクチャを考えてみた(準備の準備編)

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。(全部書いてから一気にあげようと思ったけど予想以上の大変で無理でした。😅)  
(1)**設計を理解するためのレイヤードアーキテクチャ編 <-本記事**  
(2)設計を理解するためのクリーンアーキテクチャ編(執筆中)  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への(準備の)準備編として設計の概観を理解するためレイヤードアーキテクチャを説明しますので、  
「レイヤードアーキテクチャはもう知ってるよ」という人は次のクリーンアーキテクチャ編へ🚅、  
「レイヤードアーキテクチャもクリーンアーキテクチャもわかってるし」という方は概要編から読んでいただいた方が良いと思います。✈️  



## 始めに  
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの言葉の定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物。  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるようなもの。  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっていることが多いと思うのでこの記事では上のように区別することとします。  
  
また文章が進むにあたって他にも言葉の定義を明確にすることがありますが、その都度このように補足を書いていると話が逸れてわかりづらくなってしまうと思うので以後必要になりそうな細かい補足はすべて脚注として記事の終わりにまとめて記載し、関連箇所に脚注へのリンクを添える形式とします。  
ただ記事の構成上必要だと思われるようなものは補足的な内容でも本文内に記します。  



## 目的(記事全体で書かれていること)
現在モバイルアプリの開発ではMVCを始め、MVP・Flux・クリーンアーキテクチャやその他様々なアーキテクチャが採用されています。  
これらのアーキテクチャはアプリケーション開発を行う際にとても有効で、作業をする上で大きな指針を開発者に示してくれますし、コミュニケーション時の共通言語としても役立ちます。  
ただこうしたアーキテクチャはアプリケーション構造の概観を提示してくれてはいますが、その詳細についてまでは言及していません。  
そのためアプリケーションの最終的な品質は個々の設計者・実装者に大きく左右されることになり、本来問題解決のために利用されているはずのアーキテクチャの中で別の問題を引き起こしてしまうということがあります。  
巷でよくいうFatViewController、FatViewModelといった問題ですね。  
またそれぞれのアーキテクチャはいずれも特定の問題領域に注目して作られているためそこには少なからず視点の偏りがあります。  
このような状況もあり、私は個々のアーキテクチャを学んでもアプリケーション設計について理解できている感じがしませんでした。  
それぞれのアーキテクチャの形式やメリットは理解できても、それらが設計全体において何を意味しているのかイマイチ良くわからなかったのです。  
このような曖昧な理解は、先ほどのFatViewControllerのようにアーキテクチャの中でまた新しい問題を作ってしまう原因になりえます。  
なので今回、設計を俯瞰的に理解するために様々なアーキテクチャを参考にしながらそこで得られたエッセンスだと思う要素とiOSアプリの構成を照らし合わせて、自分が保守・変更しやすいと思えるようなアプリケーション開発における雛形のようなものを考えてみました。  
本記事を含めた一連の記事で書かれていることはそのアーキテクチャの説明とそこに至るまでに得られた知見をまとめたものです。  
## 前提
・SwiftUIは扱いません。  
・作成したサンプルアーキテクチャはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
・FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルアーキテクチャでは採用されていません。  


## 設計を理解するためのクリーンアーキテクチャ

「設計を俯瞰してみる」ということを最初の目的として記事を進めていこうと思いますが、なんの手がかりもなしに理解することは難しいです。  
なのでまずクリーンアーキテクチャを通して設計を理解していきたいと思います。  
既存のアーキテクチャの中からクリーンアーキテクチャを選んだのは、クリーンアーキテクチャの以下の特徴が理由です。  
1. 具体的なコンポーネント<sup>[*1](#footnote1)</sup>に依存しておらず、設計の思想を提唱している  
2. アプリケーション全体を主要な関心の対象としている  
3. 1と2の特徴を持ったアーキテクチャを総括してまとめたものである  


それぞれの詳細について簡単に説明しますと、  
1に関してはクリーンアーキテクチャにはMVPのPresenterやFluxのStoreのようにアプリーケーションに必ず含まなければいけないコンポーネントは存在しないということです。  
クリーンアーキテクチャはそのような具体的なコンポーネントには依存せず、アプリケーションを責務や性質により複数のグループに分割しそれらのグループがどのように連携するのかという考えを提示しています。  
2についてはMVC・MVP・MVVM等のアーキテクチャは一般的にGUIアーキテクチャ<sup>[*2](#footnote2)</sup>と言われ、主にアプリケーションのUIとその他を分離することに注目していますが、クリーンアーキテクチャはアプリケーション全体を主要な関心対象としています。  
3はそのままなのですが、1と2の特徴を持ったものとして他にもレイヤードアーキテクチャ・ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等があるなか、クリーンアーキテクチャはこれらのアーキテクチャを総括したような立ち位置にあるアーキテクチャです。  

クリーンアーキテクチャの以上のような特徴が設計を考える上で何を意味しているのかということは後ほど説明しますが、これらのことを簡単にまとめると「クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想」であるということです。  
これは「設計を俯瞰して理解する」という私たちの目標と完全に合致しています。  
ということでまず最初の目標としてクリーンアーキテクチャを通してアプリケーション設計への理解を深め、私たちの設計に関する共通認識を作っていきたいと思います。  

## クリーンアーキテクチャへの障壁
ただクリーンアーキテクチャと言えばこの円図が有名ですが、これが非常にとっつきづらいです。　　
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%　>
 
<sup>参考: [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)</sup>  

図が丸いのでどこからどう読んでいけばよいかわかりませんし、そもそもなぜ円なのかもよくわかりません。  
クリーンアーキテクチャを理解するためにはまず内容以前にその背景にあるコンテクストを理解する必要があります。  
なので本記事ではこの円図の背景にある考えを理解するためにクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャから学んでいきたいと思います。

## クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ

レイヤードアーキテクチャはアプリケーションを責務によって複数のグループに分割します。  
これは先ほどクリーンアーキテクチャの特徴として紹介しましたが、レイヤードアーキテクチャも同様です。  
そして分割された複数のグループが単一方向にのみ依存するような関係性を持っており、アプリケーション全体が複数のグループが積み重ねられて層をなしているかのような構成に思えるためレイヤードアーキテクチャ(layered architecture)なわけです、そのままですね。  
レイヤードアーキテクチャの目的はこの責務による分割と単一方向の依存関係によってそれぞれの層毎に開発の関心を分離することにあります。  
これによって開発者は開発時、常にアプリケーション全体に注意を向ける必要がなくなり、自分が担当している責務の層に集中することができるようになります。  
何層に分けるかについてはいくつか考え方があるのですが、私はアプリケーション設計を理解するという目的においては以下に示すように4つの層に分けるのが良いと考えているので今回はそれを紹介します。  

## レイヤードアーキテクチャの概要
レイヤードアーキテクチャの概要は以下の通りです

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/レイヤードアーキテクチャの概要.png" alt="レイヤードアーキテクチャの概要" width=60%　>


>補足  
>レイヤードアーキテクチャの層であるUI/Application/Domain/Infrastractureという言葉は記事の中で他の用法でも利用されます。  
>なので以後、アーキテクチャにおける層を指す場合は英字で、より一般的な文脈で使われる場合はカタカナで表記することとします。  
>例:  
>Application(層) -> アーキテクチャにおけるアプリケーション層  
>アプリケーション -> プロダクト、アプリケーションプログラム等 
> 
>またInfrastructureはInfraと省略して表記します。  


### Domain層とApplication層
各層の内容はだいたい上の図に書かれている通りですが、Domain層とApplication層については少しわかりづらく、また両者の区別もしづらいと思うので説明します。


#### Domain層

まずDomain層から説明します。  
ここでのドメインとはそのアプリケーションが現実で従事する**業務領域**を指し、Domain層にはその業務に関する知識やルールを表現したデータやメソッドが含まれます。    
例えば銀行アプリのドメインは銀行業務全般であり、Domain層には取引の際のルール、顧客の口座等を表現する知識やロジックが定義されます。  

#### Application層
一般的にはApplication層は「アプリケーション固有のデータ・ロジック」等と定義されていますが、もう少し平たくすると「ユーザーから見たアプリケーションの機能、またビジネスロジックの内ドメインとは関係しないものを定義・実装する場所」だと言えると思います
ただこれでも依然として具体性にかけてると思いますので補足します。  

まず「ユーザーから見たアプリケーションの機能」というのは銀行アプリで言えば「お金の預入/引き出し/振り込み」等が当たります。
「ユーザーから見たアプリケーションの機能」と定義が長たらしい理由は、「アプリケーションの機能」という定義だけでは先ほどの「お金の預入/引き出し/振り込み」というような機能を抽象化して「口座のお金の操作」としまとめてしまう可能性があると思ったからです。
Application層の主な役割はそのアプリケーションで何ができるのかを**具体的**に定義し示すことです。
そのため具体性を保つためユーザー目線で機能の定義をすることが重要で、そうすることで開発者が作業するのに役立ちます

そして後半の「ビジネスロジックの内ドメインとは関係しないもの」という定義も遠回しでわかりづらいのですが、これも具体例を使って説明します。
また銀行アプリを例に説明すると、そのアプリに「取引履歴をエクセル形式で出力する」機能があるとします。  
この「取引履歴をエクセルで出力する」機能はApplication層に定義しますが、その処理は大きく「取引履歴データの取得」と「取得したデータのエクセルファイル形式への変換」に分けられます。  
このうち「取引履歴データの取得」は銀行業務に該当するのでDomain層に定義されますが、「取得したデータのエクセルファイル形式への変換」は銀行業務ではないためApplication層に定義します  
このようにドメインとは関係なく、また単体ではアプリケーションの機能としては成り立たないような責務もアプリケーション固有のデータ・ロジックとしてApplication層に属すことになります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/取引履歴データをエクセル形式で出力する例.png" alt="取引履歴データをエクセル形式で出力する例" width=60%　>  

#### Domain層とApplication層の関係
一部例外はありますが、基本的にはApplication層ではユーザー目線でアプリケーションの個々の機能を定義して、Domain層でApplication層の内部で利用されるデータ・ロジックを定義すると捉えて良いと思います。  
こうすることで開発者は機能単位で作業がしやすく、またそこからDomain層のクラス・メソッドを再利用することでコードの重複を減らせます。
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/Application層とDomain層(銀行アプリ).png" alt="銀行アプリを例にしたApplication層とDomain層の関係" width=70%>  

ここまででみてきたようにApplication層とDomain層は概念的に切り離すのが難しく、レイヤードアーキテクチャの中でも他の組み合わせと比べて密接な関係性にあります。  
しかしそれでもレイヤードアーキテクチャの目的である関心の分離はApplication層とDomain層の関係にも当てはまり、Domain層がApplication層にどう利用されているかは意識されるべきではありません。  

### ビジネスロジックとは
先ほどの[Application層](#Application層)の説明の中で「ビジネスロジック」という言葉が使われていますが、この言葉は「ビジネス」と「ロジック」という日常的によく使う単語を組み合わせたものであるためなんとなく使われることが多いと思うので説明します。  
[wikipedia](https://ja.wikipedia.org/wiki/ビジネスロジック)にはビジネスロジック に関して明確な定義はないとしながらも、「実世界のビジネスオブジェクトをモデル化したもの」と紹介しています。  
この表現でもなんとなくはわかると思いますが、もう少し身近な言い方をすると「アプリケーションに関する仕様書をデザイン/ビジネス/技術の3つにカテゴライズした場合にビジネス仕様書に含まれるもの」と言っても良いと思います。  
アプリケーションに関する仕様のうちビジネスチームが関わるロジックであるためビジネスロジックなわけです。  
これをレイヤードアーキテクチャに当てはめるとちょうどApplication層とDomain層を合わせたものをビジネスロジックと表現していることになります  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/アプリケーションの仕様書とレイヤードアーキテクチャの関係.png" alt="アプリケーションの仕様書とレイヤードアーキテクチャの関係" width=60%　>  

このようにAppplicationとDomainの2つの層を一括りにして表現している「ビジネスロジック」という言葉が開発において頻繁に使われているということからもこの2層が密接に関係していることが伺えます。  
レイヤードアーキテクチャには4層ではなく3層構造で捉える見方もあるのですが、その場合はこのApplicationとDomainが一つにまとまった形になっています。  
ネットで調べていると、この3層構造のApplicationとDomainをまとめた表現として"Application"だったり"Domain"などが使われているケースもあるのですが、そうすると4層構造におけるApplicationとDomainと混同してしまうので私はBusiness Logic(ビジネスロジック)と表現するのが良いと思っています。
のちに紹介する私が作成したサンプルプロジェクトでもディレクトリ名としてこのBusiness Logicを使っています。  

### レイヤードアーキテクチャの依存関係

#### 依存は一方向のみ
レイヤードアーキテクチャは層の分割に加えてそれぞれの層の関係性の定義も記しています。  
最初のレイヤードアーキテクチャの図でも説明されていますが、それぞれの層を  
UI-Application-Domain-Infra  
という順番に並べた場合、依存方向は左から右への一方向のみであるというルールです  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/レイヤードアーキテクチャの依存ルール.png" alt="レイヤードアーキテクチャの依存ルール" width=60%>  

#### 層を跨いだApplication層からInfra層への依存
しかし例外というわけではないのですが一つ注意しておきたいのがDomainを跨いだApplication->Infraという依存関係もありえます。  
これは実際のアプリの機能を考えてみればわかりますが、例えばアプリのログイン状態はDomainとは関係ないのでApplication層のデータですがこのログイン状態は次回起動時も引き続き利用するべき状態なのでInfra層の永続化機能で保存する必要があります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/ApplicationからInfraへ依存.png" alt="ApplicationからInfraへ依存" width=60%　>

このようにアプリケーションにおいてはApplication層のデータをInfra層を使って操作することは少なからずあるのでApplication->Infraという依存関係は自然と発生します。   
しかしこの場合も依存方向が一方向であるということは同じです。  

#### Application層からInfra層への依存以外で層を跨いだ依存はない
ここで一つ疑問に思うのが、「Application->Infrastractureという依存関係がありえるのならば論理的にはUI->Domain/Infraというケースもあるのでは？」ということです。  
しかしこのような依存関係は実際の開発ではありえません。  
なぜなら既に述べた通りApplication層は「ユーザー目線でアプリケーション機能」を定義している場所であり、言い換えるとこのApplication層はユーザーの要求に応えるべく複数のDomain層の処理を連携させています。
そのためUI層がApplication層を飛び越えてDomain/Infra層にアクセスする場合、Domain/Infra層の処理の連携をUI層が担うこととなり、関心の分離が破られUI層のコードが肥大化・複雑化していきます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/UIからDomainとInfraを利用.png" alt="UIからDomain/Infraを利用した場合" width=70%　>



ケースによってはApplication層の実装が冗長に感じる場合はあるかもしれませんが、そこでApplication層を省略してUI->Domainの依存を許容してしまうとアプリケーション全体でUI->ApplicationとUI->Domainの二つのフローを持つことになるため結果としてApplication層を省略することによるコストカット以上に設計・開発の複雑さが増え開発コストが嵩むことになります。  

このようにUI->Domain/Infraという依存関係を構築してもアプリケーションの開発になんのメリットももたらさず、むしろ複雑にしてしまうだけであるため実際の開発ではあり得ないと考えてもらって大丈夫です。  

これら4層の依存関係で少し変わったケースがあるのは先に説明したApplication->Infraのみです。  

以上でレイヤードアーキテクチャの基本的な説明は終わりですが、クリーンアーキテクチャへ進む前にレイヤードアーキテクチャについて何点か考えることで設計への理解を深めたいと思います。  

## レイヤードアーキテクチャの層の分割は4つが適切か？

レイヤードアーキテクチャの説明の冒頭で分ける層は4つで良いと書きましたが、本当に4つで良いんでしょうか？  
ここでは4つの層が適切であるという私なりの根拠をアプリケーションの層を一つ一つ分割していきながら説明していきたいと思います。  

### アプリケーションをビジネスロジックとビジネスロジック以外に分ける

まずアプリケーションを「ビジネスロジック」と「ビジネスロジック以外」というように分割します。  
アプリケーション設計には[Presentation Domain Separation(プレゼンテーションとドメインの分離)](https://bliki-ja.github.io/PresentationDomainSeparation/)(以下PDSと表記)という考え方がありますが、これはアプリケーションをビジネスロジックとその他に分けるものです。  
なぜ最初にビジネスロジックが抜き出されるのかというと、やはりここがアプリケーションプログラムの機能的中心であり、また他の層とは異なりその実装がプログラミング言語による純粋なデータ宣言とロジックによってなされるからだと考えます。
ビジネスロジックを他と切り離すことで再利用が可能になり、またテストもしやすくなります。  


#### プレゼンテーションとドメインの分離(Presentation Domain Separation)についての補足
PDSについては2点ほどわかりづらいところがあると思うので補足します。  
##### 1 ドメイン=ビジネスロジック
まず最初にPDSのドメインをビジネスロジックと置き換えていることからもわかる通り、ここでのドメインは実質的にはApplication層とDomain層を含んでいます。  
実質的にはというのは概念的な意味としてはこのドメインはレイヤードアーキテクチャでのドメインと同じ「業務領域」を指していると思いますが、そもそもPDSはアーキテクチャではなく設計原則であって、ここでいうドメインは具体的な層やコンポーネントを指しているわけではありません。
そしてPDSのドキュメントを読むにその第一の主張はアプリケーションの機能に関するロジックと他の部分を切り離すことにあると考えられるので、ここでのドメインをレイヤードアーキテクチャの文脈に照らし合わせるとApplication層を含めたビジネスロジックと捉えた方が正しいと思います。

##### 2 プレゼンテーションとはUIを含めたドメインと連携する全ての機構を含む
次にプレゼンテーションという言葉は一見UIを想起させますが、ここにはInfraも含まれます。  
[PDSのドキュメント](https://bliki-ja.github.io/PresentationDomainSeparation/)には最後に補足のような形で以下のように書かれています。  

>人間ではなく、コンピュータ相手の Web Services だって、プレゼンテーション部分です。  
>ですから、ドメイン部分のコードと Web Services 部分のコードをごちゃまぜにしてはいけないのです。  
>外部APIにしてもそうです。  

上の引用文から推察するに、どうやらここでいうプレゼンテーションはUIのみを指しているわけではなくドメインと連携する外部機構全てを指していると捉えた方が良さそうです。  
この意味でPDSという概念ではプレゼンテーションよりもドメインにより重きが置かれているように思います。  
冒頭でのPDSの定義を「ビジネスロジックとプレゼンテーション」ではなく「ビジネスロジックと**ビジネスロジック以外**」と表現したのもそのためです。

### ビジネスロジック以外をUIとInfraに分ける
これは特に説明不要でしょう。  
PDSではこの2つはドメインに対する外部機構ということでまとめられましたが、一般的にユーザーとの接点であるUIとアプリケーションを下で支える技術基盤の役割を担うInfraを区別することには異論はないと思います。  
ただUIとInfraを区別することに違和感がなくても、永続化機構や端末機能をInfraと一つにまとめることには違和感がある人がいるかもしれません。  
確かに永続化機構や端末機能は役割が異なる部分があり、場合によってはそれぞれをData、Deviceと区別します。  
しかしどちらもアプリケーションの機能を技術的に裏で支えているということは共通しており、また設計上でもUIとDomainの関係性は「UI->Domain」となりUIからDomainを呼び出す形になりますが、Data/Deviceはともに「Domain->Data/Device」という依存関係でありDomainから呼び出されるコンポーネントとしてアプリケーション構造上の立ち位置は同じです。  
そのため設計の概観を捉える上ではこれらは一つにまとめた方がわかりやすいと思っています。  
なのでこの記事でも必要であればData/Deviceと区別して表現しますが、そうでなければInfraとして括ることとします。  

### ビジネスロジックをApplicationとDomainに分ける

最後にビジネスロジックをApplicationとDomainに分けます。  
この2層は既に説明した通り非常に密接に関わっていますが、やはり責務の質が異なります。
また設計論においてもFlux/Reduxを筆頭に近年Application層の状態を管理することを目的としたアーキテクチャが注目されており、
そしてドメイン層に注目した開発・設計論であるドメイン駆動開発はその提唱以来多くの人に支持されています。  
このようにApplication層とDomain層は個々の設計論がアーキテクチャを語る上で重要な存在となっていて、それぞれが設計において大きな役割を持っていることがわかると思います。  
そのためアプリケーション設計を理解する上で、Application層とDomain層は独立した2つの層として捉えた方が良いと考えています。

### この4層によってアプリケーションの提供元である企業から提供先であるユーザーまでしっかり捉えている

さて、アプリケーションの層をその必要性を考えながら一つ一つ分けていったのですが、私がこの4層が最適だと思う理由はこれによってアプリケーションの端から端までをしっかりと表現しているからです。  
端から端までとはアプリケーションの提供先であるユーザーとの接点となるUIと提供元となる企業もしくは事業のことです。  
UIに関しては説明するまでもないと思いますが、企業(事業)について説明するとDomainとは業務領域と説明しましたが別の言い方をするとその企業がアプリケーションを通して提供している事業の知識・ルールを記述している箇所であるともいうことができます。  

このように4つに分割することでアプリケーション上でその提供先であるユーザーとの接点になるUIと提供元となる企業(事業)をしっかりと捉えることができるようになっているのがわかると思います。  
もしこれより少ない層にしてしまうとUIとInfraをPresentationとしてまとめたり、ApplicationとDomainをBusiness Logicとしてまとめたりとアプリケーション開発において異なる責務を一緒くたにしてしまうことにより複数の問題を混同してしまい、うやむやにしてしまう可能性があります。  
また逆にこれ以上層を分けていったとしても詳細に立ち入りすぎてアプリケーションの概観を理解するという点においては必要以上に複雑になりすぎてしまうと考えています。


## アプリケーション設計においてレイヤードアーキテクチャからわかること
本記事の最後にアプリケーション設計においてレイヤードアーキテクチャから学べることを考えていきたいと思います。

### 設計とは関係性を構築することである
これに関していろいろと意見はあると思うのですが、ここで私が述べたいことは「設計とはアプリケーションにおいて開発しやすい関係性を構築すること」であるということです。  
レイヤードアーキテクチャではアプリケーションをその責務や性質の違いから4つのグループに分類しました。この一番のメリットは「関心の分離」です。  
それぞれの層が他の層に影響を与えるのは自身が返り値として出力するデータのみです。(メソッドの返り値ではなく、他の方法でデータを異なる層へ出力している場合もあります。)    
そのためそれぞれの関心が分離され、各層の変更によるアプリケーション全体への影響は非常に限定されます。  
そしてそれぞれの層の依存関係は単一方向なので、最終的にプロダクトとして4つの層が連携することで複雑になってしまう恐れもありません。  
このようにレイヤードアーキテクチャでは責務によってアプリケーションを分割しそれらをシンプルな関係性によって構築することによって全体の構成がより具体的になり、開発のさまざまな面で予測しやすくなるため開発効率が大きく上がります。  
また開発者の心理面から言ってもそれまでアプリケーションと漠然と捉えていたものをUI/Application/Domain/Infraというより具体的な責務の集まりと捉えることによってアプリケーション開発に対する見通しがよくなり開発に対する心理的負担はだいぶ軽減されると思います。    
  
ここでは記事の都合上レイヤードアーキテクチャの流れから「設計とは関係性を構築すること」だと話していますが、これはなにもレイヤードアーキテクチャに限ったことではありません。  
MVCはアプリケーションをModel-View-Controllerの構成で捉えた上でそれらの関係性を定義しているということができますし、他のアーキテクチャも同様です。  
また、よりミクロな観点で言えばデザインパターンはアプリケーションにおける特定機能の実現のためのパターン(関係性)を提示おり、SOLID原則はその関係性が適切に保たれているかどうかの判断基準であるということもできます。  

### 関係性の複雑さ=アプリケーションの複雑さ

このようにアプリケーション設計のマクロからミクロレベルに至る全ての概念やテクニックは「関係性」を定義しているといって良いと思いますが、これほどまでに関係性が重要な理由はそれがアプリケーションの複雑さを直接的に決定しているからです。  

いくつか具体例を出して説明します。

### Fat ViewControllerの問題

レイヤードアーキテクチャはUI-Application-Domain-Infraという構成であるということを説明しましたが、これらをMVCアーキテクチャの文脈に当てはめるとUIを除くApplication/Domain/Infraは全てModelに分類されます。


>補足  
>・iOSMVCのControllerに当たるViewControllerはUIKitに含まれていることからわかる通り、   
>  Viewの操作を行う役割を担いUIの仕様を把握しているのでレイヤードアーキテクチャではUI層に該当します。
>   
>・MVCにおいて厳密にInfraがModelに分類されるのかは個人的に疑問なのですが、  
>　少なくともネットでMVCの概要を調べるとInfraをModelに含めてる記事は散見していますし、  
>　何よりMVC(Model-View-Controller)のどれかに分類するなら消去法でModelしかないのでここではそういうことで話を進めます。  

そうするとレイヤードアーキテクチャにおいて異なる階層に属していたApplication/Domain/Infra層のクラスは全てModelという一つのカテゴリーの中に並列に並べられることになり、iOSMVCでは以下のような構成が成立するように思えます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/単純に考えたMVC.png" alt="Modelを深く考えず設計した時に起こりうるMVCの構成" width=70%> 

このような構成は図でみると一見問題ないようにみえますが、実際の開発では大きな問題を生み出します。  
その主な原因はController(ViewController)とModel間の関係性の曖昧さです。  
Application/Domain/Infraと役割の異なるコンポーネントを全てModelとしてしまったために、ViewControllerにとってModelがどのような役割なのかはっきりとせず、その結果各Modelクラスの責務が曖昧になってしまうのです。(Modelの役割が曖昧だからController-Modelの関係がわかりづらいともいえます。)  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/ViewController-Modelの関係性.png" alt="Modelの責務の曖昧化" width=60%> 

そしてそのようなModelクラスの曖昧さを解決するのは、結果的にViewControllerの責務となります。  
どんなにViewController-Model間で問題を抱えていてもViewではユーザーに適切な形で情報を表示しなくてはなりません。  
そのためViewControllerはViewController-Model間で抱える問題を全て解決してから本来の責務であるViewの操作を行うことになるため、責務が膨れ上がりコードが肥大化していきます。  
こうして生まれるのが俗にいうFatViewControllerです。

>補足
>ここで述べたFatViewControllerの問題はレイヤードアーキテクチャの依存関係のところでも書いた[UIがApplication層を跨いでDomain/Infraを利用した場合の問題](#Application層からInfra層への依存以外で層を跨いだ依存はない)と外面的には同じです。  
>ただレイヤードアーキテクチャの場合ではModelをしっかりとApplication/Domain/Infraと区別した上でその依存関係の誤りによって発生してしまったのに対し、  
>こちらのMVCのFatViewControllerではそもそもApplication/Domain/Infraの区別ができていません。  
>そのため問題の原因はより複雑であり、さらにはModelの責務が曖昧になっていることさえ気づかず無意識に起こしてしまっている可能性もあるため状況としてはより深刻であると思います。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/FatViewController.png" alt="FatViewController" width=70%> 

もちろんこれはiOSMVCの理想的な形ではありません。[AppleのViewControllerに関するドキュメント](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)にも  

>you should minimize the view controller’s role in managing the actual data.

とあり、ViewControllerのデータの操作は最小限にするべきと記されています。  
  
ただそうだとしてもModel-View-Controllerという責務の分担でApplication/Domain/InfraをまとめてModelと捉えてしまうのは致し方なく、  
さらにControllerからModelを利用するというMVCのシンプルな構図だけでは上のような問題は起こってしまいがちだと思います。  

MVCは概念としてはシンプルでわかりやすいのですが、実際の開発を考えるとApplication/Domain/InfraをModelという一言で済ましてしまうのは言葉足らずな感じがします。  

#### レイヤードアーキテクチャを取り入れたMVC

次に先程のMVCの構成にレイヤードアーキテクチャの考え方を加えてみます。  
図にすると以下のような感じです。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Images/レイヤードアーキテクチャを取り入れたMVC.png" alt="レイヤードアーキテクチャを取り入れたMVC" width=70%> 

上の図をみただけで、先ほどよりもわかりやすくなったのがわかるのではないでしょうか？  
ViewControllerから利用するモデルクラスはレイヤードアーキテクチャでいうApplication層モデルのみとなり、Controller-Model間の関係性が非常にわかりやすくなりました。  
そして既に説明した通りApplication層は「ユーザー目線でそのサービスが提供している機能」を定義しているため、Application層モデルのメソッドの返り値はユーザーの要求に直接対応しているはずです。  
そのためModelからの返り値をViewに表示するための ViewControllerの処理は必要最低限のものになり、ViewControllerで複雑なデータの操作を行う必要はなくなります。  
(ここでいう必要最低限の処理というのはInt型で返された時間を人が認識できる形式に変更したり、ログインしているかどうかというBool型を"ログイン中"という文字に変換する等です。Model(Application)はViewの仕様を知っているべきではありません。なのでApplication層のModelの返り値がユーザの要求に直接対応していたとしても例に出したようにコンピュータにとって都合の良いデータ形式を人間に都合の良いデータ形式に変換する作業は必要になることがあります。)  
このようにMVCのModelをレイヤードアーキテクチャによって再考することによって、Controller-Modelの関係性がシンプルでわかりやすくなり、またViewControllerで複雑なModelの操作を行う必要がなくなったためViewControllerの責務が肥大化することがなくなりました。  

#### MVCとMVC+レイヤードアーキテクチャの比較
単純なMVCとレイヤードアーキテクチャを採用したMVCを比較すると、レイヤードアーキテクチャを採用しているMVCの方が責務をより細かく分ける傾向にあるためコードやコンポーネントの量は多くなると思います。  
しかしそれでもレイヤードアーキテクチャを採用している方が各コンポーネントの責務がはっきりしているため、自身がどこから利用されまたまたどのコンポーネントを利用するのか悩む必要はありません。  
このようにそれぞれの責務・関係性が明瞭になることで開発者はどうコードを書くべきか考えるコストが減り、またチーム開発でのタスクの分担も行いやすくなるなど開発効率が大きく上がります。  
そしてこうした設計による開発効率へのポジティブな効果はそのプロジェクトの規模が大きくなればなるほど高くなっていきます。  

## if文ネスト構造によるコンテクストの複雑化

プログラミングをやっていると「(if文の)ネスト構造を深くすることは避けろ」ということをよく耳にすると思います。  
ネスト構造が否定的に捉えられている理由はif文が入り組むことによりコードの流れを追うのが難しくなること、また一つ一つのif文がコンテクストを提供しているのでそれらが入れ子になった結果全体のコンテクストが複雑になってしまうことにあることだと思います。  
そのような複雑なコンテクスト内では、内側のif文を読むためその外側のif文のコンテクストを把握しなければならず開発者は常に目の前のコード以外の事にも注意を払っていなければならないので認知負荷がとても高くなってしまいます。  
そしてネストが深くなるといういうのは関係性が複雑になっているということでもあります。

**ネストが深くなったif文の複雑さを示すためのコード例を差し込む
  
このように関係性の複雑さによってプログラムの流れは入り組んだものとなり、開発者はいくつもの状況を考えながら作業をしていかなければいけないためアプリケーション開発に大きな影響を及ぼします。  

### アプリケーションの関係性を考えることで適切な設計を見つける

関係性がアプリケーションに与える影響が大きい説明を二つのケースを例に説明しました。  
他にも該当するケースはいくつもあり挙げていけばキリがないですが、ここで私が関係性ということについて言及したのはこれが設計を考える上での思索や議論の滑り止めになると考えているからです。  
私たちがコードの設計について考えるときにとりうるアプローチは数多くあり、その中には互いに反対の方向性を持ったものもあります。  
あるケースではコードの重複を減らすために複数のコンポーネント分けて考えていたものをまとめて一つにするのが良いかもしれませんし、別のケースでは反対に責務の複雑性を回避するためあるコンポーネントから特定責務を取り出して別コンポーネントとした方がわかりやすくなるかもしれません。  
私たちはこうしたさまざまな解決方法の中から適切なものを選んでいく必要がありますが、その時にそのコンポーネントの背後(周辺)にある関係性を考えることが大きな助けとなります。  

### 関係性を考えなかった結果失敗したViewModelの設計

ここではその関係性を考えずに設計を行った結果失敗した経験を紹介し、アプリケーション設計において関係性を考えることの重要性を示したい思います。  
私はこのあとの記事で紹介するサンプルプロジェクトの作る際、ViewModelの設計を画面機能ごとにまとめようと考えました。  
画面機能毎にprotocolとその既定実装を書くことで再利用できるようにしてコード量を減らそうと考えたのです。  
しかしその結果ViewModelはとんでもなく複雑で、開発しづらいものになりました。  
その理由は今から考えればとても馬鹿馬鹿しいと思うのですが、ViewModelが「ViewのModel」だからです。  
ViewModelの中心にあるのはあくまで「View」であって「Viewの機能」ではありません。  
ViewModelの設計の根幹に「View」ではなく「Viewの機能」を据えてしまったことで、ViewModelの責務はそのViewModelクラスに書かれたコードとそのViewModelが適応するいくつものProtocolに散在することになりました。  
そのためViewModelの責務を理解するためにはいくつものファイルに書かれたProtocolを参照しながらそれらを頭の中でまとめあげ、さらにそこにViewModelクラス自体書かれている責務を加えなければなりませんでしたが、いくつもファイルを跨いでるうちに初めの方に読んだコードを忘れてしまうので全てのファイルを読んだ後もどこか理解が曖昧になってしまいます。  
このように本来一つのViewに関するものである情報がさまざまな箇所に散らばることで、プログラムを把握することが難しくなり仕様の追加・変更によりコードを変更した時にどこに影響が出るのかもよくわからなくなってしまいました。  
こうした複雑さViewModel全体に広がりViewModelのコードはまさにカオスで、開発の度にコードを読み直す必要がありました。  
そしてprotocolの既定実装では格納プロパティを持てないため、仕様の追加・変更によっていつこの設計が崩壊してもおかしくありません。  
今回のケースではどんなにコードの重複を減らせたとしても、ViewのModelであるViewModelはView毎に責務をまとめる必要がありました。  
これはアプリケーションにおけるViewModelの立ち位置を考えず、コードの重複を減らすことだけに目がいってしまったがための失敗です。  
このように設計を行う際はコンポーネントのアプリケーションにおける立ち位置や関連するコンポーネントとの関係を考えなくてなりません。  
そうすることで数ある中からその開発により適切なアプローチを選び出すことができるようになります。  

### この一連の記事で書かれていることも全て関係性についてである

これはコインの裏表ですが、設計を考える際に関係性を考えなくてはいけないということはいかなる設計論の背後には関係性が提示されているということができます。  
設計論ではマクロからミクロに至るまでさまざまな技術やパターンそして概念が登場し、それら全てを別個のものとして理解していてはあまりに情報量が多く目が眩んでしまいます。  
しかしそうした中それらの全ての背後の核心にあるのが関係性であることを把握していれば詳細に圧倒されることなく、設計論の概念を理解する助けになると思います。  
この一連の記事でもこのあとアプリケーションのさまざまな箇所についてさまざまな視点からスケールしやすい設計を考えていきますが、そこで書かれていることは全てあるコンポーネントを理解しその責務と他のコンポーネントとの関係性を見つけるための作業、もしくは一つのアプローチということになります。  
補足：コンポーネントが先にあってそれから関係性を構築するのか、関係性を構築するためにコンポーネントを作るのかというのはケースバイケースだと思うのですが、これまでのプログラミングの歴史におけるアーキテクチャの探究の中でアプリケーションにとって大事なコンポーネントはほとんど出揃っていると考えています。  
また既存で普及しているコンポーネントから考えた方が私も作業しやすいし、皆さんも理解しやすいと思います。  
なので基本的にこの記事では既存のコンポーネントを利用しながらそれらの関係性を考えていくというスタイルで話を進めます。  

## 準備の準備編(本記事)のまとめ
-クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想である
-レイヤードアーキテクチャはクリーンアーキテクチャの原型ともいえ、その主な目的はアプリケーションをUI/Application/Domain/Infraという責務の集まりと捉えることによって開発時にそれぞれの責務の関心を分離することである。
-設計とはアプリケーションにおいて開発しやすい関係性を構築することである


## 補論① アプリケーション設計における関係性とは
本記事内で設計においては関係性を考えることが重要であることを書きました。  
ここでは具体的にアプリケーション設計における関係性とは簡単に示したいと思います。
最初にアプリケーション開発(主にコーディング)において関係性とはどこで生まれるものなのでしょうか。  
私は大きくいって関係性が発生する箇所は3つあると思います。  
①コンポーネント内部  
②コンポーネント間  
③アプリケーション全体に対してコンポーネント役割、またそれらと開発者との間  


私は大きく以下2点がアプリケーションを複雑にしている原因だと考えました。  
(1)データフローが複雑になる  
(2)コンテクストが複雑になる  
最初にいっておくと(1)(2)は互いに排他的ではなく、関係性が複雑になることにより同時に起こってしまう現象です。  
それぞれについての内容は概要をみただけでわかると思いますが、簡単に補足したいと思います。  
(1)データフローが複雑になる  
関係性が複雑になってしまうことにより、アプリケーションのデータフローが複雑になってしまうことがあります。  
そしてデータフローが複雑なアプリケーションではコードを追うのが難しくなります。  
(2)コンテクストが複雑になる  
関係性が複雑になるとコンテクストが複雑になり、開発者は多くのことを同時に注意しながら作業しなければならないため認知負荷が高くなってしまうことは本記事内で書きました。  
記事内ではネスト構造と関連づけて紹介しましたが、コンテクストの複雑さを生み出すのはネスト構造に限った話ではありません。  
本来より大きなコンテクストとしてまとめることができるような箇所で、if文に限らず細かい分岐を行っているような設計だと開発者は些細な変化にも敏感になって開発を行わなればならないため神経質になり結果的にヒューマンエラーを引き起こす可能性が高くなります、等等。  
記事本文と比べると雑さが拭えませんが、簡単にアプリケーション設計における関係性を言語化してみました。  
テーマとしてはこれだけで記事が書けるくらい大きいなものだと思うので、もう少し煮詰めることができたら別記事で取り上げたいと思います。  

## 補論② GUIアーキテクチャとPDS(Presentation Domain Separation)
初めに言いますがこの補論は実質的な内容はほぼゼロでただの雑記です。  
本記事の初めにGUIアーキテクチャとは「アプリケーションのUIとその他を分離すること」と記し、その脚注で「少し正確さに欠ける表現かもしれない」と補足しました。  
ここではそれについて書きたいと思います。  
結論を先に言えばGUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」ではなく、PDSと同様に「ビジネスロジック(ドメイン)とその他を分離すること」ではないかという考えから「少し正確さに欠ける」のではと思っています。  
詳細を説明するためにGUIアーキテクチャとPDSについて説明します。  
まずMartin Flower氏の「GUI Architectures」と題された記事の中では以下の一節があります。  
```
At the heart of MVC, and the idea that was the most influential to later frameworks, is what I call Separated Presentation. The idea behind Separated Presentation is to make a clear division between domain objects that model our perception of the real world, and presentation objects that are the GUI elements we see on the screen. Domain objects should be completely self contained and work without reference to the presentation, they should also be able to support multiple presentations, possibly simultaneously.

意訳
MVCの核心、また後に登場するアーキテクチャにもっとも影響を与えた考えは私が「Separated Presentation」と呼んでいるものである。
この考えは私たちの現実世界に対するメンタルモデルを表したドメインオブジェクトと私たちが画面上でみるGUIに関するモデルを分離する事である。
ドメインオブジェクトは単独で動作可能であり、複数のGUIモデルにたいてい同時に対応することが可能である。
```
ここでは「MVCの核心」となっていますが、この記事のタイトルが「GUI Architectures」であることからもMVCはそのままGUIアーキテクチャに置き換えることが可能であると思いますし、そのためGUIアーキテクチャの特徴を「アプリケーションのUIとその他を分離すること」と紹介することに誤りはないと思います。  
次にPDSの方もみていきたいと思います。  
まずPDSの原則も同じMartin Flower氏により提案されたもので、記事内でも説明した通りPDSにおけるプレゼンテーションはUIのみならずWebAPIも含めたドメインと連携する外部機構全てを指しているためその特徴は「アプリケーションのUIとその他を分離すること」というよりも、「ビジネスロジック(ドメイン)とその他を分離すること」と表現した方が正しいと思います。  
そしてPDSのドキュメントには以下のような一節があります。  
```
This principle is the most prominent part of Model View Controller (MVC), indeed for many people MVC is how they describe this separation.
意訳
この原則はMVCにおいて最も重要なものであり、実際多くの人にとってMVCとはPDSを表現するための一つの形式である。
```
このPDSの引用文と先程のGUIアーキテクチャの引用文を照らし合わせると、GUIアーキテクチャの核心にある「Separated Presentation」と「PDS」がどちらもMVCで最も重要な概念と言われておりこれをまとめると「GUIアーキテクチャの特徴=PDS」と捉えて問題ないはずです。  
実際「iOSアプリ設計パターン入門」という本でもGUIアーキテクチャの根底にあるのはPDSだと書いていますし、その認識はこの本に限らずプログラマの世界では一般的なものだと思います。  
そして私がこの補論で言いたいことはGUIアーキテクチャと聞くとその概念の中心には「UI」があるように思いがちですが、実際にこの概念の中心になっているのはPDSと同じように「ビジネスロジック(ドメイン)」ではないかいうことです。  
そうやって理解した方がGUIアーキテクチャとPDS、またこのあと登場するクリーンアーキテクチャの間で主張の一貫性が生まれますし、逆にGUIアーキテクチャの中心を文字通り「UI」と捉えても設計の観点からあまり利点が見えてきません。  
なにはともあれGUIアーキテクチャが「UIとビジネスロジック(ドメイン)を分離すること」を目的としていることは間違いないですし、本記事のGUIアーキテクチャの初登場時点ではビジネスロジックもドメインもまだ登場していなかったため「UIとその他を分離すること」と表現することにしました。  
*この補論だとGUIアーキテクチャという概念をMartin Flower氏が提案したかのような印象を与えているかもしれませんが、そこまで確認できていません(恐らくそうだ
とは思いますが)。ただGUIアーキテクチャと調べるとMartin Flower氏の記事がでてきたので参照しました。PDSに関してはMartin Flower氏提案で合っていると思います。

## 補論③ Modelとはなにか？
記事内のFat ViewControllerに関する内容でMVCのModelにはInfraも含まれるとして話を展開しましたが、留意点として厳密にModelにInfraを含めることには違和感があるとも記しました。
ここではそれらの問題を踏まえながらModelとは何かということについて考えたいと思います。  
まずMVCの提案者であるTrygve Reenskaug氏の記事にはModelは以下のように定義されています。  
```
Models represent knowledge. 
(中略)
There should be a one-to-one correspondence between the model and its parts on the one hand, and the represented world as perceived by the owner of the model on the other hand. 
The nodes of a model should therefore represent an identifiable part of the problem.
意訳:
モデルは知識を表している。
(中略)
モデルとそのパーツはその設計者が問題としている領域に対する認識に対応しているべきである。
*「owner」を設計者と意訳しましたが、正確に言えばそのソフトウェアの発案者やアイディアを考えた人といった方が良さそうです

```
後半はだいぶ「ModelにInfraは含まれない」という主張に寄って意訳しているので(そうでないとわかりづらい文になると判断したため)テーマから考えるとフェアではない感じはあるのですが、それを差し引いてもこの定義でModelにInfraを含めることには違和感があります。  
冒頭の「知識」を意味する「knowledge」という言葉はドメインを含むビジネスロジックの文脈で使われることが多いですが、この言葉自体は抽象的でいかようにも解釈可能です。  
InfraのみならずUIも含めたアプリケーションを構成する全てがアプリケーションの知識であるというできます。  
ただこの定義の中で「認識」として訳されている箇所に当たる「perceive」という単語は「論理的な認識」ではなく「感覚による認識」を意味している言葉です。  
アプリケーションの技術基盤としての役割を担うInfraはこのような感覚による認識を反映させるようなコンポーネントではありませんし、むしろ感覚的な認識ではなく合理性や効率性を追及してロジカルに設計されるコンポーネントだと思います。  
この論文が発表された1979年にはまだWeb誕生しておらずネットワークを利用したアプリケーションは一般的ではないためデータベースやWeb APIはここには含まれないという見方もできますが、そもそも上で述べたような性質的な異なりからModelには本来データベースやWeb APIクライアントが直接的には含まれていないと思います。  
そしてTrygve Reenskaug氏のこのModelの定義は私にGUIアーキテクチャのドキュメントに書かれているドメインオブジェクトの定義を想起させます。  
```
domain objects that model our perception of the real world
意訳
現実世界に対する認識を型どったドメインオブジェクト
```
「perceived」と「perception」と同じ意味を持った単語が使われていることもありますが、それ以上にこの2つの文は「人の知覚による認識をモデル化したもの」という文意そのものが同じなように思います。
そうなるとやはりModelはアプリケーションを通して解決しようとしている現実の問題をコードで表現したものであると捉えるべきだと思います。  

補論③は未完


参考：  
書籍  
・iOSアプリ設計パターン入門
・ドメイン駆動設計
Web
・MVCモデルについて
・レイヤードアーキテクチャの視点
・レイヤードアーキテクチャを振り返る
・The Clean Architecture
・wiki(ビジネスロジック)
・Appleドキュメント(ViewController)
・GUI Architectures
・Presentation Domain Separation(日本語訳)
・MODELS - VIEWS - CONTROLLERS(Trygve Reenskaug)



<a name="footnote1">*1</a>: ここでいうコンポーネントとはアプリケーションの構成要素のことを指しており特に特別な意味はありません。MVPでいうところのModel/View/Presenter、FluxでいうところのView/Action/Dispatcher/Store等です。   
「構成要素」と書いても良いのですが、漢字だと画数が多く記事内での頻出単語でもあるため文章がガチャガチャした感じになるので「コンポーネント」と表現します。

<a name="footnote2">*2</a>: GUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」にあるとしましたが、GUIアーキテクチャと関連する概念であるPresentation Domain Separationと照らし合わせると自分の理解に少し曖昧な点があるのでもしかしたら少し正確さに欠ける表現かもしれません。  
とはいえ大筋では合っているのは確かですし、記事の内容には影響はありません。  
曖昧に思われる点についての詳細は補論「GUIアーキテクチャとPresentation Domain Separation」に記しました。
