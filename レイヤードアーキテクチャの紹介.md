
# iOSアプリでスケールしやすいアーキテクチャを考えてみた(準備の準備編)

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。(全部書いてから一気にあげようと思ったけど予想以上の大変で無理でした。😅)  
(1)**設計を理解するためのレイヤードアーキテクチャ編 <-本記事**  
(2)設計を理解するためのクリーンアーキテクチャ編(執筆中)  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への(準備の)準備編として設計の概観を理解するためレイヤードアーキテクチャを説明しますので、  
「レイヤードアーキテクチャはもう知ってるよ」という人は次のクリーンアーキテクチャ編へ🚅、  
「レイヤードアーキテクチャもクリーンアーキテクチャもわかってるし」という方は概要編から読んでいただいた方が良いと思います。✈️  



## 始めに  
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの言葉の定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物。  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるようなもの。  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっていることが多いと思うのでこの記事では上のように区別することとします。  
また文章が進むにあたって他にも言葉の定義を明確にすることがありますが、その都度このように補足を書いていると話が逸れてわかりづらくなってしまうと思うので以後必要になりそうな細かい補足はすべて脚注として記事の終わりにまとめて記載し、関連箇所に脚注へのリンクを添える形式とします。  
ただ記事の構成上必要だと思われるようなものは補足的な内容でも本文内に記します。  



## 目的(本記事で書かれていること)
現在モバイルアプリの開発ではMVCを始め、MVP・Flux・クリーンアーキテクチャやその他様々なアーキテクチャが採用されています。  
これらのアーキテクチャはアプリケーション開発を行う際にとても有効で、作業をする上で大きな指針を開発者に示してくれますし、コミュニケーション時の共通言語としても役立ちます。  
ただこうしたアーキテクチャはアプリケーション構造の概観を提示してくれてはいますが、詳細についてまでは言及していません。  
その結果アプリケーションの最終的な品質は個々の設計者・実装者に大きく左右されることになり、本来問題解決のために利用されているはずのアーキテクチャの中で別の問題を引き起こしてしまうということがあります。  
巷でよくいうFatViewController、FatViewModelといった問題ですね。  
またそれぞれのアーキテクチャはいずれも特定の問題領域に注目して作られているためそこには少なからず視点の偏りがあります。  
このような状況もあり、私は個々のアーキテクチャを学んでもアプリケーション設計について理解できている感じがしませんでした。  
それぞれのアーキテクチャの形式やメリットは理解できても、それらが設計全体において何を意味しているのかイマイチ良くわからなかったのです。  
このような曖昧な理解は、先ほどのFatViewControllerのようにアーキテクチャの中でまた新しい問題を作ってしまう原因になりえます。  
なので今回、設計を俯瞰的に理解するために様々なアーキテクチャを参考にしながらそこで得られたエッセンスだと思う要素とiOSアプリの構成を照らし合わせて、自分が保守・変更しやすいと思えるようなアプリケーション開発における雛形のようなものを考えてみました。  
本記事を含めた一連の記事で書かれていることはそのアーキテクチャの説明とそこに至るまでに得られた知見をまとめたものです。  
## 前提
・SwiftUIは扱いません。  
・作成したサンプルアーキテクチャはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
・FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルアーキテクチャでは採用されていません。  


## 設計を理解するためのクリーンアーキテクチャ

「設計を俯瞰してみる」ということを最初の目的として記事を進めていこうと思いますが、なんの手がかりもなしに理解することは難しいです。  
なのでまずクリーンアーキテクチャを通して設計を理解していきたいと思います。  
既存のアーキテクチャの中からクリーンアーキテクチャを選んだのは、クリーンアーキテクチャの以下の特徴が理由です。  
1. 具体的なコンポーネント<sup>[*1](#footnote1)</sup>に依存しておらず、設計の思想を提唱している  
2. アプリケーション全体を主要な関心の対象としている  
3. 1と2の特徴を持ったアーキテクチャを総括してまとめたものである  


それぞれの詳細について簡単に説明しますと、  
1に関してはクリーンアーキテクチャにはMVPのPresenterやFluxのStoreのようにアプリーケーションに必ず含まなければいけないコンポーネントは存在しないということです。  
クリーンアーキテクチャはそのような具体的なコンポーネントには依存せず、アプリケーションを責務や性質により複数のグループに分割しそれらのグループがどのように連携するのかという考えを提示しています。  
2についてはMVC・MVP・MVVM等のアーキテクチャは一般的にGUIアーキテクチャ<sup>[*2](#footnote2)</sup>と言われ、主にアプリケーションのUIとその他を分離することに注目していますが、クリーンアーキテクチャはアプリケーション全体を主要な関心対象としています。  
3はそのままなのですが、1と2の特徴を持ったものとして他にもレイヤードアーキテクチャ・ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等があるなか、クリーンアーキテクチャはこれらのアーキテクチャを総括したような立ち位置にあるアーキテクチャです。  

クリーンアーキテクチャの以上のような特徴が設計を考える上で何を意味しているのかということは後ほど説明しますが、これらのことを簡単にまとめると「クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想」であるということです。  
これは「設計を俯瞰して理解する」という私たちの目標と完全に合致しています。  
ということでまず最初の目標としてクリーンアーキテクチャを通してアプリケーション設計への理解を深め、私たちの設計に関する共通認識を作っていきたいと思います。  

## クリーンアーキテクチャへの障壁
ただクリーンアーキテクチャと言えばこの円図が有名ですが、これが非常にとっつきづらいです。　　
![クリーンアーキテクチャ円図](https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg)  
<sup>参考: [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)</sup>  

図が丸いのでどこからどう読んでいけばよいかわかりませんし、そもそもなぜ円なのかもよくわかりません。  
クリーンアーキテクチャを理解するためにはまず内容以前にその背景にあるコンテクストを理解する必要があります。  
なので本記事ではこの円図の背景にある考えを理解するためにクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャから学んでいきたいと思います。

## クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ

レイヤードアーキテクチャはアプリケーションを責務によって複数のグループに分割します。  
これは先ほどクリーンアーキテクチャの特徴として紹介しましたが、レイヤードアーキテクチャも同じ特徴を持っています。  
そして分割された複数のグループが単一方向にのみ依存するような関係性を持っており、アプリケーション全体が複数のグループが積み重ねられて層をなしているかのような構成に思えるためレイヤードアーキテクチャ(layered architecture)なわけです、そのままですね。  
レイヤードアーキテクチャの目的はこの責務による分割と単一方向の依存関係によってそれぞれの層の関心を分離することにあります。  
これによって開発者は開発時に常にアプリケーション全体に注意を向ける必要がなくなり、自分が担当している責務の層に集中することができるようになります。  
何層に分けるかについてはいくつか考え方があるのですが、私はアプリケーション設計を理解するという目的においては以下に示すように4つの層に分けるのが良いと考えているので今回はそれを紹介します。  

## レイヤードアーキテクチャの概要
レイヤードアーキテクチャの概要は以下の通りです
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/レイヤードアーキテクチャの概要.png" alt="レイヤードアーキテクチャの概要" width=80%　>

```
補足  
レイヤードアーキテクチャの層であるUI/Application/Domain/Infrastractureという言葉は色々な用法で利用されます。  
なので以後、アーキテクチャにおける層を指す場合は英字で、より一般的な文脈で使われる場合はカタカナで表記することとします。  
例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  
またInfrastructureはInfraと省略して表記します。  
```

### Domain層とApplication層
各層の内容はだいたい上の図に書かれている通りですが、Domain層とApplication層については少しわかりづらく、また両者の区別もしづらいと思うので説明します。


#### Domain層

まずDomain層から説明します。  
ここでのドメインとはそのアプリケーションが現実で従事する業務領域を指し、Domain層にはその業務に関する知識やルールを表現したクラスやメソッドが含まれます。    
例えば銀行アプリのドメインは銀行業務全般であり、Domain層には取引の際のルール、顧客の口座等を表現する知識やロジックが定義されます。  

#### Application層
Application層の定義は少し長くなるのですが、「そのアプリケーションの機能、またビジネスロジックの内ドメインとは関係しないものを定義・実装する場所」だと思ってください。  
もう一度銀行アプリを例に説明すると、そのアプリに「取引履歴をエクセル形式で出力する」機能があるとします。  
この「取引履歴をエクセルで出力する」機能は「そのアプリケーションの機能」にあたるのでApplication層に定義しますが、その処理は大きく「取引履歴データの取得」と「取得したデータのエクセルファイル形式への変換」に分けられます。  
このうち「取引履歴データの取得」は銀行業務に該当するのでDomain層に定義されますが、「取得したデータのエクセルファイル形式への変換」は銀行業務ではないためApplication層に定義します  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Application層の説明(取引履歴データをエクセル形式で出力する例).png" alt="Application層の説明(取引履歴データをエクセル形式で出力する例)" width=50%　>  



<a name="footnote1">*1</a>: ここでいうコンポーネントとはアプリケーションの構成要素のことを指しており特に特別な意味はありません。MVPでいうところのModel/View/Presenter、FluxでいうところのView/Action/Dispatcher/Store等です。   
「構成要素」と書いても良いのですが、漢字だと画数が多く記事内での頻出単語でもあるため文章がガチャガチャした感じになるので「コンポーネント」と表現します。

<a name="footnote2">*2</a>: GUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」にあるとしましたが、GUIアーキテクチャと関連する概念であるPresentation Domain Separationと照らし合わせると自分の理解に少し曖昧な点があるのでもしかしたら少し正確さに欠ける表現かもしれません。  
とはいえ大筋では合っているのは確かですし、記事の内容には影響はありません。  
曖昧に思われる点についての詳細は補論「GUIアーキテクチャとPresentation Domain Separation」に記しました。
