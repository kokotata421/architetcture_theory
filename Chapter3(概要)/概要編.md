
# iOSアプリでスケールしやすいアーキテクチャを考えてみた③-アーキテクチャ-の概要

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)設計を理解するためのクリーンアーキテクチャ編  
(3)**アーキテクチャ概要編←本記事**  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編で扱うアーキテクチャの概要を説明します。  
基本的な設計理論を前提としているので、そこから知りたいという方はレイヤードアーキテクチャ編、もしくはクリーンアーキテクチャ編から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

## 前回までの内容と本記事の内容
前回までの記事でレイヤードアーキテクチャ・クリーンアーキテクチャを通して設計の概要を掘り下げていきました。    
この記事では前回までで学んだ設計概論をもとに考えたiOSでスケールしやすいアーキテクチャの構成を紹介していきます。  

## アーキテクチャの構成
記事で紹介するアーキテクチャの構成は以下の通りです。  

構成をわかりやすく伝えるために上記のような図になっていますが、実際にはクリーンアーキテクチャを踏まえてプロトコルを利用してBusiness Logicは他の層に依存しないようになっています。

基本的にはクリーンアーキテクチャやVIPERで紹介されるiOSアプリの構成と大きく違うところはありません。  
概観での特徴はUI層においてViewContrllerとViewを明確に区別したり、Routerと同じようにAlertも一つの機構として切り出して、またApplication層でUseCaseだけではなく状態管理を目的としたStateを採用しているくらいでしょうか。  
ただ後ほど説明していきますが、一つ一つの層・モジュールの詳細は他と比べてかなり具体的になっていると思います。  

## 各層の概要

### UI層

#### ViewControllerとViewを分離する
先ほどの説明でも述べましたが、UI層ではViewControllerとViewを切り離しています。  
これらを分離させている理由やそもそも切り離しているとはどういうことなのかという詳細はViewController編、View/Alert編で書こうと思いますが、簡潔にいうとViewControllerとViewを明確に区別しないと各ViewControllerの責務の大きさは各画面の仕様によって大きく左右されることになるからです。  

#### Alertを一つのモジュールとして切り出す
これはアーキテクチャとして意識しているかどうかは別として多くの開発者が実践していることではないでしょうか？  
個々のアラートを別々にコーディングするとコードが重複するため、アラート機能のコードを抽象化して再利用可能なようにしている開発者は多いと思います。  
私がここで挙げているAlertも自分なりに工夫はしましたが、基本的にはそれらと同様のものになります。  

#### Routerをカスタム遷移にも対応させている
Routerは遷移処理をViewControllerから切り出したコンポーネントです。  
遷移処理を責務としているのは通常のRouterと変わりませんが、このアーキテクチャのRouterでは通常遷移だけでなくカスタム遷移もより実装しやすくするための工夫がなされています。  


### Application層

#### QueryUseCaseとCommandUseCase
「QueryUseCase」と「CommandUseCase」と見慣れない言葉が出てきましが、最初に言っておきたいのはこれらは私の造語であり、またスケールしやすいアーキテクチャを考えた結果というよりは一つ実験的な意味合いが強いです。  
実験的とは「アプリケーションの状態管理をFlux/Reduxのようにアプリケーション全体に影響を及ぼすような形でなく、あくまでApplication層の一部分の機構として実現させるとしたらどのような形式になるだろうか」ということです。  
Flux/Reduxは「アプリケーション状態管理をしやすいアーキテクチャ」という認識だけが広まり(少なくともモバイルアプリ開発では)、あまり設計においてFlux/Reduxというアーキテクチャがどういったものなのか俯瞰的に捉えている記事がないように思います。(歴の長いプログラマの方々は経験から自然と理解していると思いますが)　　
そのため特定の既存アーキテクチャの形式に依存しないことを目的としている本サンプルプロジェクトでは



