
# iOSアプリでスケールしやすいアーキテクチャを考えてみた③-アーキテクチャ-の概要

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)設計を理解するためのクリーンアーキテクチャ編  
(3)**アーキテクチャ概要編←本記事**  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel(Controller/Presenter)編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編で扱うアーキテクチャの概要を説明します。  
基本的な設計理論を前提としているので、そこから知りたいという方はレイヤードアーキテクチャ編、もしくはクリーンアーキテクチャ編から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

## 前回までの内容と本記事の内容
前回までの記事でレイヤードアーキテクチャ・クリーンアーキテクチャを通して設計の概要をまとめました。    
この記事では前回までで学んだ設計概論をもとに考えたiOSでスケールしやすいアーキテクチャの構成を紹介していきます。  

## アーキテクチャの構成
記事で紹介するアーキテクチャの構成は以下の通りです。  

構成を平面図でわかりやすく伝えるために技術的な依存関係に沿って示していますが、実際にはクリーンアーキテクチャを採用していてBusiness Logic層は他の層に依存しないようになっています。

基本的にはクリーンアーキテクチャやVIPERで紹介されるiOSアプリの構成と大きく違うところはありません。  
概観における特徴はUI層でViewContrllerとViewを明確に区別していること、Routerと同じようにAlertも一つの機構として切り出していること、またApplication層で状態管理を目的としたState/Eventを採用していることくらいでしょうか。(State/Eventについては後ほど説明します)  
しかし一つ一つの層・モジュールについては他のアーキテクチャと比べかなり詳細に立ち入っています。  
ちなみにアプリケーションのデータフロー(一部を除く)はRxSwiftによって実装されています。   

## 各層の特徴

### UI層

#### ViewControllerとViewを分離する
冒頭でも述べましたが、UI層ではViewControllerとViewを切り離しています。  
なぜそのようなことをするのか簡単に説明すると、ViewContorllerの主な責務は「入出力(イベント)の処理」と「UIの宣言・操作」です。  
この内「入出力(イベント)の処理」の量はUX的な観点から各画面で変動が起こることは考えづらいのですが、「UIの宣言・操作」に関してはViewの操作は手続的なプログラムになることが多い等、画面の仕様によってコードの量が大きく変わってしまいます。        
ストーリーボードなどを使わずUIの宣言もプログラムで記述している場合、画面間のコード量の違いはさらに大きくなるでしょう。  
そのためViewControllerから「UIの定義・操作」を行うViewを切り離すことで、画面の仕様による影響を最小限に留めながらViewControllerの開発を行える設計にしています。

これについての詳細は4章のViewController編、5章のView/Alert編で説明します。  
#### Alertを一つのモジュールとして切り出す
これはアーキテクチャとして意識しているかどうかは別として多くの開発者が実践していることではないでしょうか？  
個々のアラートを別々にコーディングすると重複してしまう箇所が出てきます。    
そのためアラート機能のコードを抽象化して再利用可能な形式で扱っている開発者は多いと思います。  
私がここで挙げているAlertも基本的にはそれらと同様のものです。    
アラートに関しては第5章View/Alert編で取り上げます。  

#### Routerをカスタム遷移にも対応させている
Routerは遷移処理をViewControllerから切り出したコンポーネントです。  
遷移処理をRouter、もしくはそれに準ずるものに切り出すことは特に珍しいことないと思いますが、このアーキテクチャでは通常遷移だけでなくカスタム遷移も統一的なインターフェースで実行できるような工夫がなされています。   
詳しくは6章の画面遷移編で説明しています。  

#### ViewModel
UI層では他にも7章でViewModel(Controller/Presenter)について触れています。  
サンプルプロジェクトではViewModelを採用しているためViewModelに沿って話しますが、基本的にはControllerやPreseter等、他のViewロジックを扱う機構でも共通する内容になっているはずです。  

### Application層
Application層に関しては少し見慣れない構成になっているものの、基本的にはUseCaseを中心とした設計であることに変わりはありません。  
前回記事の最後で触れた「**いくつものUseCase(データフロー)の蓄積として生成されるアプリケーション状態**」を設計に取り込んだ結果このような構成になっています。    
その特徴は以下の通りです。  
#### CommandUseCaseとQueryUseCase
これらは私の造語ですが、副作用がないQueryと副作用があるCommandの意味さえわかっていればQueryUseCaseとCommandUseCaseを理解するのも難しくないと思います。  
QueryUseCaseは副作用なく自身が結果を出力するのに対して、CommandUseCaseは副作用があり結果を自身が出力せず後述するState・Eventから出力します。  

一点留意したいのが、このApplication層の設計に関しては他の層の設計と趣旨が異なっています。  
他の層では記事のタイトルの通りスケールしやすい設計を目指しているのに対して、Application層はFlux・Redux等の既存アーキテクチャに依存しない形式で状態管理を考えることを通してFlux・Reduxの理解を深めることを目的としています。(もちろんFlux・Reduxの理解を深めることの延長にはスケールしやすい設計という目的があるのですが)  
FluxやReduxは非常に便利なアーキテクチャです。  
ただそれは裏を返せばそれらのアーキテクチャの採用によって開発における問題群をあまり意識せずに解決できるということでもあります。  
実際の開発では手段問わず現前の問題を解決することが何より大切なのでそれで構わないと思いますが、一方で設計者・開発者としてこれから起こりうる様々な状況に柔軟に対応できるようにするためにFlux・Reduxを客観的に理解することも重要だと思います。  
そのため本記事ではFlux・Reduxに依存はしないけれども、機能的には同等の設計を考えていくことでFlux・Reduxが設計において何を意味しているのか考察していきます。    

これについては第9章UseCaseとアプリケーションの状態管理編で取り上げます。  
#### State/Event
これらは先ほどのCommandUseCaseの結果を出力する機構であり、ReduxのStateとは異なります。  
StateとEventと分かれているのは出力する値の質によって区別するためです。  
例えばログインしているかどうか等、常時現在値を取得する必要がある状態はStateで管理し、アプリの開始時、終了時など特定イベント発生時のみ通知するものはEventで管理します。      


#### UseCaseとエラー
順番前後しますが、第8章UseCase編では基本的なUseCaseの設計とエラーの設計について説明します。  
ここでエラーの話をするのはアプリケーションのエラー設計について考えるときUseCaseがその中心的な存在になるためです。  

### Domain層  
始めに述べておくと、本一連の記事でDomain層はあまり深く取り上げる予定はありません。  
その理由としてはDomainが「業務領域」を意味していることからもわかる通りその内容は各アプリケーションが扱うサービスによって大きく異なること、また一般的にモバイルアプリではDomainではデータの操作が主な役割となっていて複雑なロジックを持っていないことが挙げられます。  
しかしそれでもなお設計においてDomainが重要な役割を担っていることには変わりありません。  
なので第9章Domain編ではDomain駆動設計の内容について簡単に説明する予定です。  

#### Repository
RepositoryはDomainオブジェクトの操作処理をカプセル化したコンポーネントでありシンプルなように思いますが、ここでの設計を適切に行わないとアプリケーションプログラムは冗長でわかりづらいものになってしまいます。  
第10章ではRepositoryをシンプルに保つための設計について考えていきます。  

### Infra層
12章はWeb API/データベースの設計について書かれています。    
Web API/データベースはアプリケーションサービスからは独立しているはずなのでアプリケーション開発者がその枠組みから設計していく必要はありませんが、それでも細かいところを工夫をすることでInfra周りのプログラムの使い勝手が大きく変わります。    
12章ではInfraの汎用性を高めるために私が実践しているテクニックを紹介します。  

### その他
各層における内容以外にもテストなど開発において重要だと思うことがあれば追記していく予定です。  

## 補論:アプリケーションにおけるRxSwift
ここではアプリケーションにおけるRxSwiftの扱いについて個人的に思うことを述べています。  
また本サンプルプロジェクトではRxSwiftを利用したためこのようなタイトルとなっていますが、補論内で"RxSwift"と表現している箇所にはCombineフレームワーク等同等のライブラリも当てはまります。  
### RxSwiftは外部技術か？
本サンプルプロジェクトではBusinss LogicにおいてもRxSwiftが利用されています。  
しかしクリーンアーキテクチャのドキュメントにはBusiness Logicにおいて外部技術は利用してはいけないと書かれていますが、RxSwiftはこの外部技術には含まれないのでしょうか。  
  
結論からいうと厳密にいえば例外なくRxSwiftも外部技術に含まれ、Business LogicでRxSwiftを利用するのは望ましくないと思います。  
### RxSwiftはプログラミングスタイル
しかしこれにはいくつかの留意点があり、iOSアプリの設計に関するネット記事でBusiness Logic内でもRxSwiftが利用されているケースがよくみられるのはそれらを踏まえた判断だと思われます。  
その留意点とは具体的に以下3点です。  
1.RxSwiftは技術というよりもプログラミンングスタイルの導入  
2.RxSwiftの導入によって機能実装の際にボトルネックになるようなことはない  
3.現状のSwift言語仕様を考慮するとRxSwiftを導入することのメリットが大きい

それぞれに簡単に説明します。  
#### 1.RxSwiftは技術というよりもプログラミンングスタイルの導入
そもそもBusiness Logicで外部技術を利用しない理由は、Business Logicが特定の開発環境でしか利用できない外部技術に依存してしまうことでプログラムの柔軟性を失ってしまうからです。  
しかし一般的にこの外部技術とは特定機能を提供するライブラリ等を指しますが、RxSwiftが提供しているのは機能ではなくプログラミングスタイルであり、その内部では独自の外部技術は一才使われておらず純粋なSwift言語のみで実装されています。  
またRxSwiftのようなリアクティブプログラミングライブラリはRxJavaやRxKotlinなど他の開発プラットフォームでも提供されていて、実質的に開発環境に依存してしまうことにはなりません。  
このようにRxSwiftは他の外部技術と比べると、開発の柔軟性を著しく落としてしまうような強い制約を発生させません。  

#### 2.RxSwiftの導入によって機能実装の際にボトルネックになるようなことはない  
これは1と重複している部分もありますが、通常外部技術は特定の機能を実現するため特定の開発環境でしか利用できません。    
そのため仕様の変更等によってそれら外部技術がボトルネックとなり仕様要件を満たすことができず実装の変更を迫られる場合があります。  
しかしすでに説明した通りRxSwiftはプログラミングスタイルを提供しており、特定環境に依存しているわけではないので開発の際にRxSwiftがボトルネックとなり機能実装ができなくなるような事態は起こりません。    

#### 3.現状のSwift言語仕様を考慮するとRxSwiftを導入することのメリットが大きい
1と2ではRxSwiftは他の外部技術と比べて開発において強い制約が起こらないことを説明しました。  
さらにそうした消極的な理由に加えてRxSwiftを導入することで統一的な記法によってコーディングできるメリットがあります。  
現状のSwiftの言語仕様だとアプリケーションを通して同期処理と非同期処理でコードの記述方法が異なってしまいがちになるのに対して、RxSwiftを利用すると同期、非同期関係なく統一的な記法でコーディングができるようになります。  
また非同期を含めた複数の処理を連携させたい等、特定の処理の実装において、純粋なSwiftのみだとネスト構造ができてしまったりわかりづらいコードになってしまうところ、RxSwiftを利用することでシンプルなコードで実装できる場合があります。      

### しかし、RxSwiftが負の制約になるのも事実
このようにRxSwiftは他の外部技術と比べると致命的なデメリットがあるわけでもなく、それどころか採用することでアプリケーション全体のコーディングが統一されるメリットがあるため本プロジェクト以外にも多くのプロジェクトにおいてもBusiness Logic箇所で利用されている印象を受けます。  
しかしそれでもやはり負の側面があることも事実です。  
例えば具体的に以下2点のデメリットがあります。  

1. RxSwift独特のプログラミングスタイルを強制されるためコストがかかる  
2. 移行にコストがかかる

#### 1.RxSwift独特のプログラミングスタイルを強制されるためコストがかかる
他の外部技術と比べて制約は少ないとは言いながらもやはりRxの独特なプログラミングスタイルで強制的実装するハメになるためコストがかかります。  
Rxプログラミングでは本来瑣末であるような処理でもオペレーターと呼ばれるデータ処理メソッドを利用しなければならない等通常のSwiftプログラミングよりもコストがかかるケースが発生します。  
Rxのそのような特徴はプログラムを直感的に実装することができず、Businness Logicの本来そのロジックに集中しづらいことがあります。  

#### 2.移行にコストがかかる
RxSwiftがプログラミングスタイルの導入であり特定の開発環境に依存しないと述べましたが、やはり細かな処理に関してはそれぞれの環境に依存してしまっている部分があります。  
そのため例えばRxSwiftからCombineへの移行など同じリアクティブプログラミング内での移行などでもコストがかかるため、変更に弱いです。  

### 近々導入されるasync/awaitによってビジネスロジックにおいてリアクティブプログラミングは不要に？
このように現状RxSwift等リアクティブプログラミングは理想を言えばiOSではビジネスロジック内で利用したくないけれど、Swift言語仕様と一般的に想定される機能要件を考えると採用した方がメリットが多いという状況です。  
しかしこのようなジレンマを抱えた状況はSwift6が登場するまでだと思います。  
というのもSwift6ではasync/await、同期処理のように非同期処理を記述できる機能、が導入される予定なのでこれによりBusiness Logic側でRxSwiftなどリアクティブプログラミングを積極的に利用する理由はなくなるはずです。  
async/awaitの詳細については私もまだ把握できていませんが、今までSwiftプログラミングでは多くのプログラマにとって非同期処理をどうスマートにコーディングするかは大きな課題ではあったはずなので、それが同期処理同様の方法でコーディングできるようになるのは楽しみです。  

 
  
