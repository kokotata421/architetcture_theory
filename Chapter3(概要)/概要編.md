
# iOSアプリでスケールしやすいアーキテクチャを考えてみた③-アーキテクチャ-の概要

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)設計を理解するためのクリーンアーキテクチャ編  
(3)**アーキテクチャ概要編←本記事**  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel(Controller/Presenter)編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編で扱うアーキテクチャの概要を説明します。  
基本的な設計理論を前提としているので、そこから知りたいという方はレイヤードアーキテクチャ編、もしくはクリーンアーキテクチャ編から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

## 前回までの内容と本記事の内容
前回までの記事でレイヤードアーキテクチャ・クリーンアーキテクチャを通して設計の概要をまとめました。    
この記事では前回までで学んだ設計概論をもとに考えたiOSでスケールしやすいアーキテクチャの構成を紹介していきます。  

## アーキテクチャの構成
記事で紹介するアーキテクチャの構成は以下の通りです。  

構成を平面図でわかりやすく伝えるために技術的な依存関係に沿って示していますが、実際にはクリーンアーキテクチャを採用していてBusiness Logic層は他の層に依存しないようになっています。

基本的にはクリーンアーキテクチャやVIPERで紹介されるiOSアプリの構成と大きく違うところはありません。  
概観における特徴はUI層でViewContrllerとViewを明確に区別していること、Routerと同じようにAlertも一つの機構として切り出していること、またApplication層で状態管理を目的としたState/Eventを採用していることくらいでしょうか。(State/Eventについては後ほど説明します)  
しかし一つ一つの層・モジュールについては他のアーキテクチャと比べかなり詳細に立ち入っています。        

## 各層の特徴

### UI層

#### ViewControllerとViewを分離する
冒頭でも述べましたが、UI層ではViewControllerとViewを切り離しています。  
なぜそのようなことをするのか簡単に説明すると、ViewContorllerの主な責務は「入出力(イベント)の処理」と「UIの宣言・操作」です。  
この内「入出力(イベント)の処理」の量はUX的な観点から各画面で変動が起こることは考えづらいのですが、「UIの宣言・操作」に関してはViewの操作は手続的なプログラムになることが多い等、画面の仕様によってコードの量が大きく変わってしまいます。        
ストーリーボードなどを使わずUIの宣言もプログラムで記述している場合、画面間のコード量の違いはさらに大きくなるでしょう。  
そのためViewControllerから「UIの定義・操作」を行うViewを切り離すことで、画面の仕様による影響を最小限に留めながらViewControllerの開発を行える設計にしています。

これについての詳細は4章のViewController編、5章のView/Alert編で説明します。  
#### Alertを一つのモジュールとして切り出す
これはアーキテクチャとして意識しているかどうかは別として多くの開発者が実践していることではないでしょうか？  
個々のアラートを別々にコーディングすると重複してしまう箇所が出てきます。    
そのためアラート機能のコードを抽象化して再利用可能な形式で扱っている開発者は多いと思います。  
私がここで挙げているAlertも基本的にはそれらと同様のものです。    
アラートに関しては第5章View/Alert編で取り上げます。  

#### Routerをカスタム遷移にも対応させている
Routerは遷移処理をViewControllerから切り出したコンポーネントです。  
遷移処理をRouter、もしくはそれに準ずるものに切り出すことは特に珍しいことないと思いますが、このアーキテクチャでは通常遷移だけでなくカスタム遷移も統一的なインターフェースで実行できるような工夫がなされています。   
詳しくは6章の画面遷移編で説明しています。  

#### ViewModel
UI層では他にも7章でViewModel(Controller/Presenter)について触れています。  
サンプルプロジェクトではViewModelを採用しているためViewModelに沿って話しますが、基本的にはControllerやPreseter等、他のViewロジックを扱う機構でも共通する内容になっているはずです。  

### Application層
Application層に関しては少し見慣れない構成になっているものの、基本的にはUseCaseを中心とした設計であることに変わりはありません。  
ただこのアーキテクチャでは前回記事の最後にも書いた通りいくつものUseCaseの蓄積として生成されるアプリケーション状態にも目を向けているのであのよう構成になりました。  
その特徴は以下の通りです。  
#### CommandUseCaseとQueryUseCase
これらは私の造語ですが、結果を返り値として出力せず副作用があるのがCommandUseCaseで結果を直接返り値として返して副作用がないUseCaseがQueryUseCaseなのでコマンドクエリの概念がわかっていれば理解するのは難しくないと思います。  
また最初に留意点としてApplication層に関するこれらの設計は特に良いと思った出来た結果ではなく実験的な意味合いが強いということです。  
ここでいう実験的とは「アプリケーションの状態管理をFlux/Reduxのようにアプリケーション全体に影響を及ぼすような形でなく、あくまでApplication層の一部分の機構として実現させるとしたらどのような形式になるだろうか」ということです。  
そのようなアーキテクチャほどの規模ではないものの、アプリケーション状態を管理する機構を具体化にすることによってFlux・Reduxというアーキテクチャが設計において一体どのような意味を持っているのかを理解するのがここでの目的となります。  
詳しくは9章UseCaseとアプリケーションの状態管理編で述べますが、実際にアプリケーションにおいて状態の管理を行うとしたらFlux/Reduxのアーキテクチャをベースに考えた方が良いでしょう。  

#### StateとEvent
これらは先ほどのCommandUseCaseの結果を出力する機構であり、ReduxのStateとは異なります。  
StateとEventと分かれているのは出力する値の質によって区別するためです。  
例えばログイン状態のような常時現在値を取得するべきようなものをStateで管理し、アプリの開始時、終了時など常に値を管理する必要なく特定イベント発生時のみ通知する機構がEventです。  


#### UseCaseとエラー
順番前後しますが、8章UseCase編では基本的なUseCaseの設計とエラーの設計について説明します。  
ここでエラーの話をするのはアプリケーションのエラー設計について考えるときUseCaseがその中心的な存在になるためです。  

### Domain層
Domain層のための記事も書く予定ですが、正直この層に関してはRepositoryの設計以外この記事で特別取り上げるべきような内容はないと考えています。  
その理由はすごくシンプルでDomainとは「業務領域」を示していることからわかる通り、そのプログラムのベースはそのサービスに大きく依存していますし、またそれらを一般的水準でまとめあげた著書として既にドメイン駆動設計が存在しているからです。(加えて今回のサンプルプロジェクトではDomainに複雑なロジックが存在していないため、参考になる題材がないというのもあります。)  
ただだからと言って設計を考えるという記事でDomainを省略するのもどうかと思うので、今のところは11章Domain編ではドメイン駆動設計の内容を簡単にまとめようと思っています。  

#### Repository
クリーンアーキテクチャ編の記事でも書きましたが、第10章で取り上げるRepositoryはインターフェース上ではDomain層に属しています。  
Repositoryはリモートでのデータ操作処理をカプセル化したコンポーネントでシンプルなように思いがちですが、ここでの設計を適切に行わないとプログラムは冗長でわかりづらくなってしまいます。  
第10章ではRepositoryのシンプルさを保つための設計について考えていきます。  


### Infra層
12章はWeb API/データベースの設計について書く予定です。  
Web API/データベースはインフラですので、他の層と比べアプリケーション開発者がフレームワークから設計していかなくてはいけない領域はあまりありませんがその中でも個人的に気に入って実践していることについて書きたいと思っています。  


### その他
各層における内容以外にもテストなど開発において重要だと思うことがあれば追加で記していく予定です。  




