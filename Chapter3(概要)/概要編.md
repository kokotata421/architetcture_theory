
# iOSアプリでスケールしやすいアーキテクチャを考えてみた③-アーキテクチャ-の概要

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。  
(1)設計を理解するためのレイヤードアーキテクチャ編  
(2)設計を理解するためのクリーンアーキテクチャ編  
(3)**アーキテクチャ概要編←本記事**  
(4)ViewController編(準備中)  
(5)View/Alert/Data Source編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel(Controller/Presenter)編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事ではサンプルプロジェクトで採用しているアーキテクチャの概要を説明します。  
基本的な設計理論の知識を前提としているので、それらをまず知りたいという方はレイヤードアーキテクチャ編、もしくはクリーンアーキテクチャ編から読むことをオススメします。  

## 前提
- この記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

### 記事内の用語の表記ルール 
#### アーキテクチャと設計
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの言葉の定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるもの  
  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっていることが多いと思うのでこの記事では上のように区別することとします。  
#### 各層の表記
記事内でアーキテクチャの各層を示す用語は異なる用法でも利用されます。  
そのためアーキテクチャの層を示す場合はUI/Application/Domain/Infrastrature等英字で表記し、それ以外の用法の場合はカタカナで表記します。    
例:  
Application(層) -> アーキテクチャにおけるアプリケーション層  
アプリケーション -> プロダクト、アプリケーションプログラム等  

またApplicationとDomainを合わせた層をBusiness Logic(層)と表記します。  
InfrastructureはInfraと省略して表記し、Infra層のうちデータ操作に関するものをData(層)、端末機能に関するものをDevice(層)と表現する場合があります。  

#### コンポーネント
本記事ではMVPのModel/View/Presenter、FluxのView/Action/Dispatcher/Store等、アプリケーションのオブジェクトに該当するような構成要素を**コンポーネント**と表記します。  
これは構成要素と表記してしまうとアーキテクチャの各層等、アプリケーション内の次元の異なる他の構成要素と区別がつきづらくなってしまうためです。  


## 前回までの内容と本記事の内容
前回までの記事でレイヤードアーキテクチャ・クリーンアーキテクチャを通して設計の概要を見ていきました。      
この記事では、前回までの設計概論をもとに考えたiOSにおけるスケールしやすい設計の概要を説明していきます。  

## アーキテクチャの構造
記事で紹介するアーキテクチャの構成は以下の通りです。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter3(概要)/Images/アーキテクチャの構造.png" alt="アーキテクチャの構造" width=70% >  
<sup>*アプリケーションの構造を簡潔に示すためDomain、Applicationを含む各層のデータオブジェクトは省略されています。各層のデータオブジェクトについては自身の層で生成され、自身の層もしくはクリーンアーキテクチャのInterface Adapters層で使用されれば問題ありません。</sup>  
<sup>*GatewayはApplciation層、Domain層どちらにも該当するため両方の層の中間に配置しています。</sup>  


構造を平面図でわかりやすく伝えるために技術的な関係に沿って示していますが、実際にはクリーンアーキテクチャを採用していてBusiness Logic(Application/Domain)層は他の層に依存しないようになっています。

基本的にはクリーンアーキテクチャやVIPER等iOSでよく利用されているアーキテクチャと大きく異なる点はありません。  
概観において目に付く特徴はUI層でViewContrllerとViewを明確に区別していること、Routerと同じようにAlertも一つの機構として切り出していること、View Modelが入れ子になっていること、またApplication層で状態管理を目的としたState/Eventを採用している程度でしょうか。(ViewModelの入れ子構造〔Parent ViewModel/Child ViewModel〕、State/Eventについては後ほど説明します)  
ただ、一つ一つの層・モジュールについては他のアーキテクチャと比べてもかなり詳細に立ち入っていると思います。  
ちなみに本設計のデータフローは一部(基本的にDomain)を除いてRxSwiftによって実装されています。  

## 各層の特徴

### UI層

#### ViewControllerとViewを分離する
UI層ではViewControllerとViewを切り離しています。  
本来ViewContorllerの主な責務は「入出力(イベント)の処理」と「UIの宣言・操作」です。  
そして、このうち「入出力(イベント)の処理」は、UXの観点からそのコード量が各画面毎に大きく変わらない責務となっています。[<sup>*1</sup>](#footnote1)  
しかし、それに対して、「UIの宣言・操作」は手続的なプログラミングの実装が多くなる等の理由によって画面の仕様によってコードの量が大きく変わります。          
ストーリーボードなどを使わずUIの宣言もプログラムで記述している場合、画面間のコード量はさらに大きく異なるでしょう。  
そのため本設計では、ViewControllerから「UIの定義・操作」を行うViewを切り離すことで、その責務を「入出力(イベント)の処理」に集中させ、画面の仕様による可読性への影響を最小限に留めています。  

その詳細については4章のViewController編、5章のView/Alert編で詳しく説明していきます。    
#### Alertを一つのモジュールとして切り出す  
個々のアラートは別々にコーディングすると重複してしまう箇所が出てきます。    
そのためアラート機能のコードを抽象化して再利用可能な形式で再構築している開発者は多いと思います。  
私が提唱しているAlert設計も基本的にはそれらと同様のものですが、同時にアプリケーション設計の視点も踏まえた一風変わったとなっているはずです。    
こちらも第5章View/Alert編で詳しく説明します。  

#### Routerをカスタム遷移にも対応させている
Routerは遷移処理をViewControllerから切り出したコンポーネントです。  
遷移処理をRouter、もしくはそれに該当するコンポーネントに切り出すことは特に珍しくないと思いますが、本設計では通常遷移だけでなくカスタム遷移も統一的なインターフェースで実行できる工夫がなされています。   
詳しくは6章の画面遷移編で取り上げます。    

#### ViewModel
サンプルプロジェクトではViewModelを採用していますが、基本的にはControllerやPreseter等、他のViewロジックを扱う機構にも通ずる内容になっているはずです。   
また冒頭の図のViewModelは入れ子構造になっていますが、あの図のParent ViewModelは画面全体を指す親ViewModel、Child ViewModelは各UIコンポーネントを指す子ViewModelを意味しています。        
このように画面全体のViewModelが各UIコンポーネント単位に細分化されたViewModelを内包するという形式を取ることで、それぞれのViewロジックの可読性が上がり、再利用もしやすくなります。  
詳しくは7章のViewModel(Controller/Presenter)編で説明します。  
### Application層
少し見慣れない構成になっているものの、Application層も基本的には従来のUseCaseを中心とした設計であることに変わりはありません。  
前回記事の最後で触れた「**いくつものUseCase(データフロー)の蓄積として生成されるアプリケーション状態**」の管理を設計に取り込んだ結果、このような構成になっています。    
 
#### CommandUseCaseとQueryUseCase
これらは私の造語ですが、副作用がないQueryと副作用があるCommandの意味さえわかっていればQueryUseCaseとCommandUseCaseを理解するのは難しくないと思います。  
QueryUseCaseは副作用なく自身が結果を出力するのに対して、CommandUseCaseは副作用があり結果を自身が出力せず後述するState・Eventから出力します。  

##### Flux/Reduxを理解するための実験
このApplication層の設計は、他の層の設計と比べて非常に実験的な意味合いが強いです。  
他の層ではスケールしやすい設計を目指しているのに対して、Application層は既存アーキテクチャに依存しない状態管理を考えることを通してFlux・Reduxの理解を深めることを目的としています。(もちろんFlux・Reduxの理解を深めることの延長には、スケールしやすい設計を考えるという目的があります。)  
FluxやReduxは非常に便利なアーキテクチャです。  
しかし、それは裏を返せば、それらのアーキテクチャの採用によって、状態管理・データフローを中心とした開発における問題群をあまり意識せずに解決できるということでもあります。  
実際の開発では、手段問わず現前の問題を解決することが何より大切であるのでそれで構わないと思いますが、一方で設計者・開発者として将来起こりうる様々な状況に柔軟性を持って対応できるようFlux・Reduxを相対的に理解することも重要です。  
そのため本設計論では、Flux・Reduxに依存せずに機能的に同等な設計を考えることを通して、Flux・Reduxが設計において何を意味しているのか考察していきます。    

詳しくは第9章UseCaseとアプリケーションの状態管理編で取り上げます。  
#### State/Event
StateとEventは先ほど述べたCommandUseCaseの結果を出力する機構であり、ReduxのStateとは異なります。  
StateとEventと分かれているのは出力する値の質によって区別するためです。  
例えばログインしているかどうか等、常時現在値を取得する必要がある状態はStateで管理し、アプリの開始時、終了時など特定イベント発生時のみ通知するものはEventで管理します。      
State/Eventについても第9章UseCaseとアプリケーションの状態管理編で取り上げます。  

#### UseCaseとエラー
順番前後しますが、第8章UseCase編では基本的なUseCaseとエラーの設計について説明します。    
なぜエラー設計をUseCaseで説明するのかというと、アプリケーション設計で考慮されるべきエラーは全てUseCase(Application層)に集められるからです。  
アプリケーションは大きくいってUIと内部システム(Application/Domain/Infra)に分けられますが、これらをエラー設計の観点から見ていくと、UIで発生するエラーは本設計の対象となりません。    
UIでエラーが発生するとアプリがクラッシュしてしまうので、これらのエラーはassertメソッド等アサーション用の関数を使いながら開発段階で潰すべきのが最善です。    
そのためプログラム実行時において考慮すべきエラーは内部システムで発生したものに限られ、またそこで発生したエラーは、その構造上、必ずUseCaseを通過します。(下記図参照)  
こうした事情を踏まえ、本設計ではアプリケーションで発生するエラーは全てUseCaseに集約させ、扱いやすいようにしています。    

### Domain層  
始めに述べておくと、この一連の記事でDomain層はあまり深く取り上げる予定はありません。  
その理由としてはDomainが「業務領域」を意味していることからもわかる通りその内容は各アプリケーションが扱うサービスによって大きく異なること、また一般的にモバイルアプリではDomainではデータの操作が主な役割となっていて複雑なロジックを持っていないことが挙げられます。  
しかしそれでも設計においてDomainが重要な役割を担っていることには変わりません。  
なので第9章Domain編ではDomain駆動設計の内容について簡単に説明する予定です。  

#### Repository
RepositoryはDomainオブジェクトの操作処理をカプセル化したコンポーネントであり単純なように思いますが、ここでの設計を適切に行わないとアプリケーションプログラムは冗長でわかりづらいものになってしまいます。  
第10章ではRepositoryをシンプルに保つための設計を考えていきます。  

### Infra層  
本記事ではInfra層の設計としてWeb API/データベースについて説明します。  
Web API/データベースはアプリケーションサービスからは独立しているべきであり、アプリケーション開発者がその枠組みから設計していく必要はありません。  
ただ、それでも細かいところをいくつかの工夫をすることでInfra周りの使い勝手が大きく変わり、アプリケーション側のプログラムもシンプルに記述できるようになります。   
12章ではInfraの汎用性を高めるために私が実践しているテクニックを紹介します。  

### その他
各層における内容以外にもテストなど開発において重要だと思うことがあれば追記していく予定です。  

## 補論:アプリケーションにおけるRxSwift
ここでは、アプリケーションにおけるRxSwiftの扱いについて述べていきたいと思います。    
また本サンプルプロジェクトではRxSwiftを利用したためこのようなタイトルとなっていますが、ここでの"RxSwift"という表現はCombineフレームワーク等同等のライブラリに置き換え可能です。    
### RxSwiftは外部技術か？
本サンプルプロジェクトでは、Businss LogicにおいてもRxSwiftが利用されています。  
しかし、クリーンアーキテクチャのドキュメントにはBusiness Logicにおいて外部技術は利用してはいけないと書かれていますが、RxSwiftはこの外部技術には含まれないのでしょうか。  
  
結論からいうと、厳密にいえば例外なくRxSwiftも外部技術に含まれ、Business LogicでRxSwiftを利用するのは望ましくないと思います。  
### それでもRxSwiftがBusiness Logic内で使われる理由
しかしこれにはいくつかの留意点があり、iOSアプリ設計についてのネット記事でもBusiness Logic内でRxSwiftが利用されているケースがよくみられるのもこれらを踏まえた上での判断だと思われます。  
具体的にその留意点とは以下3点です。  
  
1.RxSwiftは技術というよりもプログラミンングスタイルの導入  
2.RxSwiftの導入によって機能実装の際にボトルネックになるようなことはない  
3.現状のSwift言語仕様を考慮するとRxSwiftを導入することのメリットが大きい
  
#### 1.RxSwiftは技術というよりもプログラミンングスタイルの導入
そもそもBusiness Logicで外部技術を利用しない理由は、Business Logicが特定の開発環境でしか利用できない技術に依存してしまうことで、プログラムの柔軟性が失われてしまうからです。    
ただ一般的にこの外部技術とは特定サービス機能を提供するライブラリやフレームワークを指しますが、RxSwiftが提供しているのはプログラミングスタイルであり、その内部では独自の外部技術は一才使われておらず純粋なSwift言語のみで実装されています。  
またRxSwiftのようなリアクティブプログラミングライブラリはRxJavaやRxKotlinなど他の開発プラットフォームでも提供されていて、実質的に開発環境に依存してしまうことにはなりません。  
そのためRxSwiftは他の外部技術と比べると、開発の柔軟性を著しく落としてしまうような強い制約を発生させません。  

#### 2.RxSwiftの導入によって機能実装の際にボトルネックになるようなことはない  
これは1と重複している部分もありますが、通常外部技術は特定の開発環境でしか利用できません。    
そのため仕様の変更によってそれら外部技術がボトルネックとなり要件を満たすことができず、実装の変更を迫られる場合があります。  
しかしすでに説明した通りRxSwiftはプログラミングスタイルを提供しており、特定環境への依存度は低いため開発の際にそれがボトルネックとなるような事態は起こらないと思います。  

#### 3.現状のSwift言語仕様を考慮するとRxSwiftを導入することのメリットが大きい
1と2ではRxSwiftは他の外部技術と比べて開発において強い制約が起こらないことを説明しました。  
さらにそうした消極的な理由に加えてRxSwiftを導入することで統一的な記法によってコーディングできるメリットがあります。  
現状のSwiftの言語仕様だとアプリケーションを通して同期処理と非同期処理でコードの記述方法が異なってしまいがちになるのに対して、RxSwiftを利用すると同期、非同期関係なく統一的な記法でコーディングができるようになります。  
また非同期を含めた複数の処理を連携させたい等、純粋なSwiftのみだとネスト構造ができてしまったりとコードが複雑になってしまう処理があるのですが、RxSwiftを利用することでシンプルに実装できる場合があります。       

### しかし、RxSwiftが負の制約になるのも事実
このようにRxSwiftは他の外部技術と比べ強い制約を生まず、またコード記法の統一性を生まれる等のメリットもあるため実際のプロジェクトにおいてもよく利用されてい印象を受けます。  
しかしそれでもやはり外部技術であることには変わらず、利用することの負の側面があることも事実です。  
具体的に以下2点です。    

1. RxSwift独特のプログラミングスタイルを強制されるためコストがかかる  
2. 移行にコストがかかる

#### 1.RxSwift独特のプログラミングスタイルを強制されるためコストがかかる
RxSwiftは他の外部技術と比べて制約が少ないとは言いながらもやはり独自のプログラミングスタイルを強制させられるのは一つの制約です。      
Rxプログラミングでは本来であれば特に気に留める必要のない処理でもオペレーターと呼ばれるデータ処理メソッドを利用しなければならず等手通常のSwiftプログラミング以上に手間がかかる場合があります。  
Rxのそのような特徴はプログラムを直感的に実装することを難しくさせ、ロジックそのものに集中しにくくなる側面があります。  

#### 2.移行にコストがかかる
RxSwiftはプログラミングスタイルの導入であり特定の開発環境に依存しないと述べましたが、それでも細かな処理に関してはそれぞれの環境に依存してしまっている部分があります。  
そのためRxSwiftからCombineへの移行等、同じリアクティブプログラミング内での変更も移行先の仕様に合わせて変更を行う必要が出てきます。    

### 近々導入されるasync/awaitによってBusiness Logicにおいてリアクティブプログラミングは不要に？
ここまでの内容をまとめるとRxSwift等リアクティブプログラミングは理想を言えばBusiness Logic内で利用したくないけれど、Swiftの言語仕様と一般的に想定される機能要件を考えると採用するメリットの方が大きいというのが現状だと思います。    
しかしこのようなジレンマを抱えた状況はSwift6が登場するまでのようです。  
というのもSwift6ではasync/await(同期処理のように非同期処理を記述できる機能)が導入されるのでこれによりBusiness Logic側でRxSwiftなどリアクティブプログラミングを積極的に利用する理由はなくなるはずです。  
async/awaitの詳細については私もまだ把握できていませんが、今までSwiftプログラミングにおいて非同期処理をどうスマートにコーディングするかは大きな課題だったので、それが同期処理同様の方法でコーディングできるようになり、実装に大きな変化が生まれることは間違いありません。  
 
<a name="footnote1">*1</a>: 「入出力(イベント)の処理」の処理は言い換えればその画面機能の数の多さですが、アプリの1画面の機能が多すぎるとユーザーを困惑させる原因となります。そのためUXの観点から各画面のイベント処理量の違いはおおよそ限度が決まっています。    
