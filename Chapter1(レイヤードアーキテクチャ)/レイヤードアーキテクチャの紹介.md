
# iOSアプリでスケールしやすいアーキテクチャを考える①-設計を理解するためのレイヤードアーキテクチャ-

この一連の論考ではiOSアプリにおけるスケールしやすいアーキテクチャを紹介しています。  
全体の構成(予定)は以下の通りです。   
(1)**設計を理解するためのレイヤードアーキテクチャ←本記事**  
(2)設計を理解するためのクリーンアーキテクチャ  
(3)アーキテクチャ概要    
(4)ViewController(準備中)  
(5)View/Alert/Data Source(準備中)  
(6)画面遷移(準備中)  
(7)ViewModel(Controller/Presenter)(準備中)  
(8)UseCaseとエラー(準備中)  
(9)UseCaseとアプリケーションの状態管理(準備中)  
(10)Repository(準備中)  
(11)Domain(準備中)  
(12)Web API/データベース(準備中)  
(13)その他(準備中)  

本論では本編への(準備の)準備編として設計を理解するためレイヤードアーキテクチャを説明しますので、  
「レイヤードアーキテクチャはもう知ってるよ」という人は次のクリーンアーキテクチャ編🚅、  
「レイヤードアーキテクチャもクリーンアーキテクチャもわかってる」という方はアーキテクチャ概要編から読むことをオススメします。✈️  

## 前提
- 本論はアプリケーション開発における設計を前提としており、ライブラリ等の開発は想定されていません。    

## 用語の定義  
内容に入る前に、その中心にある「設計」と「アプリケーション」という2つの言葉の用法を定義します。    
### 「設計」/「アーキテクチャ」
本論では「設計」と「アーキテクチャ」という2つの言葉が頻出しますが、これらはそれぞれ異なる意味を持ちながらも日常的なコミュニーケーションではあまり差異を意識されずに使用されているように思います。  
なので不必要な混同を避けるため、本論でのそれぞれの定義を以下で明確にしておきます。  
設計・・・アプリケーションプログラムの構造を考える作業、そこで採用されている思想、そしてそのような思想の結果としてプログラムの構造。  
アーキテクチャ・・・形式としてのアプリケーションプログラムの構造。MVC/MVVM/Flux/クリーンアーキテクチャ、またそれらと同列に語られるもの。  
  
定義を明確するとはいっても、アーキテクチャには設計(思想)が含まれているため両者を厳密に区別することは難しいです。  
以上の定義を沿っても「\~アーキテクチャは\~な点を考慮した設計。」といったほとんど両者が同義であるような文が成立します。  
しかし上記の定義を要約すると、原則として本論においては、アプリケーション構造を考える作業やその思想に着目してる場合には**設計**、その構造の形式に着目してる場合には**アーキテクチャ**と記します。    

### 「アプリケーション」/「アプリケーションプログラム」/「アプリケーションサービス」/「アプリケーションプロダクト」
また本論では「アプリケーションプログラム」という言葉が度々登場しますが、これは「アプリケーション」と同義です。  
ただ「アプリケーション」はユーザーからみたサービス/プロダクトを指す場合もあるため、開発者からみたプログラムであることを明示、強調したい際に「アプリケーションプログラム」と表記しています。    
同様に、アプリケーションの「サービス」また「プロダクト」の側面を強調したい場合には、それぞれ「アプリケーションサービス」、「アプリケーションプロダクト」と記しています。    
単なる「アプリケーション」もしくは「アプリ」という表記は、上記に該当せず特定の意図がない、もしくは意図を明確にする必要がない、と思われる場合に用いられています。  

## 目的(本記事で書かれていること)
現在、モバイルアプリの開発ではMVCを始めMVP・Flux・クリーンアーキテクチャ等様々なアーキテクチャが採用されています。  
これらのアーキテクチャは開発においてとても有効で、作業をする上で大きな指針を開発者に示してくれますし、コミュニケーション時の共通言語としても役立ちます。  
ただ、こうしたアーキテクチャはアプリケーション構造の概観を提示してくれてはいますが、その詳細についてまでは言及していません。  
そのためアプリケーションの最終的な品質は個々の設計者・開発者に大きく左右されるようになり、本来問題解決のために利用されているはずのアーキテクチャの中で別の問題を引き起こしてしまう恐れがあります。  
巷でよくいうFatViewController、FatViewModelといった問題です。  
またそれぞれのアーキテクチャはいずれも特定の問題領域に注目して作られているため、そこには少なからず視点の偏りがあります。  
このような状況もあり、私はこれまで個々のアーキテクチャを学んでもアプリケーション設計について理解できている自信が持てませんでした。  
それぞれのアーキテクチャの形式やメリットは理解できても、それらが設計全体において何を意味しているのか俯瞰的に捉えることができなかったからです。        
こうした曖昧な理解は、先ほどのFatViewControllerのように、アーキテクチャの中でまた新しい問題を作ってしまう原因になりえます。  
なので今回、設計を俯瞰的に理解するために様々なアーキテクチャを参考にしながら、そこで得られたエッセンスだと思う要素とiOSアプリの開発環境を照らし合わせ、スケールしやすいアーキテクチャの原型を考えてみました。  
この一連の論考で書かれている内容は、その最終成果物であるアーキテクチャとそこに至るまでに得られた設計に関する知見をまとめたものです。  

## 設計を理解するためのクリーンアーキテクチャ
設計を俯瞰することを最初の目的として論を進めていこうと思いますが、なんの手がかりもなしに理解するのは難しいです。  
なのでまず、クリーンアーキテクチャを通して設計を理解していきたいと思います。  
既存のアーキテクチャの中からクリーンアーキテクチャを選んだのは、クリーンアーキテクチャの以下の特徴が理由です。     
### 1. 具体的なコンポーネント[<sup>*1</sup>](#footnote1)に依存しておらず、設計思想を提唱している  
クリーンアーキテクチャにはMVPのPresenterやFluxのStoreのようにアプリーケーションに必ず含めなければいけないコンポーネントは存在しません。[<sup>*2[/sup>](#footnote2)      
クリーンアーキテクチャは具体的なコンポーネントに頼ることなく、アプリケーションを責務や性質により複数のグループに分割し、それらがどのように連携するのかという考えを提示しています。  

### 2. アプリケーション全体を主要な関心の対象としている  
MVC・MVP・MVVM等のアーキテクチャは一般的にGUIアーキテクチャと言われ、主にアプリケーションのUIとその他を分離することに注力しています。[<sup>*2</sup>](#footnote2)   
それに対してクリーンアーキテクチャはシステムアーキテクチャと言われ、アプリケーションの特定領域にのみ集中することなく、アプリケーション全体を主要な関心対象としています。  

### 3. 1と2の特徴を持ったアーキテクチャを総括した立ち位置にある  
1と2の特徴を持っているのは他にもレイヤードアーキテクチャ・ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等がありますが、クリーンアーキテクチャはこれらを総括した立ち位置にあるアーキテクチャです。

### クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想
これらの特徴が設計において何を意味しているのかということは後ほど説明しますが、以上を要約すると「クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想」だということです。  
これは「設計を俯瞰して理解する」という私たちの目標と合致しています。  
そのため、まず初めにクリーンアーキテクチャを通してアプリケーション設計への理解を深め、私たちの設計に関する共通認識を築いていきたいと思います。  

### クリーンアーキテクチャへの障壁
しかし、クリーンアーキテクチャと言えばこの円図が有名ですが、これが非常にとっつきづらいです。　　
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>
 
<sup>引用元: [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)</sup>  

図が丸いのでどこからどう読んでいけばよいかわかりませんし、そもそもなぜ円なのかもよくわかりません。  
クリーンアーキテクチャを理解するためには、まず内容以前にその背景にあるコンテクストを理解する必要があります。  
なので本記事では、クリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャから学んでいきます。  

## クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ
レイヤードアーキテクチャはアプリケーションを責務によって複数のグループに分割します。  
これは先ほどクリーンアーキテクチャの特徴として紹介しましたが、レイヤードアーキテクチャも同様です。    
そしてレイヤードアーキテクチャは「責務による分割」に加えて、「分割されたグループ間の依存は一方向のみ」というルールも有しています。[<sup>*3</sup>](#footnote3)  
これら2つの特徴を視覚的に表現すると、まるで複数のグループが積み重ねられた層でアプリケーションが構成されているように見えるためレイヤードアーキテクチャ(layered architecture)なわけです、そのままですね。(下記[レイヤードアーキテクチャの概要](#レイヤードアーキテクチャの概要)の図を参照)  
レイヤードアーキテクチャの目的は、この責務による分割と単一方向の依存関係により、それぞれの層毎に開発の関心を分離することです。    
これによって開発者は開発時、常にアプリケーション全体に注意を向ける必要がなくなり、自分が担当している責務の層に集中できるようになります。  
何層に分けるかについてはいくつか考え方があるのですが、私はアプリケーション設計を理解するという目的においては4つの層に分けるのが良いと考えているので本論ではそれを紹介します。  

## レイヤードアーキテクチャの概要
ここからは、もう少し具体的にレイヤードアーキテクチャの概要について説明していきます。  
最初に各層の説明からしていこうと思いますが、その前にレイヤードアーキテクチャの構造を示した図を以下に載せておきます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/layered-architecture-structure.png" alt="レイヤードアーキテクチャの構造" width=60%>  


> 補足:
> 
> レイヤードアーキテクチャの各層を指すUI/Application/Domain/Infrastractureという言葉は本論において他の用法でも使用されます。  
> なので混同を避けるため、以後本論においてはアーキテクチャにおける層を指す場合は英字で、より一般的な文脈で使われる場合はカタカナで表記することとします。  
> 例:  
> Application(層) -> アーキテクチャにおけるアプリケーション層  
> アプリケーション -> アプリケーションプロダクト、アプリケーションプログラム  
> 
> またInfrastructureはInfraと省略して表記します。  

以上の図で示したレイヤードアーキテクチャの構造のうち、UI層とInfra層に関してはこれ以上特に付け加える説明はありません。          
UI層は「ViewもしくはViewに関わるロジックやデータ変換の処理」、Infra層は「デバイス/OS/ネットワーク/データベース等、アプリケーションを支える技術群」を指していることは、多少ITに対して感度を持っている人ならば、たとえプログラミング初学者でも比較的容易にイメージできるはずです。  
ただ、このように直感的に理解し易いUI層とInfra層に対して、Application層とDomain層は馴染みのない人にとって判然としないと思います。        
Applicationはプログラム/プロダクトとしてのアプリケーションと混同しやすく、Domainもソフトウェア開発の文脈において独特の意味を帯びているためその原義である「領域」という意味とは異なり、イメージを掴みにくい概念です。  
そうしたレイヤードアーキテクチャの各層の事情を鑑みて、ここではレイヤードアーキテクチャの層の内、Domain層とApplication層に焦点を絞って説明をします。      

### Domain層とApplication層
#### Domain層
レイヤードアーキテクチャにおけるドメインとはアプリケーションが現実で従事する**業務領域**を指し、Domain層にはその業務に関する情報やルールを表現したデータやメソッドが含まれます。    
例えば銀行アプリのドメインは銀行業務全般であり、Domain層には取引の際のルール、顧客の口座等を表現するオブジェクトが定義・実装されます。  

#### Application層
こちら"アプリケーション"の「Application」層ということで聞き馴染みのない人は混乱すると思います。  
一般的にApplication層は「アプリケーション固有のデータ・ロジック」等と定義されていますが、もう少し平たくすると「ユーザーから見たアプリケーション機能、またビジネスロジックの内ドメインとは関係しないデータ・ロジックを定義・実装する場所」と言えるでしょう。    
ただ、これでも依然として具体性に欠けると思うので、以下でその詳細について説明していきます。      
##### &#12300;ユーザーから見たアプリケーション機能&#12301;としてのApplication層
まず、「ユーザーから見たアプリケーション機能」というのは、銀行アプリで言えば「お金の預入/引き出し/振り込み」等が当たります。  
「ユーザーから見たアプリケーションの機能」と形容が長い理由は、「アプリケーションの機能」だけでは先の「お金の預入/引き出し/振り込み」という各機能を抽象化して「口座のお金の操作」とまとめてしまう恐れがあるからです。  
Application層の主な役割は、そのアプリケーションが提供するサービスを**具体的**に示すことです。  
そのため具体性を保つべくユーザー目線で機能を定義することはとても重要であり、それによって開発者は機能単位で作業がしやすくなります。    

Application層の定義に求められる具体性については[補論](#補論4Application層に求められる具体性)にてもう少し詳しく説明しています。  

##### 「ビジネスロジックの内ドメインとは関係しないデータ・ロジック」としてのApplication層
次に後半の「ビジネスロジックの内ドメインとは関係しないデータ・ロジック」についてですが、これも再び銀行アプリを例に出して説明します。  
ある銀行アプリに「取引履歴をエクセル形式で出力する」という機能があると想定してください。      
その場合、この「取引履歴をエクセル形式で出力する」という機能は、先に述べた「ユーザーから見たアプリケーション機能」に当てはまるためApplication層に定義されますが、その処理の詳細は大きく「取引履歴データの取得」と「取得したデータのエクセルファイル形式への変換」に分けられます。  
そして、ここがこの例の肝で、それら分けられた処理をレイヤードアーキテクチャの層と照らし合わせると、「取引履歴データの取得」は銀行業務に含まれるためDomain層、「取得したデータのエクセルファイル形式への変換」はApplication層に分類されます。  
「取得したデータのエクセルファイル形式への変換」は、それ自体では「ユーザーから見たアプリケーションの機能」として成立していませんが、同時に銀行業務(Domain)にも該当せず、あくまでアプリケーションが独自で行っている処理です。      
そのため、「取得したデータのエクセルファイル形式への変換」は、それだけではアプリ機能として成立していなくとも、アプリ固有の処理としてApplication層に分類されます。  
このようにApplication層には最初に挙げた「ユーザーから見たアプリケーション機能」以外にも、Domainには含まれないもののアプリケーションのために定義、実装したデータ・ロジックが含まれます。  
他にも身近な例でいえば、アプリのログイン情報を表現した独自定義のデータ型等もこのApplication層に属します。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/application-layered-example.png" alt="取引履歴データをエクセル形式で出力する例" width=60%　>  

#### Domain層とApplication層の関係
基本的にはApplication層ではアプリの各機能(ユースケース)毎に定義され、そこからDomain層のデータ・ロジックを利用して処理を実行していきます。  
[先の説明](#Application層)で述べた「取得したデータのエクセルファイル形式への変換」のような機能も一部存在はしますが、通常、Application層はアプリの各機能を表現しており、そこでは具体的な処理は実装されません。  
Application層に具体的な処理が実装されないとは、例えば銀行アプリにおいて現金の引き出しはサービスの1機能としてApplication層に定義されますが、実際に引き出しの際の諸々の計算はDomain層に実装され、Application層側の実装はそれらDomain層の処理の呼び出しとなるということです。       
Application層は、あくまでアプリ機能毎にDomain層の処理を統制する司令塔の役割を担っています。  
Domain層はいわばアプリケーションサービスの原理・原則を定義・実装した非常に抽象的なプログラムの集合であり、そこにはアプリケーションプロダクトのコンテクスト(実際にDomainの原理・原則がどのように使用され、プロダクトサービス機能を提供するのか)が存在していません。  
Application層は、そうしたDomainの処理を機能単位でまとめあげることで、アプリケーションのコンテクストを開発者に提供しているのです。        
これにより開発者は、実際のアプリケーションサービスの仕様に沿って、プログラムの開発を行うことが可能になります。  
以下の図で示した銀行アプリの例を見ると、「取引ロジック」「手数料ロジック」等Domain層の定義をApplication層が機能単位でまとめることで、プログラムの構造が理解しやすくなっているのがわかると思います。  
このようにApplication-Domainは「Application層でアプリケーションサービスとしてのコンテクストを提供し、そこからサービスの内実を示すDomain層のデータ・ロジックを再利用してコードの重複を避ける」という協調関係を築くことで、効率的で開発しやすいプログラムを実現しています。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/application-domain-relation.png" alt="銀行アプリを例にしたApplication層とDomain層の関係" width=70%>  

ここまで読んでわかる通り、Application層とDomain層は概念的に切り離すのが難しくレイヤードアーキテクチャの他の層の組み合わせと比べても密接な関係にあります。  
しかし、それでもレイヤードアーキテクチャの目的である関心の分離はApplication層とDomain層にも当てはまり、Domain層はApplication層からどう利用されているかは意識されるべきではありませんし、Application層にサービス本来の業務に関するデータ・ロジックを含めてはいけません。  

### ビジネスロジックとは
先の[Application層](#Application層)の定義の中で「ビジネスロジック」という言葉が登場しますが、これは「ビジネス」と「ロジック」という日常的によく使う単語を組み合わせたものでなんとなく使われることが多いように思います。  
なので、ここではビジネスロジックの定義について簡単に説明していきます。      
[Wikipedia](https://ja.wikipedia.org/wiki/ビジネスロジック)にはビジネスロジックに関して明確な定義はないとしながらも、「実世界のビジネスオブジェクトをモデル化したもの」を含めた「ビジネスルール(ビジネスに関する方針を表現したもの)」と「ワークフロー(ある関係者から他の関係者へと文書やデータを渡す仕事の順序)」から構成されると説明しています。  
これらの説明でもある程度のビジネスロジックを理解することはできるでしょう。  
ただ、ビジネスロジックをより平易に理解するために、私は「アプリケーションに関する仕様書をデザイン/ビジネス/技術の3つに分類した場合に**ビジネス**仕様書に含まれるもの」であると捉えるのが良いと思っています。  
アプリケーションに関する仕様のうち、ビジネスチームが関わるロジックとそこで利用されるデータ型を指しているため**ビジネスロジック**なわけです。  
そして、これをレイヤードアーキテクチャに当てはめると、ちょうどApplication層とDomain層を合わせたものをビジネスロジックと表現していることになります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/what-businesslogic.png" alt="アプリケーションの仕様書とレイヤードアーキテクチャの関係" width=60%>  

このように、AppplicationとDomainの2つの層を一括りにして表現している「ビジネスロジック」という言葉が多くの開発の現場において頻繁に使われていることからも、これら2層の密接な関係を窺うことができます。  
ちなみにレイヤードアーキテクチャには4層ではなく3層構造で捉える見方もあるのですが、その場合はこのApplicationとDomainがまとまって一つになっています。   
ネットで調べていると3層構造のApplicationとDomainをまとめた層を"Application"、"Domain"等と表現しているケースを見かけますが、そうすると4層構造におけるApplication、Domainと混同してしまうので、私はBusiness Logic(ビジネスロジック)と表すのが良いと思っています。  
私が今回作成したサンプルプロジェクトでもApplication、Domain層をまとめてBusiness Logicと命名しており、以後、本記事でもApplication層、Domain層を一括したい場合にはBusiness Logicと表現することとします。  
### レイヤードアーキテクチャの依存関係

#### 依存は一方向のみ
レイヤードアーキテクチャは層の分割に加えて、それらの依存関係も定義しています。  
本論冒頭の[レイヤードアーキテクチャ概要](#レイヤードアーキテクチャの概要)に記載した図でも示しましたが、それぞれの層を**UI-Application-Domain-Infra**という順番に並べた場合、依存方向は左から右への一方向のみとなります。      

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/layered-architecture-dependency-rule.png" alt="レイヤードアーキテクチャの依存ルール" width=60%>  

#### 反対方向への呼び出しは?
依存方向は一方向のみというルールですが、逆方向へ依存したい時はどうしたら良いのでしょうか。  
ほとんどの場合は、返り値やクロージャのパラメーター(completion handler)を利用することで逆方向への依存関係を作らずに要件を満たしますが、どうしても必要である場合はプロトコルを利用します。  
ただその詳細についてはレイヤードアーキテクチャからは逸れてしまうので、とりあえず本論においては、逆方向へのデータの流れは返り値もしくはcompletion handlerによって実現され、依存は一方向のみであると考えてください。  
プロトコルを利用した依存関係については次章で説明します。  

#### 層を跨いだApplication層からInfra層への依存
一つ注意しておきたいのは、依存は一方向でも、UIからApplicationへ、 ApplicaitonからDomainへ、DomainからInfraへ、というUI->Application->Domain->Infraの依存関係が固定化されているわけではなく、ApplicationからDomainを跨いでInfraへ依存する、つまりApplication->Infraという依存はありえます。     
これは実際のアプリの機能を考えてみればわかると思います。    
例えばアプリのログイン状態はApplication層のデータですが、通常ログイン状態は次回起動時も引き続き使用したいためInfra層の永続化機能で保存する必要があります。  
なので、ログイン状態を操作するApplication層から永続化機能を担当するInfra層へ直接依存することになります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/application-infra-dependency.png" alt="ApplicationからInfraへ依存" width=60%　>  
このように、アプリケーションの機能上Application層のデータをInfra層を通して操作することは少なからずあり、Application->Infraという依存関係は自然と発生します。   
しかし、このような層を跨いだ依存の場合も、その方向が一方のみであることには変わりありません。         

#### Application層からInfra層への依存以外で層を跨いだ依存はない
ここで「Application->Infrastractureという依存関係がありえるのならば論理的にUI->Domain/Infraというケースもありえるのでは？」と疑問に思う方がいるかもしれません。  
しかし、そのような依存関係は実際の開発ではありえません。  
なぜなら、既に述べた通り、Application層は「ユーザーから見たアプリケーションの機能」を定義している場所であり、このApplication層においてユーザーの要求に応えるべく複数のDomain層の処理を連携させているからです。  
そのため、UI層がApplication層を飛び越えてDomain/Infra層にアクセスした場合、Domain/Infra層の処理の連携をUI層が担う必要があり、関心の分離が破られてUI層のコードが肥大化・複雑化してしまいます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/harm-ui-domain_infra-dependency.png" alt="UIからDomain/Infraを利用した場合" width=70%>

UI層から一つのDomainメソッドのみを呼び出したい場合は、ユースケースによってはApplication層への呼び出しが冗長でUI層からDomain層を直接呼び出したくなるかもしれません。      
ただ、そこでApplication層を省略してUI->Domainの依存を許容してしまうと、[先に説明した](#Domain層とApplication層の関係)Application層の「開発者にアプリ機能のコンテクストを提供する」という役割が疎かになり、結果としてコストカット以上に開発コストが増えてしまう複雑な設計となります。  
先のApplication->Infraが設計にとって問題ではなかったのは、それが技術ではなくサービス的な観点によるものであり、技術的な詳細を把握していない開発者にとっても自然に理解できるものであったからです。  
今回のケースのように、特定のサービス機能の処理において一つのDomainメソッドを呼び出すのみであるという技術的理由によってApplication層を省略して依存関係を構築してしまうと、その技術詳細を把握している一部のプロジェクトメンバーを除いて理解しにくい排他的な設計になってしまいます。  
こうした事情を踏まえると、4層の依存関係が変則的になるのは、Application->Infraのみになることが理解できるはずです。    

レイヤードアーキテクチャの基本的な説明は以上です。  
ここからは、クリーンアーキテクチャへ進む前にレイヤードアーキテクチャについていくつか考えることで設計への理解を深めたいと思います。  
## レイヤードアーキテクチャの層の分割は4つが適切か？
本論冒頭の[レイヤードアーキテクチャの導入](#クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ)において、レイヤードアーキテクチャの層は4つで良いと書きましたが、本当にそれで良いんでしょうか。  
ここでは4つの層が適切であるという私なりの根拠を、アプリケーションの層を一つ一つ分割しながら説明していきたいと思います。  

### アプリケーションをBusiness&nbsp;LogicとBusiness&nbsp;Logic以外に分ける
まずアプリケーションを「Business Logic」と「Business Logic以外」に分割します。  
アプリケーション設計には[Presentation Domain Separation(プレゼンテーションとドメインの分離)](https://bliki-ja.github.io/PresentationDomainSeparation/)(以下PDSと表記)という考え方があり、詳細は[補論](#補論2PDSを読み解く)にて説明しますが、これはアプリケーションをBusiness Logicとその他に分けるという設計原則です。  
なぜ最初にBusiness Logicが抜き出されるのかというと、それはBusiness Logicがアプリケーションプログラムの核心であるからです。    
UI、Infraはアプリケーションサービスの実現を支えていますが、そのアプリケーションがどのようなサービスをどのようなルールで提供するかという本質部分の定義は全てBusiness Logicにされています。  
また、その性質の技術的な側面として、Business Logicはプログラミング言語による純粋なデータとロジックによってのみ実装され、外部技術に依存していません。  
そのためアプリケーションの層の分割においては、何よりもまず、Business Logicを分け出すことが効率的なプログラム開発にとって重要になるのです。  
Business Logicを他と切り離すことで、アプリケーションプログラムの核心部分であるビジネスルールの再利用とそのテストが容易になります。  

### Business Logic以外をUIとInfraに分ける
これは説明不要でしょう。    
PDSではUIとInfraはドメインに対する外部機構として一つにまとめられていましたが、一般的にユーザーとの接点であるUIとアプリケーションを裏で支えるInfraを区別することに異論はないと思います。  
ただUIとInfraを区別することに違和感がなくても、WebAPIやデータベースを指す永続化機構とカメラやメール等の端末機能がInfraとして一つにまとまっていることに違和感を感じる人はいるかもしれません。  
確かに、永続化機構と端末機能はアプリケーション上の役割が異なり、場合によってはそれぞれをData/Deviceと区別します。  
しかし、どちらもアプリケーションの機能を技術的に裏で支えているという役割は共通しており、設計上でもBusiness Logicとの関係性はともに「Business Logic->Data/Device」となっていてBusiness Logicから呼び出されるため立ち位置が同じです。  
そのため、設計を捉える上ではこれらは一つにまとまっていた方が理解しやすく、本論でも必要であればData/Deviceと区別しますが、通常はInfraとして括ることにします。  

### ビジネスロジックをApplicationとDomainに分ける
最後にビジネスロジックをApplicationとDomainに分けます。  
この2層は[既に説明した](#Domain層とApplication層)通り、非常に密接に関わっていますが、やはり責務の質が異なっています。    
  
また、設計論においてもApplication層に焦点を当てたFlux/Redux、ドメイン層に注目した開発・設計論であるドメイン駆動開発が提唱された後に普及していて、これらの技術論はApplication層とDomain層がそれぞれ設計において固有の問題を抱えていることを示しています。  
こうした設計を取り巻く状況を踏まえても、アプリケーション設計を理解するためには、Application層とDomain層をそれぞれ独立した層として捉えるのが良いと考えています。    

### この4層によってアプリケーションの提供元である企業から提供先であるユーザーまでしっかり捉えている
さて、アプリケーションの層をその必要性を考えながら一つ一つ分けていったのですが、私がこの4層が最適だと思う理由は、これによりアプリケーションプログラムの端から端までをしっかりと表現できているからです。  
端から端までとは、アプリケーションの提供元となる「企業、もしくは事業」から提供先であるユーザーとの接点になる「UI」までを指しています。  
ドメインとは「業務領域」であると述べましたが、これは言い換えると「企業が提供している事業のビジネスルール」であり、つまりDomain層とは、サービスを提供している主体(企業・事業)が定めたビジネスルールを定義しています。        
そして、そのビジネスルールをアプリケーションサービスとして定義したものがApplication層、それらビジネスルールとアプリケーションサービスを技術的に支えるのがInfra層、アプリケーションサービスとユーザーとの接点として定義されているのがUI層となります。  
このように、「事業/Domain」、「サービス/Application」、「技術的インフラ/(Infra)」、「ユーザー(との接点)/UI」と4層レイヤードアーキテクチャはアプリケーションプログラムの提供元から提供先まで登場する主要な要素を明確に捉えています。   

もし、これよりも層を少なくしてしまうとアプリケーション開発における異なるレイヤーの問題を混同してしまう恐れがありますし、逆にこれ以上層を分けると詳細に立ち入りすぎてその構造を必要以上に複雑にしてしまいます。        

## 設計とは関係を構築すること
4層レイヤードアーキテクチャの概要とそれがアプリケーションプログラムの設計として適している理由を説明してきました。  
ここでは、レイヤードアーキテクチャの以上の内容を踏まえて、設計とはなんであるのか考察したいと思います。   
「設計とはなんなのか」については様々な意見があると思いますが、私は**アプリケーション設計とはアプリケーションにおける開発しやすい関係を構築すること**だと考えています。    
レイヤードアーキテクチャではアプリケーションを責務によって分割し、それらをシンプルな関係によって構築することでプログラム構造をより明確で予測しやすいものにしました。  
 
このように、設計の際アプリケーションプログラムを意味としてまとまりを持った粒度に分解してそれらを再構築するという考え方は、何もレイヤードアーキテクチャに限った話ではありません。  
MVCはアプリケーションをModel-View-Controllerに分けてそれらの関係を定義しているアーキテクチャですし、同様のことはMVP/MVVM/Flux/Redux等他のアーキテクチャにも当てはまります。      
また、よりミクロな設計に目を向けてみても、デザインパターンはアプリケーションにおける特定機能を実現するためのパターン(関係)を提示しており、SOLID原則はそうして構築された関係が開発を行う上で適切であるのか判断する基準だといえます。  

こうして見てみてみると設計に関する種種の概念やテクニックは、全てアプリケーション内の関係を構築するためのものだということがわかります。  
設計とはアプリケーションのマクロからミクロレベルに至る様々な次元において、適切な関係を考えていく作業なのです。  

>補足:  
>設計の定義を「関係の構築」とする場合、レイヤードアーキテクチャの特徴として挙げた「責務による分割」と「依存関係の単一方向」のうち前者が切り捨てられたような印象を受けます。  
>しかし、実際の設計作業を考えてみればわかりますが、アプリケーション内の関係を構築する際には必ずその関係の項を見出すためアプリケーションプログラムを分割して捉える必要があり、「関係の構築」という定義の中には「分割」いう意味も含まれています。  
>ただ、設計においては間違いなく「分割」よりも「関係」の方が重要です。  
>先にレイヤードアーキテクチャが4層であることが適切である理由を述べましたが、効率の良い開発を続けるためにはアプリケーションをただ「分割」するだけでは不十分であり、その状況において適切な関係を構築できるように分割されている必要があります。  
>そのため、ここでは設計を「関係の構築」という定義で集約しています。   

>補足:  
>「関係性が重要である」と言われて、「何をそんな当たり前なことを」と思っている人はいるかもしれません。  
>これはその通りだと思います。  
>私たちは、意味という概念的な次元においても周りとの関係性を考えることなくある対象について考えることはできませんし、また物質的にもダイヤモンドと黒鉛が同じ炭素の配列の違いでしかないようにその定義は究極的には関係によって決定されます。  
>何かを論じる際、そこで関係が重要でないということなんてありえません。  
>しかし、それでもあえて私がここで関係を強調するのは、ネット記事にある設計論のほとんどが「MVC」「Redux」といったパッケージ化された粒度でしか語られていないからです。  
>また、SOLID原則等より粒度の小さい設計原理においても定式化された概念の重要性ばかりが強調され、それらがアプリケーション開発の実践においてどのように適用されるべきかはあまり論じられていないように思います。  
>例えばSOLID原則の一つであるSingle Responsibility(単一責任原則)の「単一」とは一体何を指すのでしょうか。私たちは現実社会における常識から、ある程度は「単一の責任」というものを判断することができると思います。ただプログラミングとは概念的な操作であるため、厳密に何を「単一の責任」とするのかは周囲との関係によって変化します。  
>設計論におけるこうした事情を踏まえ、本論では本来は大前提として省かれている「関係」に焦点を置いてアプリケーション設計を考えることを目的としています。  
  
### アプリケーションの複雑さは関係の複雑さによって決まる
このように設計において関係が重要なのは、それがアプリケーションの複雑さを決定しているからです。[<sup>*4</sup>](#footnote4)  
個々のコンポーネントにおいては、複雑さを決めている主な要因はその大きさです。  
物事の複雑さを決定している基本的な要因はその情報量であり、その意味で個々のコンポーネントがどのような基準で作られたものであったとしてもその大きささえ適切であれば理解するのは難しくないでしょう。      
しかし、コンポーネントの集合体であるアプリケーションの開発では、その複雑さが大きさに帰因する度合いはあまり大きくないと思います。  
以下では、アプリケーションプログラムにおいて大きさではなく関係が複雑さを決定している理由として、4つの連続している要因を挙げています。  
#### 関係がアプリケーションの複雑を決定する4つの要因
##### 1.アプリケーションの一般的な大きさ
一般的なアプリケーションは、個人で開発している等一部のものを除いてどれもそれなりの大きさを持っています。    
単純な情報量で言えばほとんどのアプリケーションが開発者にとって複雑だと感じるだけの大きさを持っているはずであり、それぞれの大きさの違いは相対的にどちらがより情報量が多いか(少ないか)を意味しているにすぎません。  
##### 2.アプリケーションは責務によって分割される
そのため、実際のアプリケーションでは責務に応じてコンポーネント単位に分割します。[<sup>*5</sup>](#footnote5)  
これによりアプリケーションプログラムの情報は整理され、理解しやすくなります。  
例えば、本は情報量(文章量)だけで言えばどれもそれなりの量を持っているはずですが、それらが部・編・章・節・項と特定のまとまりを持って構成されることで情報が整理され、大変読みやすくなります。  
アプリケーションを責務に応じて分割するのも、それと同様です。  
大意で言えば、本の「部・編」といった大きな構成はアプリケーションの「層」、「章」はアプリケーションの「モジュール」、「節・項」といった小さな構成はデザインパターン等コンポーネントレベルの設計に当たると思います。[<sup>*6</sup>](#footnote6)  
  
##### 3.責務の分割の際にはコンポーネント間の関係が重要
責務に応じた分割によりアプリケーションはわかりやすくなりますが、アプリケーションを理解するためには個々のコンポーネントだけでなくそれらの関係も含めて理解する必要があります。    
個々のコンポーネントがどう関わりあっているのか、それを理解して初めてアプリーション全体がどのように動いているのか見えてくるからです。  
従って、アプリケーションのコンポーネントへの分割は相互の関係も踏まえて決定していく必要があります。  
こうした関係を踏まえたコンポーネントの分割には、サービス、技術、デザインに関する専門性を含んだ総合的な知識[<sup>*7</sup>](#footnote7)、そしてそれをチームでブラッシュアップしていく組織力が必要であり、開発者とプロジェクトチームの力の見せ所です。  

##### 4.シンプルな関係を徹底することで大きさの影響を受けづらくなる
関係を踏まえてコンポーネントを構築することにより個々の処理の内容が理解しやすくなりますが、開発を効率的に行うためにはさらにアプリケーション全体の関係が一貫している必要があります。   
全体においてアプリケーションの関係が一貫してるならば、プログラムの変更、機能追加の際にもこの一定のルールのもと開発を行うため、開発者はアプリケーションプログラムの大きさの影響を受けにくくなるからです。  
開発者は常にその一定のルールに沿いながら機能変更/追加をすれば良く、またその影響範囲さえ把握していればプログラム全体の詳細を理解する必要はなく、該当プログラムにのみ集中できるようになります。        
この特性は主要なアーキテクチャを見てみるとわかると思います。  
例えば、ここで主題としているレイヤードアーキテクチャでは、それがどのような大きさであれ各コンポーネントは「UI->Application->Domain->Infra」の関係の中に収斂されるため、開発者は各機能やそのコードの詳細に囚われることなくプログラムの流れを理解することが可能となります。  
また、最近普及しているFluxやReduxのスケールのしやすさも「アプリケーションのデータフローは一方向」という制約によって生まれています。[<sup>*8</sup>](#footnote8)  

>note
> 
>そもそもアプリケーションの大きさはサービスに対する需要や利便性等プログラム以外の観点によって決定されるので、プログラム設計者が解決できるような問題ではありません。  
>その意味でも、各コンポーネント等大きさを配慮すべき箇所はありますが、設計者が設計の際に一番注力すべきは**アプリケーション内の関係をどう構築するか**であると言えます。  

## アプリケーションの複雑さが関係の複雑さによって決まる例
以上で説明したように、アプリケーションプログラムが一定の関係で構築されているのならば、いくらスケールしてもプログラムは一定の型の内に収ます。[<sup>*9</sup>](#footnote9)  
そのため一定の関係が維持されたアプリケーションの元では、開発者が開発コストにおいてプログラムサイズから受ける影響は小さくなります。  
ただ、そのメカニズムを理論的に説明されても、実際に具体例を見ないことにはしっかりイメージができないと思います。  
なので、以下では関係がアプリケーションの複雑さを決定していることを示すいくつかの例を紹介します。  

### Fat ViewController問題
#### MVCのModelにはApplication&frasl;Domain&frasl;Infra層が含まれる
レイヤードアーキテクチャはUI-Application-Domain-Infraという構成であるということを説明しましたが、これらをMVCアーキテクチャの文脈に当てはめるとUIを除くApplication/Domain/Infraは全てModelに分類されます。

>補足:  
>iOSMVCのControllerに当たるのはViewControllerですが、ViewControllerはUIKitに含まれていることからもわかる通り、Viewの操作を行う役割を担いUIの仕様を把握しているのでレイヤードアーキテクチャではUI層に該当します。  

>補足:  
>ここではInfraはMVCのModelに分類されています。  
>厳密にみるとInfraがModelに分類されるという考え方は疑問がありますが、    
>少なくともネットでMVCの概要を調べるとInfraをModelに含めてる記事は散見していますし、  
>何より各コンポーネントをMVC(Model-View-Controller)のどれかに分類するならば消去法でModelしかありません。  
>そのためここではInfraもModelの一部であると仮定して話を進めます。[<sup>*10</sup>](#footnote10)  

そうするとレイヤードアーキテクチャにおいて異なる階層に属していたApplication/Domain/Infra層のコンポーネントは全てModelという一つのカテゴリーの中で並列関係となり、iOSMVCでは以下のような構造が成立するように思えます。  

<img name="simple-mvc" src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/simple-mvc.png" alt="Modelを深く考えず設計した時に起こりうるMVCの構成" width=70%> 

#### FatViewControllerとは
このような構造は一見問題ないようにみえますが、実際の開発では大きな問題を生み出します。  
俗にいうFatViewController問題です。  
FatViewControllerとはViewControllerにビジネロジックが書かれる等、ViewControllerの責務が本来あるべき以上に大きくなってしまっている状態を指していますが、上の図のMVCも構造上そうなることを避けられません。  
その原因の所在は突き詰めていくと、ViewControllerとModel間の関係性の複雑さにあります。(このケースでは関係の複雑さではなく関係の曖昧さといった方が正確かもしれません。)  

ここではなぜ上記の構成だとFatViewControllerに陥ってしまうのか順に説明していきます。    
#### FatViewControllerの問題はViewControllerというクラス名ではない
FatViewControllerというとViewControllerの責務が「View」なのか「Controller」なのか名前からわかりづらい等、クラス名に関する指摘をよく見聞きしますが、[Appleドキュメント](https://developer.apple.com/documentation/uikit/view_controllers)には   
>You use view controllers to manage your UIKit app’s interface.    

とViewControllerの責務はUIをmanage(管理)であると書かれていて、ここからView(UI)をcontrol(管理)するViewControllerというクラス名は決しておかしな名前とは思えません。(ドキュメントでmanageという言葉を使いながらクラス名がView"Controller"なのはiOSプログラミングを既存のMVCに寄せて親しみやすいようにしたかったからでしょうか。)  
「管理」という言葉自体が明確さに欠けているとは言えるかもしれませんが、それが問題になるのは名前そのものに原因があるわけではなくViewControllerと周辺との関係がわかりづらいからです。[<sup>*11</sup>](#footnote11)    

#### ModelとViewの責務が明確ならば、ViewControllerの責務も明確だ
その理由を説明するために、ここでいきなりスイスの話をします。  
スイスはドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの5つの国に囲まれ、4つの言語を公用語としている非常に国際色豊かな国です。  
多くの国際機関がスイスにその本部を置いているのも、世界の文化的中心といえるヨーロッパの中で多くの国に陸続きで囲まれているこうした地理的な状況が関係しているのかもしれません。  
さて、突然ですが、この5つの国に囲まれるスイスの領土を知るためには一体どうしたら良いでしょうか。  
  
  
答えは簡単で、スイスからみてドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土がどこから始まっているか把握すれば良いのです。  
スイスから見て隣国の領土がどこから始まっているのか、それさえわかればスイスの領土も自然とわかるようになります。  
そしてこれは逆に言えばスイスを囲んでいるドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土を知っているならば、スイスの領土も明確になるということです。    
  
MVCにおけるViewControllerの責務だって同じです。  
iOSではViewControllerはModelとViewの間に立つコンポーネントであり、この隣接しているModelとViewの責務が明確であればViewControllerの責務も自然と明確になります。  
そのためViewControllerの責務がそのクラス名から推測可能であるにもかかわらず、依然として曖昧であるのはModelとViewの責務がはっきりとしていないからだと言えます。  
そしてここで一般的に問題となるのはViewController-Modelの境界です。  

#### ViewControllerにとってのModelの役割が曖昧
[先に示した通り](#MVCのModelにはApplicationDomainInfra層が含まれる)MVCではApplication/Domain/Infraと役割の異なるコンポーネントを全てModelとしているため、各Modelコンポーネントの責務、すなわちViewControllerにとってModelがどのような役割を担っているのかが非常に曖昧になっています。    

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/vague-model-responsibility.png" alt="Modelの責務の曖昧化" width=50%> 

そしてこのようにViewController-Model間の責務の境界が不明瞭になった結果、本来Modelの責務であるデータの操作やロジックがViewController側に漏れてしまう現象がFatViewControllerです。    
このときModel側ではなくViewController側に責務が漏れてしまうのは、一般的にModelの責務が何でないのか、つまりModelにはUI操作が含まなれないことは認知されているものの、何であるのかが認知されていないからだと思います。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/fat-viewcontroller.png" alt="FatViewController" width=70%> 
  
もちろんこれはiOSMVCの理想的な形ではありません。[AppleのViewControllerに関するドキュメント](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)にも  

>you should minimize the view controller’s role in managing the actual data.

とあり、ViewControllerのデータの操作は最小限にするべきと記されています。  
  
ただそうだとしても、Application/Domain/InfraをModelとして捉え、それをControllerから利用するというMVCのシンプルな構図だけではFatViewControllerは必ずと言って良いほど起こってしまう問題だと思います。  

MVCは概念としてはシンプルでわかりやすいのですが、実際の開発を考えるとApplication/Domain/InfraをModelという一言で済ましてしまうのは言葉足らずな感じがします。      

>補足:  
>ここで述べたFatViewControllerの問題はレイヤードアーキテクチャの依存関係のところでも書いた[UIがApplication層を跨いでDomain/Infraを利用した場合の問題](#Application層からInfra層への依存以外で層を跨いだ依存はない)と外面的には同じです。  
>ただレイヤードアーキテクチャの場合ではModelの責務をしっかりとApplication/Domain/Infraに区別した上でその依存関係の誤りによって問題を起こしてしまったのに対し、MVCのFatViewControllerではそもそもApplication/Domain/Infraの区別ができていません。  
>そのためFatViewControllerの方が状況としてはより深刻であると思います。    
  
>補足:   
>ここではFatViewControllerを取り上げたので問題の力点がViewController-Modelに置かれていますが、Modelの責務が曖昧になっているということはViewController-Model間だけでなくModel内部でも問題を引き起こしまう危険性があります。      
>Model内の各コンポーネント間で適切な関係性が構築されていない場合には各責務が小さすぎてコードが冗長になる、また逆に責務が大きすぎて作業しづらいFatModelが発生する等の問題が発生するでしょう。  


#### レイヤードアーキテクチャを取り入れたMVC
レイヤードアーキテクチャはクリーンアーキテクチャと同様に設計思想的性質が強いため、他のアーキテクチャと併用することが可能です。  
そのため、ここでは先のMVCにレイヤードアーキテクチャを取り入れることで、Model設計の解像度を高くしてみます。    
MVCにレイヤードアーキテクチャを取り入れた場合の構造は、図にすると以下のような感じです。[<sup>*12</sup>](#footnote12)   

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/layered-mvc.png" alt="レイヤードアーキテクチャを取り入れたMVC" width=70%>  

[先ほどの単純なMVC](#simple-mvc)よりもわかりやすくなったのがわかるのではないでしょうか？  
まずレイヤードアーキテクチャを採用することでModelが整理されてわかりやすくなりました。  
図の中では責務の性質によりコンポーネントの色を分けているのですが、それを踏まえて先程のMVCの図と比べると今回のModel内の構造が以前より理路整然としているのが見て取れると思います。  
そして、ViewControllerから利用するModelはレイヤードアーキテクチャでいうApplication層Modelのみになっているので、ViewController-Model間の関係もより明瞭になりました。              
Application層ModelがViewControllerへ渡すデータはユーザーの要求に直接対応しているはずなので、これによりViewControllerのデータ操作は必要最低限のものになり、複雑なロジックを抱えることはなくなります。   
>補足:    
>ここでいうViewControllerの必要最低限のデータ操作とは、Modelから渡されたログインしているかどうかというBool型を"ログイン中"というString型に変換する等です。  
>Model(Application)はViewの仕様を知っているべきではありません。  
>そのためModel(Application)からのデータがユーザーの要求に直接対応していたとしても、コンピュータにとって都合の良いデータ形式を人間に都合の良いデータ形式に変換する作業はViewControllerで行う必要があります。　　

このようにMVCのModelをレイヤードアーキテクチャによって再考することによって、ViewController-Modelの関係がシンプルでわかりやすくなり、ViewControllerでModelデータ操作により責務が肥大化する恐れがなくなりました。    

#### MVCとMVC+レイヤードアーキテクチャの比較
単純なMVCとレイヤードアーキテクチャを採用したMVCを比較すると、レイヤードアーキテクチャを採用しているMVCの方が責務をより細かく分ける傾向にあるためコードやコンポーネントの量は多くなる可能性が高いです。    
しかしそれでもレイヤードアーキテクチャを採用している方が各コンポーネントの責務やそれらの関係性が明瞭であるため、コーディングやチーム開発での作業がしやすくなると思います。     
そしてこうした責務・関係のわかりやすい設計が開発へ与えるポジティブな効果は、プロジェクトの規模が大きくなればなるほど高くなっていくでしょう。          

### ネスト構造によるコンテクストの複雑化
関係がアプリケーションの複雑さを左右するケースについて、もう少しミクロなレベルの例を一つ紹介します。  
プログラミングをやっていると「ネスト構造を深くすることは避けろ」ということをよく耳にするのではないでしょうか。[<sup>*13</sup>](#footnote13)      
このようにネスト構造が否定的に捉えられている理由は分岐が入り組むことによりコードの流れを追うのが難しくなること、また一つ一つのブロックがコンテクストを提供しているのでそれらが入れ子になった結果、全体のコンテクストが複雑になってしまうことにあると思います。  
そうした複雑なコンテクスト内では、内側のブロックを読む際にその外側のブロックのコンテクストも把握していなければならず、開発者は常に目の前のコード以外にも注意を払う必要があるため、認知負荷がとても高くなってしまいます。  
そしてコンテクストが複雑になるということは、関係が複雑になっているということです。

#### 手数料計算処理をネスト構造を用いて実装する
以下ではネスト構造による複雑さを示すために、ある銀行の取引手数料を計算するロジックを、特に工夫することなくif文のネスト構造を用いて実装したプログラムを記しています。[<sup>*14</sup>](#footnote14)[<sup>*15</sup>](#footnote15)   
```

//サービス提供方法
enum ServiceProvisionStyle { 
  case online
  case inperson
}
//取引タイプ
enum TransactionType {
  case withdraw
  case deposite
  case transfer
}

//手数料の計算ロジック
func calculateTransactionCommission(style: ServiceProvisionStyle, transaction: TransactionType, date: Date) -> Int {
    var fee: Int = 0
    let calendar: Calendar = Calendar(identifier: .gregorian)
    
    guard let hour: Int = calendar.dateComponents([.hour], from: date).hour else {
        //時間は必ず取得されなければならない
        fatalError("must be able to get "hour"")
    }
    
    if style == .inperson { //対面サービスの場合
        fee += 300
        if transaction == .withdraw {
            fee += 100
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        } else if transaction == .deposite {
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        } else { //振り込みの場合
            fee += 200
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        }
    } else { //オンラインの場合
        fee += 100
        if transaction == .withdraw {
            fee += 100
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        } else if transaction == .deposite {
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        } else { //振り込みの場合
            fee += 200
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        }
    }
}

```
    
上記のコードの目的を理解するだけなら、「calculateTransactionCommission」というメソッド名から簡単に銀行の取引手数料の計算であることがわかると思います。      
しかし、挙動の不具合等で実装の詳細を理解しなければいけなくなった場合には、いくつものif文による分岐とそこで行っている処理を頭の中でまとめあげながら読み解いていく必要があり、ロジックとしては複雑ではないにも拘らず読み解くのが難しいプログラムになってしまっています。  

#### 手数料計算処理をネスト構造を避け、関係を整理して実装する
先のネスト構造を用いた取引手数料計算処理の実装を、関係を整理してリファクタリングしてみましょう。  
具体的には手数料計算処理「基本取引手数料(サービス提供形式と取引内容に関する手数料)」「時間外取引手数料」に分け、それぞれをcalculateTransactionCommissionメソッドの内部メソッドとして定義・実装します。  

```
//サービス提供方法
enum ServiceProvisionStyle {
  case online
  case inperson
}
//取引タイプ
enum TransactionType {
  case withdraw
  case deposite
  case transfer
}

//手数料の計算ロジック
func calculateTransactionCommission(style: ServiceProvisionStyle, transaction: TransactionType, date: Date) -> Int {
    //基本取引手数料(サービス提供形式と取引内容に関する手数料)の計算
    func calculateBasicTransactionComission(with transaction: TransactionType, on style: ServiceProvisionStyle) -> Int {
        let transactionTypeCommission: Int
        let serviceStyleComission: Int
        
        switch transaction {
        case .deposite:
            transactionTypeCommission = 0
        case .withdraw:
            transactionTypeCommission = 100
        case .transfer:
            transactionTypeCommission = 200
        }
        
        switch style {
        case .inperson:
            serviceStyleComission = 300
        case .online:
            serviceStyleComission = 0
        }
        return transactionTypeCommission + serviceStyleComission
    }
    //時間外取引手数料の計算
    func calculateOvertimeTransactionComission(date: Date) -> Int {
        let calendar: Calendar = Calendar(identifier: .gregorian)
        
        if calendar.isDateInWeekend(date) { //週末の場合
            let weekendComission: Int = 200
            return weekendComission
        } else {
            guard let hour: Int = calendar.dateComponents([.hour], from: date).hour else {
                //時間は必ず取得されなければならない
                fatalError("must be able to get \"hour\"")
            }
            let basicBuisinessHours: ClosedRange<Int> = 9...17
            let overtimeComissionOnWeekdays: Int = 100
            return basicBuisinessHours.contains(hour) ? 0 : overtimeComissionOnWeekdays
        }
    }
    //基本取引手数料と時間外取引手数料を足して、全体の取引手数料を算出
    return calculateBasicTransactionComission(with: transaction, on: style) + calculateOvertimeTransactionComission(date: date)
}
```
変更によりコードが理解しやすくなったのがわかると思います。  
if文ネストが解消され、迷路のように入り組んだ分岐の中プログラムを追う必要がなくなったことに加え、基本取引手数料の計算を`func calculateBasicTransactionComission(with transaction: TransactionType, on style: ServiceProvisionStyle) -> Int`、時間外取引手数料の計算を`func calculateOvertimeTransactionComission(date: Date) -> Int`として実装したことで個々のロジックの意図が明確になり、読みやすくなりました。    
このような改善は技術的にはDRY(Don't Repeat Yourself)の原則に則ったリファクタリングとされます。    
しかしその本質は、プログラムの意味を検討してそのコンテクスト(関係)を整理したことにあるといえます。  

## アプリケーション内の関係を考えることで適切な設計を見つける
2つの例を交えながら、アプリケーションプログラムにおける関係の重要性を説明しました。  
このようにアプリケーションプログラムは関係に配慮されている必要がありますが、これは他方で、関係が私たちが良い設計を考える上での手がかりになるということを意味しています。      
プログラムの設計について考えるときには、とりうるアプローチは数多くあり、その中には互いに矛盾した方向性を持ったものもあります。  
あるケースでは、コードの重複を減らすために複数のコンポーネントに分けていた責務をまとめて一つにした方が良いかもしれません。  
また別のケースでは、反対に一つのコンポーネントの持つ責務の複雑性を回避するため、そこから特定の責務を取り出して別コンポーネントとした方がわかりやすくなるかもしれません。  
私たちは設計を考えていく上で、こうしたさまざまな解決方法の中から適切なものを選んでいく必要があります。  
そして、そうした選択を迫られた時に大きな助けとなるのが「該当のコンポーネントの背後・周辺にある関係」です。    
本論の最後では、「コンポーネントの背後・周辺にある関係」がいかに設計の指針になるのかを、私の経験を通して説明しようと思います。  

### 関係を考えなかった結果失敗したViewModelの設計
私は、後(第3章以降)に紹介するサンプルプロジェクトを作る際、ViewModelの設計を画面機能ごとにまとめようと考えました。  
画面機能毎にProtocolとその既定実装を書くことで、コードを再利用できるように考えたのです。  
しかしその結果、ViewModelはとんでもなく複雑で、開発しづらいものになってしまいました。    
その理由は今から考えればとても馬鹿馬鹿しいと思うのですが、ViewModelが「ViewのModel」だからです。  
ViewModelの中心にあるのはあくまで「View」であって、「Model(画面機能)」ではありません。  
この例では、ViewModelの設計の根幹に「View」ではなく「Model」を据えてしまったことにより、以下のような問題が発生しました。
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/viewmodel-failure-design.png" alt="ViewModelの設計(失敗例)" width=70%>
 1. **理解しづらい**  
ViewModelの責務を理解するためにはViewModel自身の実装をはじめいくつものプロトコルを参照して、それらを頭の中でまとめあげる必要があったが、複数のプロトコルを跨いでるうちに始めに読んだコードを忘れてしまいがちで、仕様の把握が大変  
 2. **変更しづらい**  
各責務はViewModel自身の実装とViewModelが適応するいくつものプロトコルに散在しているため、コード変更時にその影響範囲がどこまであるのかよくわからない  
 3. **設計がいつ崩壊してもおかしくない**  
各画面機能のコードを再利用するためにはプロトコルの既定実装を利用する必要がある。しかしプロトコルの既定実装では格納プロパティを持てないため、仕様の追加・変更によっていつ設計が崩壊してもおかしくない  

先に述べた通り、上記の問題は全て、ViewをViewModelの中心に据えなかったことに起因しています。        
そのため、以下では「View中心のViewModel」にすることで、なぜ上記の問題が発生しないのか、そのメカニズムを説明していきます。  
#### ViewModelの設計でViewを中心に据える根拠
「機能中心のViewModel」の問題原因を説明していこうと思いますが、まずはその前提として原理的にViewModelの設計の中心がViewであるべき根拠を示します。  
##### 1. **視覚的認識の理解のしやすさ**  
視覚的認識に基づいたViewは直感的に理解でき、それを中心据えることでViewModelは開発者にとって馴染みやすい構造を持ちます。      
##### 2. **一般的にViewModelを開発する順序**  
一般的に、ViewModelプログラムに関心を寄せる順序はView->ViewModelとなっているため、View中心のViewModelの場合、ViewからViewModelへ開発を進めやすくなります。これはレイヤードアーキテクチャにおいてViewModelはApplication層ではなくUI層に属していることと関連しています。  
##### 3. **Viewの設計との一貫性**  
ViewModelがViewと一貫した構造を持っていると格段にプログラムが理解しやすくなります。それに対して、機能が中心にあるViewModelの場合はViewとViewModelの構造に差異が発生するため、開発者はその差異を頭の中で整合させながら開発を行う必要があります。  

この3に関しては視覚的に示した方がわかりやすいと思うので、以下で「『View』単位で責務を分割したViewModel」の設計と先の「『機能』を中心としたViewModel」の設計、そしてそれぞれとViewの構造の関係を比較した図を載せておきます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/viewmodel-design-comparation.png" alt="ViewModelをView中心で設計した場合と機能を中心で設計した場合の比較" width=70%>

#### Viewを中心に据えることで「機能中心のViewModelが抱える問題」を発生させないメカニズム
さて、それでは先で示した「ViewModelの設計でViewを中心に据える」根拠と「View単位で責務を分割したViewModel設計」の図に基づいて、「View中心のViewModel」だとなぜ「機能中心のViewModel」の問題が発生しないのか、各点に沿って説明していきます。

1. 「**理解しづらい**」問題を防ぐ  
ViewModelの責務が視覚的に認識できるViewコンポーネント単位に分割されていると、開発者は分割された各責務を直感的に理解することができる。そのため、それらの責務の間で関心の分離が適切になされているのならば、開発者は分割されたプログラムを「頭の中でまとめあげる」という煩わしい作業をする必要はない。  
2. 「**変更しづらい**」問題を防ぐ  
1と同様、分割された責務間で関心の分離が適切になされているのならば、コード変更時の影響範囲に関してあれこれ考える必要はない。コード変更で影響が出る範囲は各Viewコンポーネントに対応したViewModelに限定される。  
3. 「**設計がいつ崩壊してもおかしくない**」問題を防ぐ  
「機能中心のViewModel」にはコードの重複を避ける目的があったが、通常ViewModelは複数のView機能を持ち、多重継承を行えないSwiftにおいては、コードを再利用するためにはプロトコルの既定実装に頼るしかなかった。それに対して、「View単位で分割されたViewModelの設計」では、画面全体を表す親ViewModelと各Viewコンポーネントを表す子ViewModelの親子関係構造となっているため、コードを再利用したい場合には子ViewModelの "具象型"を再利用すれば良く、Protocolの既定実装に依存する必要がない。  

> 補足:  
> 「3. 『**設計がいつ崩壊してもおかしくない**』」で「View中心のViewModel」では親子関係であるため再利用可能であるならば、「機能中心のViewModel」でも親子関係の構造にすれば良いのでは
ないかと一見考えられますが、現実的にそれは不可能です。  
> その理由は、「ViewModelの機能」を表したプロトコルは、それ自体単独では具象型にはなれないからです。    
> 機能に関するViewModelプロトコルにおいて、「~の機能を持ったViewModel」プロトコルという形容詞的な使用方法は、実務運用面ではここで再三説明しているように問題があるものの、論理的にはおかしくありません。  
> しかし、機能ViewModelプロトコルを単独で具象型として実装した「~の機能のViewModel」クラスという名詞的な使用は、論理的にほとんど語義矛盾といえます。  
> 例えば、「ログイン機能を含んだViewModel」を意味するプロトコルが単独で具象型となり、「ログイン機能のViewModel」クラスを実装したならば、それはもはや「ログインボタンViewModel」を無理矢理に機能側に寄せて表現しているだけです。  
> このように画面機能を表したプロトコルは、ViewModelクラスの一部として準拠されはするものの、それだけで独立して具象型になることはできず、親子関係を持てません。  

#### 人の認識と設計の乖離による複雑化
「機能中心のViewModel」の問題原因を項目に沿って説明しましたが、これらを要約すると、「人が認識する構造と同じ構造で設計をすべきである」という原則が見えてきます。  
今回の例で言えば、一般的に視覚的で認識するViewのModelである"ViewModel"において、強引に機能を中心とした設計を採用したために、理解・変更しづらく、また既定実装に依存しなければならない歪な構造を持ったプログラムようになってしまいました。  
現状のプログラミングにおいて、実際にコードを読み書きして開発するのは人間です。    
そのため設計の際には、技術的に複雑に考えすぎず、コンポーネントに対する素直な認識に基づいて開発者が作業しやすいように設計をしていくのが重要になります。    
もちろん、Domainの設計等、アプリの外面から認識できないプログラムに関しては専門的な知識、アプリの仕様を用いて認識、設計していくため、そもそも「認識と設計が乖離しているか」という判断が難しい場合もあります。  
しかしViewを含めたUI層、サービスを定義したApplication層はアプリユーザーからも認識できるプログラムの設計においては、素直にその視点に基づき設計した方が多くの開発者にとってわかりやすい設計となるでしょう。  
その意味で本例は、アプリケーションにおけるViewModelの立ち位置を考えず、コードの重複を減らすこと(DRY)だけに目がいってしまったがための失敗だといえます。  

### プログラミングという自由な空間だからこその、道標としての「関係」の重要性
プログラミングは、その言語を使って概念から定義していくことができる創作活動であり、それがためにとても自由な空間を持っています。  
この自由さは、プログラミングの一番の面白さでありながら、問題でもあります。  
私たちは、プログラミングの持つこの自由によって、機械のように規則に従ってコードを書くのでなく、自らの創造性を活かしながら作業に臨むことができます。  
ただ、同時に、そのあまりの自由さによって、プログラミングにおいては何が実現(運用)可能で何が机上の空論なのかという判断が非常に難しいのです。  

このよう、設計の際に無数にあるように思われるアプローチの中から開発にとってより適切なものを選び出すため、コンポーネントのアプリケーションにおける立ち位置や関連するコンポーネントとの関係を考えることがとても重要になります。  
特に個人ではなく、チームで開発している時にはその重要性はより顕著となるでしょう。  

## この一連の記事で書かれていることも全て関係についてである
本論を通して紹介してきたように、設計論の背後には必ずし関係論がその要として存在しています。  
そして、アプリケーション設計という広大な領域を持つ分野では、このように一貫した基礎的概念を念頭に置くことはとても重要であるように思います。  
設計論ではマクロからミクロに至るまでさまざまな技術やパターン、概念を提示していますが、それら全てを別個に理解していてはそのあまりの情報量が多さに目が眩んでしまいます。  
しかしそのような時、それらの全ての背後にある関係が要であることを理解していればその詳細に圧倒されることなく、設計を理解する助けになるはずです。  
この一連の記事でも、この後アプリケーションにおけるさまざま責務についてスケールしやすい設計を考えていきますが、それらは全てアプリケーション開発にとって最適な関係を見つけていく作業であると言えるでしょう。   
次編ではクリーンアーキテクチャの仕組みを知ることを通して、設計における関係に関してさらに考えを深めていきます。  

>補足:  
>コンポーネントが先にあってそれから関係を構築するのか、関係を構築するためにコンポーネントを作るのかというのはケースバイケースです。  
>しかし、これまでのプログラミングの歴史におけるアーキテクチャの探究の中でアプリケーション設計基礎にとって大事なコンポーネントはほとんど出揃っていると考えています。  
>また既存で普及しているコンポーネントから考えた方が、読者の方も理解しやすいでしょう。  
>そのため、この記事では基本的に既存のコンポーネントを利用しながら、それらの関係を考えていくというスタイルで話を進めます。  

## 準備の準備編(本記事)のまとめ
- クリーンアーキテクチャは、アプリケーション全体を考慮して提案された設計思想である  
- レイヤードアーキテクチャはクリーンアーキテクチャの原型であり、その主な目的はアプリケーションをUI/Application/Domain/Infraという責務毎に分割し、またそれらの依存関係を一定に定めることにより、開発においてそれぞれの責務の関心を分離することである
- 設計とは、アプリケーションにおいて開発しやすい関係を構築することである


## 補論1&#58;アプリケーション設計における関係とは
本論では、設計においては関係を考えることが重要であると説明してきました。    
ここではもう少し具体的に、アプリケーション設計における関係とはなんであるかを考えていきたいと思います。  
### 設計(関係)の2つの在り方
アプリケーションプログラム開発における関係とは、言い換えれば、開発者とプログラムの関係です。    
その関係は大きくいって「外部設計」と「内部設計」の2つに分けられると思います。  
#### 1.外部設計
一つ目はプログラムを外部から使用する場合です。  
外部からの使用において、開発者はそのプログラム内部には強い関心がありません。  
自分でそのプログラムを読み書きする必要がないからです。  
ただ、その代わり開発者にとって重要であるのがプログラムのインターフェースになります。            
外部からプログラムを使用する場合、そのインターフェースを通して接します。  
そのため、適切なインターフェースはそのプログラムの使用を容易にさせます。  

#### 2.内部設計
もう一つはそのプログラム自身を開発していく場合です。  
この場合、開発者はプログラムの中の構造を考えながら開発を行なっていく必要があります。  

#### 外部設計と内部設計への配慮は混ざり合う
上記で挙げた2つの関係は純粋な概念として切り分けたものであって、実際の開発では両者は混ざり合っています。  
例えば、プログラムを外部から使用する場合にも、堅牢性やパフォーマンス等の要件のために内部設計に対して注意を向ける必要があります。    
インターフェースが優れていても機能的要件が満たされいなければ、異なる外部プログラムを選択、もしくは自作しなければなりません。    
また内部設計を行う場合も、まずはそのプログラムのユースケースを想定してインターフェースを構想した上で、内部の構造を考えるべきです。    
このように、「外部設計」と「内部設計」は地続きであり、それぞれが独立しているわけでありません。    
しかしそれでも設計の際には、「外部設計」と「内部設計」という2つの観点とその差異をしっかり意識しておくべきでしょう。  

### 「外部設計」と「内部設計」における関係
次に「外部設計」と「内部設計」、それぞれの設計において関心を向けるべき関係について説明していきます。  
### &#12300;外部設計&#12301;における関係
「外部設計」における関係で考えるべき点には「インターフェースの命名」、「インターフェースの粒度」があると思います。  
#### インターフェースの命名
一つ目はインターフェースの命名です。  
インターフェース(主にプログラムのメソッド名)の名前が適切に命名されていないと、プログラムが他の点でどんなに素晴らしいものであっても使い勝手が悪いものになってしまいます。    
インターフェースは、それを使用する開発者が迷わずに理解できるように命名すべきです。  
例えば、銀行アプリで「calculateComission(手数料計算)」という名前のメソッドがあったとして、そのアプリが多くのサービスを提供しているならば、「calculateComission」の「手数料」が何を意味しているのか明確ではありません。  
この場合、プログラム使用者に意図を具体的に伝えるためには、「calculateTransactionComission(取引手数料計算)」などと命名した方がわかりやすいでしょう。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/external_design_interface_name.png" alt="アプリケーションにおける関係性" width=70%>  

#### インターフェースの粒度
また外部からプログラムを使用する場合、インターフェースの粒度も重要になります。  
このインターフェースの粒度は、言い換えれば、そのプログラムで想定されるユースケースに対して適切に設計できているかです。  
例えば、銀行サービスで振り込みを行いたい場合には「振込手数料を計算する」「自分の口座から振込額と手数料を引く」「該当の口座の預金に振込額を追加する」という処理を行なっていく必要がありますが、もしこれらの処理をプログラムを使用する側で一つ一つ呼び出さなければいけないならば、呼び出し側のコードは煩雑になってしまいます。    
この場合、ユースケースと合致させ、一連の処理を取りまとめた「振り込みをする」というメソッドがインターフェースとして提供されるべきです。    
もちろん、プログラムのユースケースは様々であり、誰にとっても最適なインターフェースを提供するのは不可能です。  
ただ、それでもプログラムの一般的な性質から想定して、多くの使用者にとって適切であろうインターフェースを提供するのは重要となります。    

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/external_design_interface_size.png" alt="アプリケーションにおける関係性" width=70%>  

### 「内部設計」における関係  
「内部設計」の関係において考えるべき点は大きく「コンポーネント内部」、「コンポーネント間」、「アプリ全体とコンポーネント、また開発者とコンポーネントの間」です。      
この内「コンポーネント内部」、「コンポーネント間」はケースに応じて内容が変わるため、その詳細な説明は省略します。  
以下では、それぞれの概要を紹介した後、「アプリ全体とコンポーネント、また開発者とコンポーネントの間」について補足します。    

### 「内部設計」において考えるべき点
1. **コンポーネント内部**・・・コンポーネント内部の変数・メソッド間の関係。さらに処理内部の中のローカルと計算の連携。    
2. **コンポーネント間**・・・コンポーネント同士の繋がり。  
3. **プログラムにおけるコンポーネントの立ち位置**・・・アプリケーション、開発者に対してのコンポーネントの役割。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/relations_in_internal_design.png" alt="アプリケーションにおける関係性" width=70%>  

#### プログラムにおけるコンポーネントの立ち位置
プログラムと外部との関わりについては「外部設計」で主に触れましたが、「内部設計」においてもプログラムの外からどうみられているかということは重要な場合があります。    
その最たる例はViewControllerです。  
iOSアプリをUIKitで開発している場合、そのアプリプログラムを理解するためにまずViewControllerを読んでみる人が多いのではないでしょうか。  
ViewControllerは実物のアプリ画面に対応しており、アプリの画面を触ってプロダクトを調べるように、開発者にとってはViewControllerはプログラムを読み書きする入り口であり開発の基点となります。    
このViewControllerの役割を考えれば、ViewControllerには詳細ではなく概要が把握できるような実装がなされているべきです。    
「どのような機能を提供している画面か」を知りたくプログラムを読んでいるのに、技術的な詳細が事細かに書かれていては画面の全容が把握しづらく、開発の心理的負担が大きくなってしまいます。    
それぞれのコンポーネントの実装は、プログラム上においてだけでなく、開発者に対しても特定の役割を担っている場合があります。    
そのため、内部設計を考える際には、アプリケーション内のコンポーネントの立ち位置も考慮する必要があります。    

### 関係によりアプリケーションが複雑化する原因
次に関係によってどのようにアプリケーションが複雑になるか考えていきます。    
私は関係によってアプリケーションが複雑になるとは具体的に以下2つの現象を指していると思います。  
1. データフローの複雑化
2. コンテクストの複雑化

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/complicated_programme_by_relations.png" alt="関係性によるアプリケーションの複雑化" width=70%>  

#### 「データフローの複雑化」と「コンテクストの複雑化」の関係
「データフローの複雑化」とは文字通りデータの流れの複雑化、対して「コンテクストの複雑化」はプログラムの関係が入り組みその意味の解釈が難しくなってしまう現象を指しています。  
また「データフローの複雑化」と「コンテクストの複雑化」は、互いに排他的ではなく関係が複雑になることにより同時に起こる現象です。  

> 補足:  
> コンテクストの複雑化は記事内では[ネスト構造](#ネスト構造によるコンテクストの複雑化)と関連させて紹介しましたがネスト構造に限った話ではなく、コンポーネント内、またコンポーネント間など関係が発生するあらゆるところで発生します。  
> 図の2でも、都合上省略しましたが繋がりを示すコンテクストはコンテクストEだけではなく、コンテクストA->コンテクストB等他の箇所でも発生しています。  

#### 「外部設計」/「内部設計」と「データフローの複雑化」/「コンテクストの複雑化」の関係
「外部設計」/「内部設計」と「データフローの複雑化」/「コンテクストの複雑化」の関係は、「外部設計」は「データフローの複雑化」へ、「内部設計」は「コンテクストの複雑化」へつながるというような単純な構図ではなく、「外部設計」/「内部設計」の各関係項目によりけりです。    
例えば外部設計であるインターフェースの命名が雑であるとデータフローは変わりませんが、プログラムの意味の解釈が難しくなります。  
それに対してインターフェースの粒度が雑に設計されていると、データフローが複雑になると同時にコンテクストも読み取りづらくなってしまいます。  
同様に内部設計における各関係項目でもそれぞれ「データフローの複雑化」、「コンテクストの複雑化」、もしくは両方に影響するのか異なります。  

#### 「データフロー」と「コンテクスト」から設計を考える
簡単にアプリケーション設計における関係を説明してみました。  
本来プログラミングにおける「関係」は、これだけで記事が書けるくらい大きなテーマであり、ここで論じられている内容はほんの一部に過ぎません。  
ただそれでも、プログラミングにおいては「データフロー」と「コンテクスト」の2つの観点から開発のしやすさを考え、そこから「外部設計」「内部設計」の各項目を構築していく必要があることはわかったと思います。  

## 補論2&#58;PDSを読み解く

[本論](#アプリケーションをBusinessLogicとBusinessLogic以外に分ける)では、PDS(Presentation Domain Separation)が「アプリケーションをBusiness LogicとBusiness Logic以外に分ける」設計原則であると述べました。  
ここではPDSの特徴を説明しながら、なぜPDSが「Business LogicとBusiness Logic以外に分ける」ことを意味すると解釈できるのかを示していきます。    
### プレゼンテーションとはUIを含めたドメインと連携する全ての機構を含む 
[PDSのドキュメント(和訳)](https://bliki-ja.github.io/PresentationDomainSeparation/)には最後に補足のような形で以下の文が書かれています。  

> 人間ではなく、コンピュータ相手の Web Services だって、プレゼンテーション部分です。  
> ですから、ドメイン部分のコードと Web Services 部分のコードをごちゃまぜにしてはいけないのです。  
> 外部APIにしてもそうです。  

ここからプレゼンテーションにはWeb APIを中心としたInfraも含まれていることがわかります。  
PDSのプレゼンテーションはUIのみを指しているわけではなく、ドメインと連携する外部機構に関する全てのプログラムを指しているのです。    
   
### ドメイン=Business Logic
PDSの[ドキュメント](https://bliki-ja.github.io/PresentationDomainSeparation/)では、「プログラムのプレゼンテーション層（ユーザーインターフェイス）[<sup>*16</sup>](#footnote16)とその他の機能をうまく分ける」メリットとして以下の点を挙げています。  
> ユーザーインターフェイスはテストがしにくいため、それを分離することにより、テストしやすいロジック部分[<sup>*17</sup>](#footnote17)に集中できる  
  
ここで挙げられている「テストしやすいロジック部分」とは、それが「プレゼンテーション層（ユーザーインターフェイス）」と対比的に表現されていることからも分かるとおりドメインを指していますが、これは技術的には「外部技術に依存していないプログラム」を意味しています。  
ドメインは、外部技術に依存しておらず純粋なプログラミング言語のロジックとデータによって成り立っているからこそ「テストしやすい」プログラムなのです。  
そして、本論から再三の説明している通りPDSはプログラムを「プレゼンテーション」と「ドメイン」に分ける二分法の設計原則です。  
このPDSの二分法、そして先ほど述べたPDSの、外部技術に依存している「プレゼンテーション」と外部技術に依存していない「ドメイン」というそれぞれの性質を踏まえると、PDSのドメインにはレイヤードアーキテクチャのDomain層だけでなく、Applicatioon層も含まれていると判断できます。   
つまりPDSのドメインは、Business Logic(Domain/Application)を指しています。    

### PDSの中心はドメイン
先ほども述べましたが、PDSドキュメントの冒頭では
> プログラム)のプレゼンテーション層（ユーザーインターフェイス)[<sup>*16</sup>](#footnote16)とその他の機能をうまく分ける  
  
とPDSの特徴を説明をしており、あたかもプレゼンテーションがPDSの中心であるかのような記述になっています。  
しかし[先のプレゼンテーションの定義](#プレゼンテーションとはUIを含めたドメインと連携する全ての機構を含む)で明らかにしたように、PDSにおけるプレゼンテーションは"ドメイン"の外部であることしか意味していません。  
またドキュメント内ではPDSのメリットとして
> 同じ基本プログラムを、重複コードなしに、複数のプレゼンテーションに対応させることができる  
  
点を挙げており、この「基本プログラム」は「複数のプレゼンテーションに対応させる」とプレゼンテーションと対比されていることからもわかるとおりドメインを指していますが、ここでドメインを"基本"プログラムと表現していることからPDSの中心はプレゼンテーションではなくドメインであると読み取れます。  
そしてそれは、「同じ基本プログラムを、重複コードなしに、複数のプレゼンテーションに対応させることができる」という上記の性質からPDSの構造を視覚化してみるとより明らかになります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/pds_structure.png" alt="PDSの構造" width=70%>

### PDSはプログラムをBusiness LogicとBusiness Logic以外に分ける
ドキュメントを読み解きながら、PDSの特徴を説明してきました。    
PDSのプレゼンテーションはドメインの外部でしかなく、PDSの中心はドメインにあり、またそのドメインはレイヤードアーキテクチャと照らし合わせればBusiness Logic(Domain層/Application層)を指しています。  
以上の特徴をまとめると、補論冒頭で述べたPDS(Presentation Domain Separation)が「アプリケーションをBusiness LogicとBusiness Logic以外に分ける」設計原則であるという意味が理解できると思います。  

## 補論3&#58;Modelとはなにか
本論の[MVCアーキテクチャ](#MVCのModelにはApplicationDomainInfra層が含まれる)に関する説明において、MVCのModelにはInfraも含まれると仮定しながらも、厳密にはModelにInfraを含めるのは違和感があると記しました。  
ここではその問題を踏まえながらModelについて考えたいと思います。  
### MVCにおけるModel
最初にMVCの提案者である[Trygve Reenskaug氏のModelの定義](https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf)を見ていきます。    

>Models represent knowledge.   
>(中略)  
>There should be a one-to-one correspondence between the model and its parts on the one hand, and the represented world as perceived by the owner of the model on the other hand.   
>The nodes of a model should therefore represent an identifiable part of the problem.  
>  
>意訳:  
>モデルは知識を表している。  
>(中略)  
>モデルとそのパーツはその設計者のメンタルモデルと対応していなければならず、そのためモデルの各要素はその問題の特定箇所を示している。    


Modelとは何かを考える上では、以上の定義にある
>the represented world as perceived by the owner  

をどう解釈するのかが鍵となりますが、私は「メンタルモデル」と解釈するのが良いと考えています。  
「モデル」の話に「メンタルモデル」と似た用語が出てきてわかりづらいのですが、メンタルモデルは「ある対象に対しての人が抱くイメージ」を指しています。  

Trygve Reenskaug氏の論考を[日本語訳している記事](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448)を読んでみると、該当箇所の訳は
>その所有者によって知覚された世界の表象  

と少し難解になっていますが、これを平易にすると「知性[<sup>*18</sup>](#footnote18)による認識によって現れてたイメージ」、さらにそれを簡潔に表すと「メンタルモデル」になると考えられます。    


### 改めて、Modelとは
さて話をModelの定義に戻すと、上の定義に沿ってModelを「メンタルモデルがプログラム化されたもの」と捉えた場合、そこにInfraは含まれないと思います。  
Infraは文字通り「基盤/下部構造」という意味であり、私たちの普段の活動の中でインフラに対して何かイメージを抱くほど強く意識することは滅多にありません。(インフラ開発・運用を生業としている場合は例外です。)     
もちろんハンドルを捻れば水道蛇口から水が出てくる等、私たちがインフラを利用できるのはそれらに対するイメージをしっかり持っているからだと言えるわけですが、こうしたインフラに対する理解はあまりにも当たり前のものとして私たちの意識の中に内在しており、実際の日常活動においてはほとんど意識されていません。         
例えば料理の写真を見て実際に自分で作ってみようとした時に、食材やその調理方法についていろいろとイメージしながら作りますが、その際水道やガスシステムに対してまであれこれ思いを巡らす人はいないと思います。  
ここでいう料理の材料、調理方法はプログラム開発におけるビジネスロジック、水道やガスシステムはInfraと言えるでしょう。[<sup>*19</sup>](#footnote19)  
このように、インフラは日常の活動を下支えする存在であり、それはアプリケーションにおいても同様です。    
アプリケーションは現実の活動における何らかの問題に対して解決策を提供するサービスあり、その解決のために使われるモノ(データ)や振る舞いはメンタルモデルの対象となりますが、それらの技術的基盤にあたるInfraについてはメンタルモデルの対象外であると思います。  
また先ほどのMVCのModelの定義は[GUIアーキテクチャ](https://martinfowler.com/eaaDev/uiArchs.html)におけるドメインオブジェクトの定義と同様であると考えられ、 
>domain objects that model our perception of the real world  
>
>意訳:  
>現実世界に対する認識を型どったドメインオブジェクト  

これらの定義からも、Model=ドメイン、つまりModelはレイヤードアーキテクチャにおけるBusiness Logic(Domain層/Application層)に該当すると考えられます。[<sup>*20</sup>](#footnote20)    

### InfraがModelとして扱われがちな理由
しかしそれにも拘らずInfraがModelとして扱われがちな原因には、既に本記事内で述べた通りMVCの構成があります。    
MVCアーキテクチャにおいて、アプリケーションはModel-View-Controllerで構成されており、そうなると消去法によってInfraもModelに分類されるしかありません。    

ただこれには1点留意点があり、補論冒頭で紹介したMVCの論文が発表されたのはWeb誕生以前の1979年です。    
当時のアプリケーションにおけるInfraの存在は、現在のように大きくなく、当初のMVCアーキテクチャの想定にはInfraは含まれていなかったのではないかと思われます。[<sup>*21</sup>](#footnote21)  
そう考えると、InfraがModelとして扱われがちな原因は、MVCアーキテクチャの構成そのものというよりも、Webの普及によってアプリケーション環境が大きく変わったにも拘らず、未だにWeb以前から存在するMVCアーキテクチャを採用している状況にあると言えるかもしれません。  

### Infraも独立して捉えたアーキテクチャの必要性
MVCの起源となるTrygve Reenskaug氏の定義から、Modelとは何かについて考えてきました。  
近年、WebアプリケーションだけでなくモバイルアプリでもRedux系のアーキテクチャが主流になりつつあるように感じますが[<sup>*22</sup>](#footnote22)、依然としてMVC(もしくはMV~系アーキテクチャ)は多くのプログラミング初学者が最初に触れるアーキテクチャです。  
しかし現代アプリケーションの性質を考えると、MVCの構成は初学者にModelとInfraを混同させ、設計の理解を妨げているように思います。  
現代アプリケーションにおいては、Infraはそれ自体独立して捉えなければならない程重要な役割を担っています。  
例えば、単純ですが、MVCI(Model-View-Controler-Infra)アーキテクチャがあれば、ModelとInfraのはっきりと分かれているのでプログラミングを始めたばかりの人でもModelが何であるのか、またInfraとModelがどのような関係であるのか混乱することなく理解できるのではないでしょうか。  

## 参考文献
  
書籍  
- [iOSアプリ設計パターン入門](https://peaks.cc/books/iOS_architecture)
- [ドメイン駆動設計](https://www.amazon.co.jp/エリック・エヴァンスのドメイン駆動設計-Architects’Archive-ソフトウェア開発の実践-エリック・エヴァンス/dp/4798121967/ref=asc_df_4798121967/?tag=jpgo-22&linkCode=df0&hvadid=295719984664&hvpos=&hvnetw=g&hvrand=3926308388276309968&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=1009283&hvtargid=pla-525481409888&psc=1&th=1&psc=1)  
  
Web  
- [MVCモデルについて](https://qiita.com/riku-shiru/items/2bed096e106e72e0b58a)
- [レイヤードアーキテクチャの視点](https://qiita.com/kichion/items/aca19765cb16e7e65946)
- [レイヤードアーキテクチャを振り返る](https://buildersbox.corp-sansan.com/entry/2019/04/21/000000_1)
- [MVCのモデルの誤解を解くためにフレームワークを例に挙げようとしたら誤解してもしゃーないなって思った](https://qiita.com/khsk/items/a8cd3adf1e22c9eb209e)
- [wiki(ビジネスロジック)](https://ja.wikipedia.org/wiki/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF)
- The Clean Code Blog by Robert C. Martin (Uncle Bob), The Clean Architecture(2012/8/13), https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html
- [Appleドキュメント(ViewController)](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)
- [GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)
- [Presentation Domain Separation](https://martinfowler.com/bliki/PresentationDomainSeparation.html)([日本語訳](https://bliki-ja.github.io/PresentationDomainSeparation/))
- [MODELS - VIEWS - CONTROLLERS](https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf)([日本語訳](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448))


## 注釈 
<a name="footnote1">*1</a>: ここでいうコンポーネントとは、アーキテクチャにおいてClass/Struct/Enumで定義されるような具体的な構成要素を指しています。MVCでいうところのModel/View/Controller、FluxでいうところのView/Action/Dispatcher/Store等です。「構成要素」と記すと他の集合体の要素と混同してしまう恐れがあるため、コンポーネントと表記しています。  

<a name="footnote2">*2</a>: 読み方によっては、クリーンアーキテクチャの「UseCases」や「Entities」が具体的なコンポーネントを示してると考えることができます。しかし私はこれらはUseCases(Application Business Rules)の性質を持ったコンポーネント、Entities(Enterprise Business Rules)を持った性質を持ったコンポーネントを抽象的に指し示しているだけであると考えています。例えばMVCの「Controller」、MVPの「Presenter」、MVVMの「ViewModel」などは全てクリーンアーキテクチャにおいては「Interface Adapters」と抽象的に称されることになります。  
  
<a name="footnote3">*3</a>: GUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」にあると述べましたが、少し正確さに欠ける表現かもしれません。なぜならGUIアーキテクチャの根底には本文内でも紹介している[Presentation Domain Separation](#補論2PDSを読み解く)(以下PDS)があり、そのPDSの中心には「アプリケーションのUIとその他を分離すること」ではなく、「ドメイン(ビジネスロジック)とその他を分離すること」という考えがあるからです。とはいえ大意で合っているのは確かですし、本論の内容には影響はありません。    

<a name="footnote3">*3</a>: [設計を理解するためのクリーンアーキテクチャ](#設計を理解するためのクリーンアーキテクチャ)では概念的な特徴に留めて説明がなされているため省略されていますが、実際にはクリーンアーキテクチャも「一方向のみの依存」の特徴を有しています。クリーンアーキテクチャの詳細は次章「設計を理解するためのレイヤードアーキテクチャ」で説明します。  

<a name="footnote4">*4</a>: ここでいう「アプリケーションの複雑さ」とは別の言葉でいうと「アプリケーション開発のしやすさ」です。    
  
<a name="footnote5">*5</a>: 正確にはレイヤー、モジュールとより大きな単位でも分割は起こっていますが、論旨とは関係ないためここではコンポーネントのみ取り上げています

<a name="footnote6">*6</a>: 「本は部・編・章・節・項と分割していくことで読みやすくはなるけど、結局その複雑さは文章量によるのでは?」という疑問もあるかもしれませんが、ここで指しているのはあくまで「情報は整理したらわかりやすくなる」という一般的性質であり、その例として本を挙げています。  

<a name="footnote7">*7</a>: ここで指しているのはアプリ開発全体です。アプリ全体から見ればサービス、技術、デザインに関する総合的的知識が必要です。ただ実際のプログラムでは責務による分割が適切に行われていれば、サービスとデザインの専門知識が求められるコードは互いに切り離されているはずなので、それらの知識が同時に必要になることはありません。    

<a name="footnote8">*8</a>: プログラムを理解するためにはその処理の流れを追っていく必要があり、その意味で依存関係が一方向である制約を持つレイヤードアーキテクチャよりもデータフローが一方向であるFlux/Reduxの方がより具体的な関係の制約を定めていると言えます。

<a name="footnote9">*9</a>: 関係については補論[アプリケーション設計における関係性とは](#補論1アプリケーション設計における関係とは)でも取り上げています。

<a name="footnote10">*10</a>: Modelについては補論[Modelとはなにか](#補論2Modelとはなにか)でも考察しています。

<a name="footnote11">*11</a>:  一般的に管理者を意味する「Manager」は抽象的でコンポーネント名の一部として使用するのは避けるべきだと言われており、それは「Controller」でも同様だと思いますが、私は、事ViewControllerに関しては致し方ないと思います。[Appleのドキュメント](https://developer.apple.com/documentation/uikit/uiviewcontroller)にはViewControllerの責務として「Viewの更新」「インタラクションへの対応」「レイアウトの変更」「他のオブジェクトとの連携」等が挙げられていることからもわかるとおり、ViewControllerはアプリケーションプログラムの基点であり、ここで様々な処理を担当せざるを得ない実情があります。そのため、これらを様々な責務を要約した表現として「manage/control(管理)」といった単語を使用することは問題ではないと考えています。  
 
<a name="footnote12">*12</a>: 実際の開発ではDomain・Infraクラスは複数箇所から利用される場合が多いためこの図のようにケース毎に定義されることはないと思います。
  
<a name="footnote13">*13</a>: ちなみに私はコンテクストが複雑にならない限りにおいて、ネスト構造をするのはありだと思います。  
 
<a name="footnote14">*14</a>: 実際には規定時間外で銀行の対面サービスは行われていない点等を含め、この例のサービス仕様は現実的ではありません。ここでの意図はコンテクスト(関係)が複雑になることでプログラムが開発しづらくなることを示すことであり、サービス仕様は仮想的で単純化されています。その意味でこの例は、サービス仕様がとても単純なものであっても関係に配慮しなければプログラムが煩雑になることを示しています。  

<a name="footnote15">*15</a>: この例ではネスト構造による複雑化を強調するため明らかにわかりづらいコードを意図的に書いており、このような煩雑なコードは現実的とは思えないかもしれません。しかしネスト構造によって複雑化してしまう場合の多くは、開発者が無意識のうちにどこかで誤った理解をしているはずであり、いささか誇張気味ではありますがこの例のようなケースが実際の開発で起こることもあながちあり得ないとは言い切れません。  
<a name="footnote16">*16</a>: ドキュメント和訳では「プログラム（ユーザーインターフェイス）のプレゼンテーション層」と記されていますが、原文をみてみると「the presentation aspects of a program (the user interface) 」となっており、そのドキュメントの意図を考えてもこの「（ユーザーインターフェイス）」は「プログラムのプレゼンテーション層」にかかっていると解釈するのが自然であると思います。そのため補論内では「プログラムのプレゼンテーション層（ユーザーインターフェイス）」と表記しています。  

<a name="footnote17">*17</a>:  ドキュメント和訳では「テスト可能なロジック部分」と記されていますが、原文では「more testable places」と記されており比較級を示すmoreが使われています。そのためここでは可能/不可能という二分法ではなく「テストしやすいロジック部分」という表現を使用しています。  

<a name="footnote18">*18</a>: ここでの[知性](https://kotobank.jp/word/知性-96179)は感覚作用も含めた広義の意味を持っています。  

<a name="footnote19">*19</a>: 全くもって余談ですが、ここでのUIは完成した料理だと言えます。

<a name="footnote20">*20</a>: [PDSのドメイン](#アプリケーションをビジネスロジックとビジネスロジック以外に分ける)と同様、GUIアーキテクチャのドメインにもレイヤードアーキテクチャのDomain層とApplication層が含まれています。        
 
<a name="footnote21">*21</a>: [Trygve Reenskaug氏のMVCに関する論文](https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf)には「API」はもちろん、「database」、「永続化」意味する「persistence」といった単語が一切含まれていません。  
<a name="footnote22">*22</a>: FluxやReduxアーキテクチャにおいてもInfra機能は直接表現はされていません。(Infraを含む非同期処理を行う場合は、FluxではActionCreator、ReduxではThunk Action、Middlewareの使用が一般的です。)しかし、近年WebのReduxではWeb APIと連携するRTK(Redux Tool Kit)Queryというツールが公式に採用されています。これは現代の設計、アーキテクチャにおいてInfraを末節として無視できないことを示す一つの現れであると言えます。

[^1]:　引用元:The Clean Code Blog by Robert C. Martin (Uncle Bob), The Clean Architecture(2012/8/13), https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html, 参考日:2022/2/25
