
# iOSアプリでスケールしやすいアーキテクチャを考えてみた①-設計を理解するためのレイヤードアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。(全部書いてから一気にあげようと思ったけど予想以上の大変で無理でした。😅)  
(1)**設計を理解するためのレイヤードアーキテクチャ編 <-本記事**  
(2)設計を理解するためのクリーンアーキテクチャ編(執筆中)  
(3)アーキテクチャ概要編(準備中)  
(4)ViewController編(準備中)  
(5)ViewとAlert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel編(準備中)  
(8)UseCase編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web APIとデータベース編(準備中)  
(13)その他(準備中)  

本記事では本編への(準備の)準備編として設計の概観を理解するためレイヤードアーキテクチャを説明しますので、  
「レイヤードアーキテクチャはもう知ってるよ」という人は次のクリーンアーキテクチャ編へ🚅、  
「レイヤードアーキテクチャもクリーンアーキテクチャもわかってるし」という方は概要編から読んでいただいた方が良いと思います。✈️  

## 前提
- 本記事の設計とはアプリケーションに関するものでライブラリ等の設計は想定していません。  
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容はどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

## 始めに  
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの言葉の定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物。  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるようなもの。  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっていることが多いと思うのでこの記事では上のように区別することとします。  


## 目的(記事で書かれていること)
現在、モバイルアプリの開発ではMVCを始め、MVP・Flux・クリーンアーキテクチャやその他様々なアーキテクチャが採用されています。  
これらのアーキテクチャはアプリケーション開発を行う際にとても有効で、作業をする上で大きな指針を開発者に示してくれますし、コミュニケーション時の共通言語としても役立ちます。  
ただこうしたアーキテクチャはアプリケーション構造の概観を提示してくれてはいますが、その詳細についてまでは言及していません。  
そのためアプリケーションの最終的な品質は個々の設計者・実装者に大きく左右されることになり、本来問題解決のために利用されているはずのアーキテクチャの中で別の問題を引き起こしてしまうということがあります。  
巷でよくいうFatViewController、FatViewModelといった問題ですね。  
またそれぞれのアーキテクチャはいずれも特定の問題領域に注目して作られているためそこには少なからず視点の偏りがあります。  
このような状況もあり、私は個々のアーキテクチャを学んでもアプリケーション設計について理解できている感じがしませんでした。  
それぞれのアーキテクチャの形式やメリットは理解できても、それらが設計全体において何を意味しているのかイマイチ良くわからなかったのです。  
このような曖昧な理解は、先ほどのFatViewControllerのようにアーキテクチャの中でまた新しい問題を作ってしまう原因になりえます。  
なので今回、設計を俯瞰的に理解するために様々なアーキテクチャを参考にしながらそこで得られたエッセンスだと思う要素とiOSアプリの構成を照らし合わせて、自分が保守・変更しやすいと思えるようなアプリケーション開発における雛形のようなものを考えてみました。  
本記事を含めた一連の記事で書かれていることはそのアーキテクチャの説明とそこに至るまでに得られた知見をまとめたものです。  


## 設計を理解するためのクリーンアーキテクチャ

「設計を俯瞰してみる」ということを最初の目的として記事を進めていこうと思いますが、なんの手がかりもなしに理解することは難しいです。  
なのでまずクリーンアーキテクチャを通して設計を理解していきたいと思います。  
既存のアーキテクチャの中からクリーンアーキテクチャを選んだのは、クリーンアーキテクチャの以下の特徴が理由です。  
1. 具体的なコンポーネント<sup>[*1](#footnote1)</sup>に依存しておらず、設計の思想を提唱している  
2. アプリケーション全体を主要な関心の対象としている  
3. 1と2の特徴を持ったアーキテクチャを総括した立ち位置にある  


それぞれの詳細について簡単に説明しますと、  
1はクリーンアーキテクチャにはMVPのPresenterやFluxのStoreのようにアプリーケーションに必ず含まなければいけないコンポーネントは存在しないということです。  
クリーンアーキテクチャはそのような具体的なコンポーネントには依存せず、アプリケーションを責務や性質により複数のグループに分割し、それらがどのように連携するのかという考えを提示しています。  
2はMVC・MVP・MVVM等のアーキテクチャは一般的にGUIアーキテクチャ<sup>[*2](#footnote2)</sup>と言われ、主にアプリケーションのUIとその他を分離することに注目していますが、クリーンアーキテクチャはそのようにアプリケーション内部の特定領域に注力したものではなくアプリケーション全体を主要な関心対象としています。  
3はそのままなのですが、1と2の特徴を持ったものとして他にもレイヤードアーキテクチャ・ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等があるなか、クリーンアーキテクチャはこれらのアーキテクチャを総括したような立ち位置にあるアーキテクチャです。  

クリーンアーキテクチャの以上のような特徴が設計を考える上で何を意味しているのかということは後ほど説明しますが、これらのことを簡単にまとめると「クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想」であるということです。  
これは「設計を俯瞰して理解する」という私たちの目標と完全に合致しています。  
ということでまず最初の目標としてクリーンアーキテクチャを通してアプリケーション設計への理解を深め、私たちの設計に関する共通認識を作っていきたいと思います。  

## クリーンアーキテクチャへの障壁
ただクリーンアーキテクチャと言えばこの円図が有名ですが、これが非常にとっつきづらいです。　　
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%　>
 
<sup>参考: [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)</sup>  

図が丸いのでどこからどう読んでいけばよいかわかりませんし、そもそもなぜ円なのかもよくわかりません。  
クリーンアーキテクチャを理解するためにはまず内容以前にその背景にあるコンテクストを理解する必要があります。  
なので本記事ではこの円図の背景にある考えを理解するためにクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャから学んでいきたいと思います。

## クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ

レイヤードアーキテクチャはアプリケーションを責務によって複数のグループに分割します。  
これは先ほどクリーンアーキテクチャの特徴として紹介しましたが、レイヤードアーキテクチャも同様です。  
そして分割された複数のグループが単一方向にのみ依存するような関係性を持っており、アプリケーション全体の構造が複数のグループが積み重ねられて層をなしているかのように思えるためレイヤードアーキテクチャ(layered architecture)なわけです、そのままですね。  
レイヤードアーキテクチャの目的はこの責務による分割と単一方向の依存関係によってそれぞれの層毎に開発の関心を分離することにあります。  
これによって開発者は開発時、常にアプリケーション全体に注意を向ける必要がなくなり、自分が担当している責務の層に集中することができるようになります。  
何層に分けるかについてはいくつか考え方があるのですが、私はアプリケーション設計を理解するという目的においては以下に示すように4つの層に分けるのが良いと考えているので今回はそれを紹介します。  

## レイヤードアーキテクチャの概要
レイヤードアーキテクチャの概要は以下の通りです

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャの概要.png" alt="レイヤードアーキテクチャの概要" width=60%　>


>補足  
>レイヤードアーキテクチャの層を指すUI/Application/Domain/Infrastractureという言葉は記事の中で他の用法でも利用されます。  
>なので以後、アーキテクチャにおける層を指す場合は英字で、より一般的な文脈で使われる場合はカタカナで表記することとします。  
>例:  
>Application(層) -> アーキテクチャにおけるアプリケーション層  
>アプリケーション -> プロダクト、アプリケーションプログラム等 
> 
>またInfrastructureはInfraと省略して表記します。  


### Domain層とApplication層
各層の内容はだいたい上の図に書かれている通りですが、Domain層とApplication層については少しわかりづらく、また両者の区別もしづらいと思うので説明します。


#### Domain層

まずDomain層から説明します。  
ここでのドメインとはそのアプリケーションが現実で従事する**業務領域**を指し、Domain層にはその業務に関する知識やルールを表現したデータやメソッドが含まれます。    
例えば銀行アプリのドメインは銀行業務全般であり、Domain層には取引の際のルール、顧客の口座等を表現するプログラムが定義・実装されます。  

#### Application層
一般的にはApplication層は「アプリケーション固有のデータ・ロジック」等と定義されていますが、もう少し平たくすると「ユーザーから見たアプリケーションの機能、またビジネスロジックの内ドメインとは関係しないデータ・ロジックを定義・実装する場所」だと言えると思います。  
ただこれでも依然として具体性にかけると思うので補足していきます。    

まず「ユーザーから見たアプリケーションの機能」というのは銀行アプリで言えば「お金の預入/引き出し/振り込み」等が当たります。  
「ユーザーから見たアプリケーションの機能」と定義が長たらしい理由は、「アプリケーションの機能」という定義だけでは先ほどの「お金の預入/引き出し/振り込み」というような機能を抽象化して「口座のお金の操作」とまとめてしまう可能性があると思ったからです。  
Application層の主な役割はそのアプリケーションで何ができるのかを**具体的**に示すことです。  
そのため具体性を保つためにユーザー目線で機能の定義をすることが重要で、そうすることで開発者が作業するのに役立ちます

そして後半の「ビジネスロジックの内ドメインとは関係しないもの」という定義も遠回しでわかりづらいのですが、これも具体例を使って説明します。
また銀行アプリを例に説明すると、そのアプリに「取引履歴をエクセル形式で出力する」機能があるとします。  
この「取引履歴をエクセル形式で出力する」機能はApplication層に定義しますが、その処理は大きく「取引履歴データの取得」と「取得したデータのエクセルファイル形式への変換」に分けられます。  
このうち「取引履歴データの取得」は銀行業務に該当するのでDomain層に定義されますが、「取得したデータのエクセルファイル形式への変換」は銀行業務ではないためApplication層に定義します  
このようにドメインとは関係なく、また単体ではアプリケーションの機能としては成り立たないような責務はアプリケーション固有のデータ・ロジックとしてApplication層に属すことになります。 

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/取引履歴データをエクセル形式で出力する例.png" alt="取引履歴データをエクセル形式で出力する例" width=60%　>  

他にもログイン状態を示した型などもビジネスロジックではありますが、ドメインとは関係ないのでApplication層のデータ型に入ります。  

#### Domain層とApplication層の関係
基本的にはApplication層でアプリケーションの個々の機能を定義して、Domain層でApplication層の内部で利用されるデータ・ロジックを定義すると捉えて良いでしょう。(上の[Application層](#Application層)の説明で書いたように例外もありますが)    
こうすることでApplication層によって機能単位で作業がしやすくなり、またそこからDomain層のクラス・メソッドを再利用することでコードの重複を減らせます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/Application層とDomain層(銀行アプリ).png" alt="銀行アプリを例にしたApplication層とDomain層の関係" width=70%>  

ここまででみてきたようにApplication層とDomain層は概念的に切り離すのが難しく、レイヤードアーキテクチャの中でも他の組み合わせと比べて密接な関係性にあります。  
しかしそれでもレイヤードアーキテクチャの目的である関心の分離はApplication層とDomain層の関係にも当てはまり、そのアプリの現実世界の業務に関するデータ・ロジックはApplication層には書いてはいけませんし、Domain層がApplication層からどう利用されているかは意識されるべきではありません。  

### ビジネスロジックとは
先ほどの[Application層](#Application層)の説明の中で「ビジネスロジック」という言葉が使われていますが、「ビジネス」と「ロジック」という日常的によく使う単語を組み合わせたものであるためなんとなく使われることが多いと思うので説明します。  
[wikipedia](https://ja.wikipedia.org/wiki/ビジネスロジック)にはビジネスロジックに関して明確な定義はないとしながらも、「実世界のビジネスオブジェクトをモデル化したもの」、「そのようなビジネスオブジェクト間の相互作用を示したもの」などと説明されています。    
このような説明でもなんとなくわかると思いますが、もう少し身近な形で表現すると「アプリケーションに関する仕様書をデザイン/ビジネス/技術の3つにカテゴライズした場合にビジネス仕様書に含まれるもの」であると言えるでしょう。        
アプリケーションに関する仕様のうちビジネスチームが関わるロジックとそこで利用されるデータを指しているため**ビジネスロジック**なわけです。  
これをレイヤードアーキテクチャに当てはめるとちょうどApplication層とDomain層を合わせたものをビジネスロジックと表現していることになります  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/アプリケーションの仕様書とレイヤードアーキテクチャの関係.png" alt="アプリケーションの仕様書とレイヤードアーキテクチャの関係" width=60%>  

このようにAppplicationとDomainの2つの層を一括りにして表現している「ビジネスロジック」という言葉が開発において頻繁に使われているということからもこの2層が密接に関係していることが伺えます。    
レイヤードアーキテクチャには4層ではなく3層構造で捉える見方もあるのですが、その場合はこのApplicationとDomainがまとまって一つになっています。      
ネットで調べていると、この3層構造のApplicationとDomainをまとめた表現として"Application"だったり"Domain"などが使われているケースもあるのですが、そうすると4層構造におけるApplicationとDomainと混同してしまうので私はBusiness Logic(ビジネスロジック)と表現するのが良いと思います。
のちに紹介する私が作成したサンプルプロジェクトでもディレクトリ名としてこのBusiness Logicを使っています。 
以後、この記事でもDomainとApplication層を合わせて表現したい場合、Business Logicと表現することとします。  

### レイヤードアーキテクチャの依存関係

#### 依存は一方向のみ
レイヤードアーキテクチャは層の分割に加えてそれぞれの層の関係性の定義も記しています。  
最初のレイヤードアーキテクチャの図でも説明されていますが、それぞれの層を  
UI-Application-Domain-Infra  
という順番に並べた場合、依存方向は左から右への一方向のみであるというルールです  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャの依存ルール.png" alt="レイヤードアーキテクチャの依存ルール" width=60%>  

#### 反対方向への呼び出しは?
依存方向は一方向のみであるというルールですが、もし上の図でいう右から左へ呼び出しを行いたい時はどうしたら良いのでしょうか?  
例えばApplication層の結果に基づいてUI層で処理を行いたい場合はApplication層->UI層の依存が必要なように思います。  
こうした状況を依存のルールを破らずに解決する方法がいくつかあるのですが本記事のテーマから逸れてしまうため次の記事で取り上げ、この記事ではとりあえずメソッドの返り値によって解決できるものと仮定します。  
上の例で言えばUI層はApplication層メソッドの返り値によって必要なデータを取得できるため、Application層->UI層の依存は必要ありません。  

#### 層を跨いだApplication層からInfra層への依存
依存方向は一方向なのですが、一つ注意しておきたいのがDomainを跨いだApplication->Infraという依存関係もありえると言うことです。   
これは実際のアプリの機能を考えてみればわかります。  
例えばアプリのログイン状態はDomainとは関係ないのでApplication層のデータですが、このログイン状態は通常、次回起動時も引き続き利用するデータなのでInfra層の永続化機能で保存するが必要があります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ApplicationからInfraへ依存.png" alt="ApplicationからInfraへ依存" width=60%　>

このようにアプリケーションにおいてはApplication層のデータをInfra層を使って操作することは少なからずあるためApplication->Infraという依存関係は自然と発生します。   
しかしこの場合も依存方向が一方向であるということは同じです。  

#### Application層からInfra層への依存以外で層を跨いだ依存はない
ここで一つ疑問に思うのが、「Application->Infrastractureという依存関係がありえるのならば論理的に考えればUI->Domain/Infraというケースもありえるのでは？」ということです。  
しかしこのような依存関係は実際の開発ではありえません。  
なぜなら既に述べた通りApplication層は「ユーザー目線でアプリケーション機能」を定義している場所であり、言い換えるとこのApplication層はユーザーの要求に応えるべく複数のDomain層の処理を連携させています。  
そのためUI層がApplication層を飛び越えてDomain/Infra層にアクセスする場合、Domain/Infra層の処理の連携をUI層が担うこととなり、関心の分離が破られUI層のコードが肥大化・複雑化していきます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/UIからDomainとInfraを利用.png" alt="UIからDomain/Infraを利用した場合" width=70%>

ケースによってはApplication層への呼び出しが冗長でUI層からDomain層を直接呼び出したいこともあるかもしれません。    
ただそこでApplication層を省略してUI->Domainの依存を許容してしまうとアプリケーション全体でUI->ApplicationとUI->Domainの二つのフローを持つことになり、結果としてApplication層を省略することによるコストカット以上に設計・開発の複雑さが増え開発コストが嵩むことになります。  

このようにApplication層を確立しているにも関わらずUI->Domain/Infraという依存関係を構築しても設計が複雑になってしまうだけであるため実際の開発ではあり得ないと考えてもらって大丈夫です。  

これら4層の依存関係で少し変わったケースがあるのは先に説明したApplication->Infraのみです。  

以上でレイヤードアーキテクチャの基本的な説明は終わりですが、クリーンアーキテクチャへ進む前にレイヤードアーキテクチャについて何点か考えることで設計への理解を深めたいと思います。  

## レイヤードアーキテクチャの層の分割は4つが適切か？

レイヤードアーキテクチャの説明の冒頭で分ける層は4つで良いと書きましたが、本当にそれで良いんでしょうか？  
ここでは4つの層が適切であるという私なりの根拠をアプリケーションの層を一つ一つ分割しながら説明していきたいと思います。  

### アプリケーションをビジネスロジックとビジネスロジック以外に分ける

まずアプリケーションを「Business Logic」と「Business Logic以外」というように分割します。  
アプリケーション設計には[Presentation Domain Separation(プレゼンテーションとドメインの分離)](https://bliki-ja.github.io/PresentationDomainSeparation/)(以下PDSと表記)という考え方がありますが、これはアプリケーションをビジネスロジックとその他に分けるものです。  
なぜ最初にビジネスロジックが抜き出されるのかというと、やはりここがアプリケーションプログラムの機能的中心であり、また他の層が外部機構に依存しているのに対してプログラミング言語による純粋なデータ宣言とロジックによってなされているからだと考えます。  
そのような純粋なデータとロジックの集合であるビジネスロジックを他と切り離すことで再利用が可能になり、テストもしやすくなります。   


#### プレゼンテーションとドメインの分離(Presentation Domain Separation)についての補足
PDSについては2点ほどわかりづらいところがあると思うので補足します。  
##### 1 ドメイン=ビジネスロジック
最初にPDSのドメインをビジネスロジックと置き換えていることからもわかる通り、ここでのドメインは実質的にはApplication層とDomain層を含んでいます。  
実質的にはというのは概念的な意味としてはこのドメインはレイヤードアーキテクチャでのドメインと同じ「業務領域」を指していると思いますが、そもそもPDSはアーキテクチャではなく設計原則であって具体的な層やコンポーネントを指しているわけではありません。  
そしてPDSのドキュメントを読むにその第一の主張はアプリケーションの機能に関するロジックと他の部分を切り離すことにあると考えられるので、ここでのドメインをレイヤードアーキテクチャの文脈に照らし合わせるとApplication層も含めたBusiness Logic層と捉えた方が正しいと思います。  

##### 2 プレゼンテーションとはUIを含めたドメインと連携する全ての機構を含む
次にプレゼンテーションという言葉は一見UIを想起させますが、ここにはInfraも含まれます。   
[PDSのドキュメント](https://bliki-ja.github.io/PresentationDomainSeparation/)には最後に補足のような形で以下の文が書かれています。  

>人間ではなく、コンピュータ相手の Web Services だって、プレゼンテーション部分です。  
>ですから、ドメイン部分のコードと Web Services 部分のコードをごちゃまぜにしてはいけないのです。  
>外部APIにしてもそうです。  

上の引用文から推察するに、どうやらここでいうプレゼンテーションはUIのみを指しているわけではなくドメインと連携する外部機構全てを指していると捉えた方が良さそうです。  
この意味でPDSという概念の中心はプレゼンテーションではなくドメインであるように思います。  
最初のPDSの定義を「ビジネスロジックとプレゼンテーション」ではなく「ビジネスロジックと**ビジネスロジック以外**」と表現したのもそのためです。  

### Business Logic以外をUIとInfraに分ける
これは特に説明不要でしょう。  
UIとInfraはPDSではドメインに対する外部機構として一つにまとめられていましたが、一般的にユーザーとの接点であるUIとアプリケーションを裏で支える技術基盤の役割を担うInfraを区別することに異論はないと思います。  
ただUIとInfraを区別することに違和感がなくても、永続化機構や端末機能をInfraと一つにまとめることには違和感がある人はいるかもしれません。  
確かに永続化機構や端末機能はアプリケーション上の役割は異なり、場合によってはそれぞれをData、Deviceと区別します。  
しかしどちらもアプリケーションの機能を技術的に裏で支えているということは共通しており、また設計上でもUIとBusiness Logicの関係性は「UI->Business Logicn」とUIからBusiness Logicを呼び出す形になりますが、Data/Deviceはともに「Business Logic->Data/Device」となっていてBusiness Logicから呼び出されるためアプリケーション上の立ち位置は同じです。  
そのため設計の概観を捉える上ではこれらは一つにまとめた方がわかりやすいと思います。  
なのでこの記事でも必要であればData/Deviceと区別して表現しますが、そうでなければInfraとして括ることとします。  

### ビジネスロジックをApplicationとDomainに分ける

最後にビジネスロジックをApplicationとDomainに分けます。  
この2層は[既に説明した](#Domain層とApplication層)通り非常に密接に関わっていますが、やはり責務の質が異なります。  
また設計論においてもFlux/Reduxを筆頭に近年Application層の状態を管理することを目的としたアーキテクチャが注目されており、  
そしてドメイン層に注目した開発・設計論であるドメイン駆動開発はその提唱以来多くの人に支持されています。  
このようにApplication層とDomain層の設計論がそれぞれ注目を集めるほど、各々が設計において固有の問題を持っています。  
このような事情を考えてもアプリケーション設計を理解する上で、Application層とDomain層は独立した2つの層として捉えた方が良いと考えています。  

### この4層によってアプリケーションの提供元である企業から提供先であるユーザーまでしっかり捉えている

さて、アプリケーションの層をその必要性を考えながら一つ一つ分けていったのですが、私がこの4層が最適だと思う理由はこれによってアプリケーションの端から端までをしっかりと表現できているからです。  
端から端までとはアプリケーションの提供先であるユーザーとの接点となるUIと提供元となる企業もしくは事業のことです。  
UIに関しては説明するまでもないと思いますが、企業(事業)について説明するとドメインとは業務領域を意味していると書きましたが別の言い方をするとその企業がアプリケーションを通して行っている事業の知識・ルールを記述している層だということができるのです。  

このように4つに分割することでアプリケーション上でその提供先であるユーザーとの接点になるUIと提供元となる事業(Domain)をしっかりと捉えることができるようになっています。  
もしこれより少ない層にしてしまうとUIとInfraをPresentationとしてまとめたり、ApplicationとDomainをBusiness Logicとしてまとめたりとアプリケーション開発において異なる責務を持つ層を一緒くたにしてしまうことにより複数の問題を混同してうやむやにしてしまう可能性がありますし、逆にこれ以上層を分けていったとしても詳細に立ち入りすぎてアプリケーションの概観を理解するという点においてその構造は必要以上に複雑になりすぎてしまうでしょう。  


## 設計とは関係性を構築することである
本記事の最後にアプリケーション設計においてレイヤードアーキテクチャから学べることを考えていきたいと思います。  
これに関してはいろいろと意見があると思うのですが、ここで私が述べたいことは「設計とはアプリケーションにおいて開発しやすい関係性を構築すること」であるということです。  
レイヤードアーキテクチャではアプリケーションをその責務や性質の違いから4つのグループに分類しました。この一番のメリットは「関心の分離」です。  
それぞれの層が他の層に影響を与えるのは自身が返り値として出力するデータのみです。(メソッドの返り値ではなく、他の方法でデータを出力している場合もあります。)    
そのため各層の関心が分離され、各層の変更によるアプリケーション全体への影響は非常に限定されます。  
そして層の間の依存関係は単一方向なので、最終的にプロダクトとして4つの層が連携する場合もその構造が複雑になってしまう恐れはありません。  
このようにレイヤードアーキテクチャでは責務によってアプリケーションを分割しそれらをシンプルな関係性によって構築することによって全体の構成がより具体的になり、開発のさまざまな面で予測しやすくなるため開発効率が大きく上がります。  
また開発者の心理面から言ってもそれまでアプリケーションと漠然と捉えていたものをUI/Application/Domain/Infraというより具体的な責務の集まりと捉えることによってアプリケーション開発に対する見通しがよくなり負担はだいぶ軽減されると思います。    
  
ここでは記事の都合上レイヤードアーキテクチャの流れから「設計とは関係性を構築すること」だと話していますが、これはなにもレイヤードアーキテクチャに限ったことではありません。  
MVCはアプリケーションをModel-View-Controllerの構成で捉えた上でそれらの関係性を定義しているということができますし、他のアーキテクチャも同様です。  
また、よりミクロな観点でもデザインパターンはアプリケーションにおける特定機能を実現するためのパターン(関係性)を提示しており、SOLID原則はそれらの関係性が適切に保たれているかどうかの判断基準であるということもできます。<sup>[*3](#footnote3)</sup>  

## 関係性の複雑さ=アプリケーションの複雑さ

このようにアプリケーション設計のマクロからミクロレベルに至る全ての概念やテクニックは関係性を定義しているといって良いと思いますが、その理由はこの関係性がアプリケーションの複雑さを直接的に決定しているからです。  

いくつか具体例を出して説明します。

## Fat ViewControllerの問題

### MVCのModelにはApplication/Domain/Infra層が含まれる
レイヤードアーキテクチャはUI-Application-Domain-Infraという構成であるということを説明しましたが、これらをMVCアーキテクチャの文脈に当てはめるとUIを除くApplication/Domain/Infraは全てModelに分類されます。

>補足  
>・iOSMVCのControllerに当たるのはViewControllerですが、UIKitに含まれていることからもわかる通りViewの操作を行う役割を担いUIの仕様を把握しているのでレイヤードアーキテクチャではUI層に該当します。
>   
>・MVCにおいて厳密にInfraがModelに分類されるのかは個人的に疑問なのですが、  
>　少なくともネットでMVCの概要を調べるとInfraをModelに含めてる記事は散見していますし、  
>　何より各コンポーネントをMVC(Model-View-Controller)のどれかに分類するなら消去法でModelしかないのでここではそういうことで話を進めます。<sup>[*4](#footnote4)</sup>  

そうするとレイヤードアーキテクチャにおいて異なる階層に属していたApplication/Domain/Infra層のコンポーネントは全てModelという一つのカテゴリーの中で並列関係となり、iOSMVCでは以下のような構成が成立するように思えます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/単純に考えたMVC.png" alt="Modelを深く考えず設計した時に起こりうるMVCの構成" width=70%> 

### FatViewControllerとはViewControllerの責務が本来より大きくなってしまっていること
このような構成は図でみると一見問題ないようにみえますが、実際の開発では大きな問題を生み出します。  
俗にいうFatViewController問題です。  
FatViewControllerとはViewControllerにビジネロジックが書かれる等、ViewControllerの責務が本来あるべき以上に大きくなっている状態を指していますが、上の図のMVCもその構成上ViewControllerの責務が本来以上に大きくなってしまうことは避けられません。
その原因は追求していくとViewControllerとModel間の関係性の複雑さにあります。  
このケースでは関係性の複雑さというよりも関係性の曖昧さといった方が良いかもしれません。   

ここではFatViewControllerの原因を順に説明しながら、なぜ上のような構成だとFatViewControllerになってしまうのかを見ていきます。
### FatViewControllerの問題はViewControllerというクラス名ではない
FatViewControllerというとViewControllerの責務がわかりづらいことに目がいきがちですが、[Appleドキュメント](https://developer.apple.com/documentation/uikit/view_controllers)には   
>You use view controllers to manage your UIKit app’s interface.    

とViewControllerの責務はUIをmanage(管理)することにあると書かれていて、View(UI)をcontrol(管理)するというViewControllerは決しておかしなクラス名とは思いません。(ドキュメントでmanageという言葉を使いながらクラス名がViewControllerなのはiOSプログラミングを既存のMVCに寄せて親しみやすいようにしたからでしょうか。)  
「管理」という言葉自体が明確さに欠けるというのはありますが、それが問題になるのは言葉そのものというよりもViewControllerと周辺との関係がわかりづらいからです。

### ModelとViewの責務が明確ならば、ViewControllerの責務も明確だ
ここでいきなりスイスの話をします。  
スイスはドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの5つの国に囲まれ、4つの言語を公用語としている非常に国際色豊かな国ですが、このスイスの領土を知るためにはどうしたら良いでしょうか？  
  
答えは簡単で、スイスからみてドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土がどこから始まっているかがわかるとスイスの領土も知ることができます。   
言い換えればドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土を知っているならば、スイスの領土は間違えようがありません。  
  
ViewControllerだって同じです。iOSではViewControllerはModelとViewの間に立つコンポーネントであり、隣接しているModelとViewの責務が明確であればViewControllerの責務も自然と明確になります。  
そのためViewControllerの責務がそのクラス名から推測可能であるにもかかわらず依然として曖昧な部分を残してしまうのはModelとViewの責務がはっきりしていないからと言えますが、ここで一般的に問題となるのはそのModel側です。

### ViewControllerにとってのModelの役割が曖昧
上のMVCの図で示した通りApplication/Domain/Infraと役割の異なるコンポーネントを全てModelとしてしまっているため、各Modelクラスの責務が曖昧になりViewControllerにとってModelがどのような役割を持っているのかもはっきりわかりません。

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ViewController-Modelの関係性.png" alt="Modelの責務の曖昧化" width=60%> 

ViewControllerからみてModelの役割が明確でないことはViewControllerの責務を拡大解釈したり、また意図していなくとも無意識のうちにModelの責務が漏出するといった事態につながっていきます。

そしてどんなにこのViewController-Model間で問題を抱えていても、Viewではユーザーに適切な形で情報を表示しなくてはなりません。  
そのため先に見たMVCの構成のようにViewControllerからModel(Infra)やModel(Domain)を直接利用した場合、ViewControllerはModel(Infra)/Model(Domain)からの取得したデータを操作したのち本来の責務であるViewの操作を行うことになるため、責務が膨れ上がりコードが肥大化していきます。  

このように一般的なFatViewControllerの問題はModel内のコンポーネントの関係性をどう構築して良いかわからない結果、Model-ViewController間の境界線が曖昧になってしまい(この時にViewControllerの「Controller」という言葉が拡大解釈されます)、Model側の責務がViewController側に漏れてしまうことに原因があります。  


<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/FatViewController.png" alt="FatViewController" width=70%> 
  
もちろんこれはiOSMVCの理想的な形ではありません。[AppleのViewControllerに関するドキュメント](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)にも  

>you should minimize the view controller’s role in managing the actual data.

とあり、ViewControllerのデータの操作は最小限にするべきと記されています。  
  
ただそうだとしてもModel-View-Controllerという責務の分担ではApplication/Domain/InfraをModelとして並列に捉えてしまうのは致し方なく、  
さらにControllerからModelを利用するというMVCのシンプルな構図だけではFaViewController問題は必ずと言って良いほど起こってしまうものだと思います。  

MVCは概念としてはシンプルでわかりやすいのですが、実際の開発を考えるとApplication/Domain/InfraをModelという一言で済ましてしまうのは言葉足らずな感じがします。  

>補足  
>1  
>ここで述べたFatViewControllerの問題はレイヤードアーキテクチャの依存関係のところでも書いた[UIがApplication層を跨いでDomain/Infraを利用した場合の問題](#Application層からInfra層への依存以外で層を跨いだ依存はない)と外面的には同じです。  
>ただレイヤードアーキテクチャの場合ではModelの責務をしっかりとApplication/Domain/Infraに区別した上でその依存関係の誤りによって問題が起こってしまったのに対し、MVCのFatViewControllerではそもそもApplication/Domain/Infraの区別ができていません。  
>そのため問題の原因はより複雑であり、Modelの責務が曖昧になっていることさえ気づかず無意識に起こしてしまっている可能性もあるため状況としてはより深刻であると思います。    
>  
>2  
>ここではFatViewControllerを取り上げたので問題の力点がViewController-Modelに置かれていますが、Modelの責務が曖昧になっているということはViewController-Model間だけでなくModel内部でも問題を引き起こします。    
>Model内の各コンポーネント間で適切な関係性が構築されていない場合に発生する問題は大きくいうと、各責務が小さすぎてコードが冗長になってしまうかもしくは逆に責務が大きすぎて作業しづらいFatModelです。


### レイヤードアーキテクチャを取り入れたMVC

レイヤードアーキテクチャはクリーンアーキテクチャと同様に設計思想に近いため、他のアーキテクチャと併用することが可能です。  
ここではMVCにレイヤードアーキテクチャを取り入れたものを見ていきたいと思います。  
図<sup>[*5](#footnote5)</sup> にすると以下のような感じです。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャを取り入れたMVC.png" alt="レイヤードアーキテクチャを取り入れたMVC" width=70%>  

上の図をみただけで、先ほどの単純なMVCよりもわかりやすくなったのがわかるのではないでしょうか？  
ViewControllerから利用するモデルはレイヤードアーキテクチャでいうApplication層モデルのみとなり、ViewController-Model間の関係性がはっきりとしました。  
そして既に説明した通りApplication層はUI層へ渡すデータはユーザーの要求に直接対応しているはずです。  
そのためViewControllerのデータ操作は必要最低限のものになり、複雑なロジックを抱えなくなります。 
>補足  
>ここでいうViewControllerの必要最低限のデータ操作とは、Modelから渡されたログインしているかどうかというBool型を"ログイン中"というString型に変換する等です。  
>Model(Application)はViewの仕様を知っているべきではありません。  
>そのためModel(Application)からのデータがユーザーの要求に直接対応していたとしても例に出したようにコンピュータにとって都合の良いデータ形式を人間に都合の良いデータ形式に変換する作業はViewControllerで行う必要があります。　　

このようにMVCのModelをレイヤードアーキテクチャによって再考することによって、ViewController-Modelの関係性がシンプルでわかりやすくなり、ViewControllerで複雑なデータ操作を行う必要がなくなったため責務が肥大化することがなくなりました。  

### MVCとMVC+レイヤードアーキテクチャの比較
単純なMVCとレイヤードアーキテクチャを採用したMVCを比較すると、レイヤードアーキテクチャを採用しているMVCの方が責務をより細かく分ける傾向にあるためコードやコンポーネントの量は多くなる可能性は高いと思います。  
しかしそれでもレイヤードアーキテクチャを採用している方が各コンポーネントの責務がはっきりしているため、自身がどこから利用され、またどのコンポーネントを利用するのか悩む必要はありません。  
このようにそれぞれの責務・関係性が明瞭になることで開発者はどのようにコードを書くべきか考えるコストが減り、またチーム開発でのタスクの分担も行いやすくなるなど開発効率が大きく上がります。  
こうした責務・関係性がわかりやすい設計による開発効率へのポジティブな効果はそのプロジェクトの規模が大きくなればなるほど高くなっていきます。  

## ネスト構造によるコンテクストの複雑化
関係性がアプリケーションの複雑さを左右する例についてもう一例紹介します。  
プログラミングをやっていると「ネスト構造を深くすることは避けろ」ということをよく耳にすると思います。  
ネスト構造が否定的に捉えられている理由は分岐が入り組むことによりコードの流れを追うのが難しくなること、また一つ一つのブロックがコンテクストを提供しているのでそれらが入れ子になった結果全体のコンテクストが複雑になってしまうことにあると思います。  
そのような複雑なコンテクスト内では、内側のブロックを読む際にはその外側のブロックのコンテクストも把握していなければならず開発者は常に目の前のコード以外の事にも注意を払う必要があるため認知負荷がとても高くなってしまいます。  
そしてコンテクストが複雑になるということは関係性が複雑になっているということでもあります。

ネスト構造が深くなってしまった例<sup>[*6](#footnote6)</sup>
```
//手数料の計算ロジック

func calculateBankingCommission() -> Int {
    var fee: Int = 0
    if 会員の場合　{
         if 引き出しの場合 {
            fee += 50
            if 平日の場合 {
                 if 9~17時の場合 {
                    return fee
                 } else {
                    return fee + 50
                 }
            } else {
                fee += 50
                if 9~17時の場合 {
                    return fee
                } else {
                    return fee + 50
                }
            }
        } else if 預入の場合 {
             ...
        } else if 振り込みの場合 {
             fee += 300
            ...
        }

    } else {
        ...
    }
}


```
  

## アプリケーションの関係性を考えることで適切な設計を見つける

関係性がアプリケーションの複雑を決めているということを2つのケースを例に説明しました。  
他にも該当するケースはいくつもあり、挙げていけばキリがないのですが、ここで私が関係性ということについて言及したのはそれが設計に関する思索や議論の滑り止めになると考えているからです。  
私たちがコードの設計について考えるときにとりうるアプローチは数多くあり、その中には互いに正反対の方向性を持ったものもあります。  
あるケースではコードの重複を減らすために複数のコンポーネントに分けて考えていたものをまとめて一つにするのが良いかもしれません。
また別のケースでは反対に責務の複雑性を回避するため、コンポーネントから特定の責務を取り出して別コンポーネントとした方がわかりやすくなるかもしれません。  
私たちはこうしたさまざまな解決方法の中から適切なものを選んでいく必要がありますが、その時にそのコンポーネントの背後・周辺にある関係性を考えることが大きな助けとなります。  

## 関係性を考えなかった結果、失敗したViewModelの設計

ここでは私が関係性を考えずに設計を行った結果失敗した経験を紹介することで、アプリケーション設計において関係性を考えることの重要性を示したい思います。  
私はこのあとの記事で紹介するサンプルプロジェクトを作る際、ViewModelの設計を画面機能ごとにまとめようと考えました。  
画面機能毎にprotocolとその既定実装を書くことでコードを再利用できるように考えたのです。  
しかしその結果ViewModelはとんでもなく複雑で、開発しづらいものになりました。  
その理由は今から考えればとても馬鹿馬鹿しいと思うのですが、ViewModelが「ViewのModel」だからです。  
ViewModelの中心にあるのはあくまで「View」であって「Model(Viewの機能)」ではありません。  
ViewModelの設計の根幹に「View」ではなく「Model」を据えてしまったことにより以下のような問題が発生しました。
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ViewModelの設計(失敗例).png" alt="ViewModelの設計(失敗例)" width=70%>
- 変更しづらい・・・各責務はViewModelに書かれたコードとViewModelが適応するいくつものProtocolに散在することになり、責務の全体像が把握しづらくコード変更時にどのような影響が出るのかよくわからなくなってしまった
- 理解しづらい・・・責務を理解するためにはいくつものProtocolを参照しながらそれらを頭の中でまとめあげ、さらにそこにViewModelクラス自身の責務を加える必要があったが、いくつもファイルを跨いでるうちに初めの方に読んだコードを忘れがちで仕様の把握が大変
- 設計がいつ崩壊してもおかしくない・・・Protocolの既定実装では格納プロパティを持てないため、仕様の追加・変更によっていつこの設計が崩壊してもおかしくない


今回のケースではどんなにコードの重複を減らせたとしても、ViewのModelであるViewModelはView毎に責務をまとめる必要がありました。  
これはアプリケーションにおけるViewModelの立ち位置を考えず、コードの重複を減らすことだけに目がいってしまったがための失敗です。  

設計においては、殊更プログラミングの世界では、何が実現(運用)可能で何がただの机上の空論なのかという判断が非常に難しいです。

そのため設計を行う際はコンポーネントのアプリケーションにおける立ち位置や関連するコンポーネントとの関係を考えることがとても重要になります。  
そうすることで数ある中からその開発により適切なアプローチを選び出すことができるようになるからです。  

## この一連の記事で書かれていることも全て関係性についてである

設計を考える際に関係性を考えなくてはいけないということはいかなる設計論の背後には関係性が提示されているということができます。  
設計論ではマクロからミクロに至るまでさまざまな技術やパターンそして概念が登場し、それら全てを別個のものとして理解していてはあまりに情報量が多く目が眩んでしまいます。  
しかしそういう時、それらの全ての背後にある核心が関係性であることを理解していれば詳細に圧倒されることなく、設計を理解する助けになるはずです。  
この一連の記事でもこのあとアプリケーションのさまざまな箇所についてさまざまな視点からスケールしやすい設計を考えていきますが、そこで書かれていることは全てあるコンポーネントを理解しその責務と他のコンポーネントとの関係性を見つけるという作業となります。  
>補足  
>コンポーネントが先にあってそれから関係性を構築するのか、関係性を構築するためにコンポーネントを作るのかというのはケースバイケースだと思うのですが、これまでのプログラミングの歴史におけるアーキテクチャの探究の中でアプリケーションにとって大事なコンポーネントはほとんど出揃っていると考えています。  
>また既存で普及しているコンポーネントから考えた方が私も作業しやすいし、皆さんも理解しやすいでしょう。  
>なので基本的にこの記事では既存のコンポーネントを利用しながらそれらの関係性を考えていくというスタイルで話を進めます。  

## 準備の準備編(本記事)のまとめ
- クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想である
- レイヤードアーキテクチャはクリーンアーキテクチャの原型であり、その主な目的はアプリケーションをUI/Application/Domain/Infraという責務の集まりと捉えることによって開発時にそれぞれの責務の関心を分離することである。
- 設計とはアプリケーションにおいて開発しやすい関係性を構築することである


## 補論1 アプリケーション設計における関係性とは
本記事内で設計においては関係性を考えることが重要であることを書きました。  
ここではもう少し具体的にアプリケーション設計における関係性を示したいと思います。  
### 関係性はどこで起こる
まずアプリケーション開発(主にコーディング)において関係性とはどこで生まれるのでしょうか。  
私は大きくいって関係性が発生する箇所は3つあると思います。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/アプリケーションにおける関係性.png" alt="アプリケーションにおける関係性" width=70%>  
1. コンポーネント内部・・・コンポーネント内部の変数・メソッド間の関係性。さらには処理内部の中のローカル変数と計算の連携。  
2. コンポーネント間・・・コンポーネント同士の繋がり。  
3. アプリ内でのコンポーネント、またそれに対する開発者・・・アプリケーション全体におけるコンポーネントの役割、またその開発者にとっての意味  
  
1と2はそのままなので、3について説明します。  
まず「アプリケーション全体に対してコンポーネントの役割」とは本記事内[ViewModelでの設計失敗談](#関係性を考えなかった結果、失敗したViewModelの設計)で見たように、アプリケーション全体においてコンポーネントが担うべき責務のことですが、これに加えてそれが開発者に対してどのような役割を担っているかも重要です。    
ViewControllerを例に出して説明します。  
iOSアプリにおいてViewControllerは画面を統括する役割も担っていますが、開発者に対して具体性を示してもいます。    
実際のiOSアプリの画面に対応するViewControllerの存在のおかげで、開発者は実際のアプリケーションプロダクトとアプリケーションコードの親和性を感じることができます。  
ほとんどの開発者にとってViewControllerはそのアプリケーションコードを理解するための入り口となっているはずです。   
設計とは関係性を構築することだと言いましたが、そのような関係性を構築するのは    
- (開発者にとって)コードが読みやすい　　
- (開発者にとって)コードを書きやすい　　
- (開発チーム・開発者にとって)作業に取り掛かりやすい　　

など開発作業に好影響を与えるためです。  
そのため設計をする際には各コンポーネントが開発作業においてどのような役割を担うかも重要になります。 
 
### 関係性によりアプリケーションが複雑化する原因
次に関係性によってどのようにアプリケーションが複雑になるか考えたいと思います。  　
私が今のところ思い浮かんだのは以下の2点です。　　

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/関係性によるアプリケーションの複雑化.png" alt="関係性によるアプリケーションの複雑化" width=70%>
    
1と2は互いに排他的ではなく、関係性が複雑になることにより同時に起こってしまう現象です。      
コンテクストの複雑化は記事内では[ネスト構造](#ネスト構造によるコンテクストの複雑化)と関連づけて紹介しましたが、ネスト構造に限った話ではありません。     
コンテクストはコンポーネント自身、またコンポーネントの繋がりなど関係性が発生するあらゆるところで発生します。      
図の2でも、都合上省略しましたが繋がりによるコンテストはコンテクストEだけではなく、コンテクストA->コンテクストBなどあらゆるコンポーネント間の繋がりでも発生しています。  
  
簡単にアプリケーション設計における関係性を具体化してみました。  
本来これだけで記事が書けるくらい大きいなものだと思うので、もう少し煮詰めることができたら別記事で取り上げたいと思います。　　    

## 補論2 Modelとはなにか？
記事内のFat ViewControllerに関する内容でMVCのModelにはInfraも含まれるとして話を展開しつつも、厳密にModelにInfraを含めることには違和感があるとも記しました。
ここではそれらの問題を踏まえながらModelとは何かということについて考えたいと思います。  
まずMVCの提案者であるTrygve Reenskaug氏の記事にはModelは以下のように定義されています。  

>Models represent knowledge.   
>(中略)  
>There should be a one-to-one correspondence between the model and its parts on the one hand, and the represented world as perceived by the owner of the model on the other hand.   
>The nodes of a model should therefore represent an identifiable part of the problem.  
>  
>意訳:  
>モデルは知識を表している。  
>(中略)  
>モデルとそのパーツはその設計者のメンタルモデルと対応していなければならない。  
>*「owner」を設計者と意訳しましたが、そのソフトウェアの発案者やアイディアを考えた人といっても良さそうです。  


後半はだいぶ意訳です。
定義内の
>the represented world as perceived by the owner  

をどう解釈するのかが定義の鍵となるのですが、私はメンタルモデルと訳すのが一番良いと思います。  
モデルの話にメンタルモデルと似た用語が出てきてわかりづらいのですが、メンタルモデルは「ある対象に対してのイメージ」です。  
上の箇所の[日本語訳](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448)をみると
>その所有者によって知覚された世界の表象  

とわかるようでわからない日本語なのですが、      
要は「感覚的な認識によって示された世界観」みたいな意味でさらに簡潔にいうとメンタルモデルと言って良いと思います。  

そして少なくともアプリケーション開発ではInfraはメンタルモデルとは無縁であり、この定義にInfraに含まれないと思います。  
料理の写真を見て実際に自分で作ってみようとなった時、食材やその調理方法をいろいろイメージしながら作ると思いますがその時に水道やガスシステムの構造までイメージする人はいませんよね。  

この論文が発表された1979年にはまだWebは誕生しておらずネットワークを利用したアプリケーションは一般的ではないためデータベースやWeb APIはアーキテクチャの想定に入っていないと思いますが、ここでのModel定義とデータベースやWeb APIクライアントの性質を照らし合わせるとこれらはModelには直接的に含まれてはいないと思います。  

そしてTrygve Reenskaug氏のこのModelの定義はGUIアーキテクチャのドメインオブジェクトの定義と全く同じです。  
>domain objects that model our perception of the real world  
>  
>意訳  
>現実世界に対する認識を型どったドメインオブジェクト  

こうしたModelとドメインオブジェクトの定義を照らし合わせてみても、Modelに該当するのはDomain、Application層のオブジェクトだと思います。(記事内でPDSのドメインにはレイヤードアーキテクチャでいうDomainだけでなくApplicationも含むと述べましたが、ここでも同様です。)  

そもそもModelとは「模型」という意味であり、アーキテクチャの文脈で限定しないモデルは実現したいサービスをプログラミング言語化するために言葉や図を使って具体化したもののはずです。  
そこでInfraも手段として登場することはあっても、Infra自体がモデリングの対象にはならないと思います。  

しかしWebが登場し、さらにWebフレームワークでMVCアーキテクチャが普及したことでModelとWebAPI/データベースといったInfaは切っても切り離せない関係になりました。  
そして今ではWebAPI/データベースはアプリケーション開発で欠かせないほど重要な存在であり、そのような重要な役割を持つInfraをModelの補佐としてMVCの外側に補助役として置くのではなくModelそのものとして捉えてしまうのは致し方ないことだと思います。(少なくとも私はそうしてしまっていました。)  

しかしModelという言葉の意味とその定義から考えるにModelにInfraを含めてしまうことは誤りであるし、開発におけるModelの重要性を考えると問題の原因になってもおかしくないと思います。

## 補論3 GUIアーキテクチャとPDS
本記事の初めにGUIアーキテクチャとは「アプリケーションのUIとその他を分離すること」と記し、その脚注で「少し正確さに欠ける表現かもしれない」と補足しました。  
ここではそれについて書きたいと思います。  
私はGUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」ではなく、Presentation Domain Separation(PDS)と同様に「ビジネスロジック(ドメイン)とその他を分離すること」とした方が正確なのではと考えています。

このように考える理由をGUIアーキテクチャとPDSを参考にしながら説明します。  
まずMartin Flower氏の「GUI Architectures」と題された記事の中では以下の一節があります。  

>At the heart of MVC, and the idea that was the most influential to later frameworks, is what I call Separated Presentation.  
>The idea behind Separated Presentation is to make a clear division between domain objects that model our perception of the real world, and presentation objects that are the GUI elements we see on the screen.  
>Domain objects should be completely self contained and work without reference to the presentation, they should also be able to support multiple presentations, possibly simultaneously.  
>  
>意訳  
>MVCの核心、また後に登場するアーキテクチャにもっとも影響を与えた考えは私が「Separated Presentation」と呼んでいるものである。  
>この考えの目的は私たちの現実世界に対するメンタルモデルを表したドメインオブジェクトと私たちが画面上でみるGUIに関するモデルを分離する事にある。    
>ドメインオブジェクトは単独で動作可能であり、複数のGUIモデルにたいてい同時に対応することが可能である。  

ここで述べられていることは「MVCの核心」となっていますが、その後に「登場するアーキテクチャにもっとも影響を与えた考え」とも言っており、またこの記事のタイトルが「GUI Architectures」であることからも「GUI Architecturesの核心」でもあるはずです。
そしてその核心にある考えとはGUIに関するモデルとドメインオブジェクトを分離することであり、この定義をみても本記事内のGUIアーキテクチャの特徴を「アプリケーションのUIとその他を分離すること」と表現したのは誤りではないと思います。(記事のこの段階では「ドメイン」も「ビジネスロジック」も説明する前だったので、記事の構成上ドメインを「その他」と表現しました。)

ただここで私が思うのはこのGUIアーキテクチャの核心にある考えと言っているSeparated Presentationは、そのままPDSと言い換えられるのではということです。

PDSの原則も同じMartin Flower氏により提案されたもので、PDSのドキュメントにもそのように解釈できるような以下の一節があります。  
>This principle is the most prominent part of Model View Controller (MVC), indeed for many people MVC is how they describe this separation.
>  
>意訳  
>この原則はMVCにおいて最も重要なものであり、実際多くの人にとってMVCとはPDSを表現するための一つの形式である。  

「iOSアプリ設計パターン入門」という本でもGUIアーキテクチャの根底にあるのはPDSだと書いていますし、その認識はこの本に限らずプログラマの世界では一般的なものだと思います。  
そして本記事内でPDSのPresentationとはUIのみならずビジネスロジックに対する外部機構全てを指しているということはすでに述べました。  
再度引用することになりますが、PDSでは
>web services are also presentations  
>(中略)  
>don't intermix domain code with ... any other external API  
>  
>意訳  
>Webサービスもプレゼンテーションである  
>ドメインのコードと他のいかなる外部APIを混ぜないこと

とプレゼンテーションがUIのみならずWebサービスのことも指し、またそれらとドメインを混ぜないことを強調しています。  
こうした状況を踏まえるとGUIアーキテクチャはその名前からはUIを中心とした概念のように思いますが、実際にはPDS同様ドメインを中心とした概念のように感じます。    

なにはともあれGUIアーキテクチャが「UIとビジネスロジック(ドメイン)を分離すること」を目的としていることは間違いありません。  
ただその背景にある考えはその名前のイメージからは違っているかも知れません。



参考：  
  
書籍  
- [iOSアプリ設計パターン入門](https://peaks.cc/books/iOS_architecture)
- [ドメイン駆動設計](https://www.amazon.co.jp/エリック・エヴァンスのドメイン駆動設計-Architects’Archive-ソフトウェア開発の実践-エリック・エヴァンス/dp/4798121967/ref=asc_df_4798121967/?tag=jpgo-22&linkCode=df0&hvadid=295719984664&hvpos=&hvnetw=g&hvrand=3926308388276309968&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=1009283&hvtargid=pla-525481409888&psc=1&th=1&psc=1)  
  
Web  
- [MVCモデルについて](https://qiita.com/riku-shiru/items/2bed096e106e72e0b58a)
- [レイヤードアーキテクチャの視点](https://qiita.com/kichion/items/aca19765cb16e7e65946)
- [レイヤードアーキテクチャを振り返る](https://buildersbox.corp-sansan.com/entry/2019/04/21/000000_1)
- [MVCのモデルの誤解を解くためにフレームワークを例に挙げようとしたら誤解してもしゃーないなって思った](https://qiita.com/khsk/items/a8cd3adf1e22c9eb209e)
- [wiki(ビジネスロジック)](https://ja.wikipedia.org/wiki/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF)
- [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)([日本語訳](https://blog.tai2.net/the_clean_architecture.html))
- [Appleドキュメント(ViewController)](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)
- [GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)
- [Presentation Domain Separation](https://martinfowler.com/bliki/PresentationDomainSeparation.html)([日本語訳](https://bliki-ja.github.io/PresentationDomainSeparation/))
- [MODELS - VIEWS - CONTROLLERS](https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf)([日本語訳](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448))



<a name="footnote1">*1</a>: ここでいうコンポーネントとはアプリケーションの構成要素のことを指しており特に特別な意味はありません。MVPでいうところのModel/View/Presenter、FluxでいうところのView/Action/Dispatcher/Store等です。   
「構成要素」と書いても良いのですが、漢字だと画数が多く記事内での頻出単語でもあるため文章がガチャガチャした感じになるので「コンポーネント」と表現します。

<a name="footnote2">*2</a>: GUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」にあるとしましたが、GUIアーキテクチャと関連する概念であるPresentation Domain Separationと照らし合わせると自分の理解に少しはっきりしない点があるのでもしかしたら少し正確さに欠ける表現かもしれません。  
とはいえ大筋では合っているのは確かですし、記事の内容には影響はありません。  
よくわからない箇所についての詳細は補論[GUIアーキテクチャとPresentation Domain Separation](#補論3-GUIアーキテクチャとPDS)に記しました。  

<a name="footnote3">*3</a>: 関係性については補論[アプリケーション設計における関係性とは](#補論1-アプリケーション設計における関係性とは)でも取り上げています。

<a name="footnote4">*4</a>: Modelについては補論[Modelとはなにか？](#補論2-Modelとはなにか？)でも考察しています。

<a name="footnote5">*5</a>: 実際の開発ではDomain・Infraクラスは複数箇所から利用される場合が多いためこの図のようにケース毎に定義されることは少ないです。複数箇所からの再利用を図で示そうとすると矢印が複雑で見づらくなってしまい、またこの図が意図している内容とは関係ないため単純化して表しています。    

<a name="footnote6">*6</a>: この例ではネスト構造によるコードの複雑化を強調するため、明らかに誤った方法でコードを書いています。ただ実際の開発でここまでわかりやすい間違いはしなくともネスト構造によって複雑化した場合は知らず知らずのうちにどこかで誤った理解、コーディングをしているはずなのでこの例のようなケースが実際の開発で起こることもあながちあり得ないとは言い切れません。ちなみに私は全体が複雑にならなければ一度のネスト構造くらいはありだと思っています。
  
