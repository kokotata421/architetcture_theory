
# iOSアプリでスケールしやすいアーキテクチャを考える①-設計を理解するためのレイヤードアーキテクチャ-

この一連の記事ではiOSアプリにおけるスケールしやすいアーキテクチャを考えていきます。  
記事全体の構成(予定)は以下の通りです。   
(1)**設計を理解するためのレイヤードアーキテクチャ編←本記事**  
(2)設計を理解するためのクリーンアーキテクチャ編  
(3)アーキテクチャ概要編  
(4)ViewController編(準備中)  
(5)View/Alert/Data Source編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel(Controller/Presenter)編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への(準備の)準備編として設計を理解するためレイヤードアーキテクチャを説明しますので、  
「レイヤードアーキテクチャはもう知ってるよ」という人は次のクリーンアーキテクチャ編🚅、  
「レイヤードアーキテクチャもクリーンアーキテクチャもわかってる」という方はアーキテクチャ概要編から読むことをオススメします。✈️  

## 前提
- 本記事はアプリケーション開発における設計を前提としており、ライブラリ等の開発は想定されていません。    

## 用語の定義 
本文に入る前に、本記事内の中心にある「設計」と「アプリケーション」という2つの言葉の用法を定義します。    
### 「設計」/「アーキテクチャ」
本記事内では「設計」と「アーキテクチャ」という2つの言葉が頻出しますが、これらの言葉はそれぞれ異なる意味を持ちながらも日常的なコミュニーケーションではあまり差異を意識されずに使用されているように思います。  
  
なので不必要な混同を避けるため、本記事におけるそれぞれの定義を以下で明確にしておきます。  
設計・・・アプリケーションプログラムの構造を考える作業、またそこで採用されている思想。  
アーキテクチャ・・・アプリケーションプログラムの構造。MVC/MVVM/Flux/クリーンアーキテクチャ、またそれらと同列に語られるもの  
  
定義を明確するとはいっても、アーキテクチャには設計(思想)が含まれているため両者を厳密に区別することは難しいです。  
しかし原則として本記事では、アプリケーション構造を考える作業もしくはその際に用いる考え方を**設計**、その結果出来上がった具体的なプログラム構造を**アーキテクチャ**と記します。  

### 「アプリケーション」/「アプリケーションプログラム」/「アプリケーションサービス」/「アプリケーションプロダクト」
また本記事では「アプリケーションプログラム」という言葉が度々登場しますが、これは基本的には「アプリケーション」と同義です。  
ただ「アプリケーション」はユーザーからみたサービス/プロダクトを指す場合もあるため、開発者からみたプログラムであることを明示、強調したい際に「アプリケーションプログラム」と表記しています。    
同様に、アプリケーションの「サービス」また「プロダクト」の側面を強調したい場合には、それぞれ「アプリケーションサービス」、「アプリケーションプロダクト」と記しています。    
単なる「アプリケーション」もしくは「アプリ」という表記は、上記に該当せず明確な意図がない(もしくは意図を明確にする必要がない)場合に使われます。  

## 目的(本記事で書かれていること)
現在、モバイルアプリの開発ではMVCを始めMVP・Flux・クリーンアーキテクチャ、その他様々なアーキテクチャが採用されています。  
これらのアーキテクチャは開発においてとても有効で、作業をする上で大きな指針を開発者に示してくれますし、コミュニケーション時の共通言語としても役立ちます。  
ただ、こうしたアーキテクチャはアプリケーション構造の概観を提示してくれてはいますが、その詳細についてまでは言及していません。  
そのためアプリケーションの最終的な品質は個々の設計者・開発者に大きく左右されるようになり、本来問題解決のために利用されているはずのアーキテクチャの中で別の問題を引き起こしてしまう恐れがあります。  
巷でよくいうFatViewController、FatViewModelといった問題です。  
またそれぞれのアーキテクチャはいずれも特定の問題領域に注目して作られているため、そこには少なからず視点の偏りがあります。  
このような状況もあり、私はこれまで個々のアーキテクチャを学んでもアプリケーション設計について理解できている自信が持てませんでした。  
それぞれのアーキテクチャの形式やメリットは理解できても、それらが設計全体において何を意味しているのか俯瞰的に捉えることができなかったのです。        
こうした曖昧な理解は、先ほどのFatViewControllerのようにアーキテクチャの中でまた新しい問題を作ってしまう原因になりえます。  
なので今回、設計を俯瞰的に理解するために様々なアーキテクチャを参考にしながら、そこで得られたエッセンスだと思う要素とiOSアプリの開発環境を照らし合わせ、保守・変更しやすいと思えるアーキテクチャの原型を考えてみました。  
この一連の記事で書かれている内容は、その最終成果物であるアーキテクチャとそこに至るまでに得られた設計の知見をまとめたものです。  

## 設計を理解するためのクリーンアーキテクチャ
設計を俯瞰することを最初の目的として記事を進めていこうと思いますが、なんの手がかりもなしに理解するのは難しいです。  
なのでまず、クリーンアーキテクチャを通して設計を理解していきたいと思います。  
既存のアーキテクチャの中からクリーンアーキテクチャを選んだのは、クリーンアーキテクチャの以下の特徴が理由です。     
### 1. 具体的なコンポーネント[<sup>*1</sup>](#footnote1)に依存しておらず、設計思想を提唱している  
クリーンアーキテクチャにはMVPのPresenterやFluxのStoreのようにアプリーケーションに必ず含めなければいけないコンポーネントは存在しません。クリーンアーキテクチャは具体的なコンポーネントに頼ることなく、アプリケーションを責務や性質により複数のグループに分割し、それらがどのように連携するのかという考えを提示しています。  

### 2. アプリケーション全体を主要な関心の対象としている  
MVC・MVP・MVVM等のアーキテクチャは一般的にGUIアーキテクチャと言われ、主にアプリケーションのUIとその他を分離することに注目しています。[<sup>*2</sup>](#footnote2)    
それに対してクリーンアーキテクチャはシステムアーキテクチャと言われ、アプリケーションの特定領域にのみ集中することなく、アプリケーション全体を主要な関心対象としています。  

### 3. 1と2の特徴を持ったアーキテクチャを総括した立ち位置にある  
1と2の特徴を持っているのは他にもレイヤードアーキテクチャ・ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等がありますが、クリーンアーキテクチャはこれらを総括した立ち位置にあるアーキテクチャです。

### クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想
これらの特徴が設計において何を意味しているのかということは後ほど説明しますが、以上を要約すると「クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想」だということです。  
これは「設計を俯瞰して理解する」という私たちの目標と合致しています。  
そのためまず初めに、クリーンアーキテクチャを通してアプリケーション設計への理解を深め、私たちの設計に関する共通認識を築いていきたいと思います。  

### クリーンアーキテクチャへの障壁
しかし、クリーンアーキテクチャと言えばこの円図が有名ですが、これが非常にとっつきづらいです。　　
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>
 
<sup>引用元: [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)</sup>  

図が丸いのでどこからどう読んでいけばよいかわかりませんし、そもそもなぜ円なのかもよくわかりません。  
クリーンアーキテクチャを理解するためには、まず内容以前にその背景にあるコンテクストを理解する必要があります。  
なので本記事では、クリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャから学んでいきます。  

## クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ
レイヤードアーキテクチャはアプリケーションを責務によって複数のグループに分割します。  
これは先ほどクリーンアーキテクチャの特徴として紹介しましたが、レイヤードアーキテクチャも同様です。    
そしてレイヤードアーキテクチャは「責務による分割」に加えて、「分割されたグループ間の依存は一方向のみ」というルールも有しています。[<sup>*3</sup>](#footnote3)  
これら2つの特徴を視覚的に表現すると、アプリケーションがまるで複数のグループが積み重ねられた層で構成されているように捉えられるためレイヤードアーキテクチャ(layered architecture)なわけです、そのままですね。(下記[レイヤードアーキテクチャの概要](#レイヤードアーキテクチャの概要)の図を参照)  
レイヤードアーキテクチャの目的は、この責務による分割と単一方向の依存関係により、それぞれの層毎に開発の関心を分離することです。    
これによって開発者は開発時、常にアプリケーション全体に注意を向ける必要がなくなり、自分が担当している責務の層に集中できるようになります。  
何層に分けるかについてはいくつか考え方があるのですが、私はアプリケーション設計を理解するという目的においては4つの層に分けるのが良いと考えているので本記事ではそれを紹介します。  

## レイヤードアーキテクチャの概要
ここからは、もう少し具体的にレイヤードアーキテクチャの概要について説明していきます。  
最初に各層の説明からしていこうと思いますが、まずレイヤードアーキテクチャ全体の構造を示した図を以下に載せておきます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/あ.png" alt="レイヤードアーキテクチャの概要" width=60%>  


>補足  
>レイヤードアーキテクチャの各層を指すUI/Application/Domain/Infrastractureという言葉は記事の中で他の用法でも使用されます。  
>なので混同を避けるため、以後本記事においてはアーキテクチャにおける層を指す場合は英字で、より一般的な文脈で使われる場合はカタカナで表記することとします。  
>例:  
>Application(層) -> アーキテクチャにおけるアプリケーション層  
>アプリケーション -> アプリケーションプロダクト、アプリケーションプログラム  
> 
>またInfrastructureはInfraと省略して表記します。  

以上の図で示したレイヤードアーキテクチャの構造のうち、UI層とInfra層に関してはこれ以上特に付け加える説明はありません。          
UI層は「ViewもしくはViewに関わるロジックやデータ変換の処理」、Infra層は「デバイス/OS/ネットワーク/データベース等、アプリケーションを支える技術群」を指していることは、多少ITに対して感度を持っている人ならば、たとえプログラミング初学者でも比較的容易にイメージできるはずです。  
ただ、このように直感的に理解し易いUI層、Infra層に対して、Application層、Domain層は馴染みのない人にとっては判然としないと思います。        
Applicationはプログラム/プロダクトとしてのアプリケーションと混同しやすく、Domainも経営/ソフトウェア開発の文脈において独特の意味を帯びているためその原義である「領域」という意味からははっきりとイメージを掴みにくい概念です。  
なので、そうしたレイヤードアーキテクチャの各層の事情を鑑みて、ここではレイヤードアーキテクチャの層の内、Domain層とApplication層に焦点を絞って説明をしていきたいと思います。    

### Domain層とApplication層

#### Domain層
ここでのドメインとはアプリケーションが現実で従事する**業務領域**を指し、Domain層にはその業務に関する情報やルールを表現したデータやメソッドが含まれます。    
例えば銀行アプリのドメインは銀行業務全般であり、Domain層には取引の際のルール、顧客の口座等を表現するオブジェクトが定義・実装されます。  

#### Application層
こちら"アプリケーション"の「Application」層ということで聞き馴染みのない人は混乱すると思います。  
一般的にApplication層は「アプリケーション固有のデータ・ロジック」等と定義されていますが、もう少し平たくすると「ユーザーから見たアプリケーション機能、またビジネスロジックの内ドメインとは関係しないデータ・ロジックを定義・実装する場所」と言えます。  
ただ、これでも依然として具体性にかけると思うので、以下でその詳細について説明していきます。      
##### 「ユーザーから見たアプリケーション機能」としてのApplication層
まず、「ユーザーから見たアプリケーション機能」というのは、銀行アプリで言えば「お金の預入/引き出し/振り込み」等が当たります。  
「ユーザーから見たアプリケーションの機能」と形容が長い理由は、「アプリケーションの機能」だけでは先の「お金の預入/引き出し/振り込み」という各機能を抽象化して「口座のお金の操作」とまとめてしまう可能性があるからです。  
Application層の主な役割は、そのアプリケーションで何ができるのかを**具体的**に示すことです。  
そのため具体性を保つべくユーザー目線で機能を定義するのはとても重要であり、それによって開発者は機能単位で作業がしやすくなります。    

##### 「ビジネスロジックの内ドメインとは関係しないデータ・ロジック」としてのApplication層
次に後半の「ビジネスロジックの内ドメインとは関係しないデータ・ロジック」についてですが、これも再び銀行アプリを例に出して説明します。  
ある銀行アプリに「取引履歴をエクセル形式で出力する」という機能があると想定してください。      
その場合、この「取引履歴をエクセル形式で出力する」という機能は、先に述べた「ユーザーから見たアプリケーション機能」に当てはまるためApplication層に定義されますが、その処理の詳細は大きく「取引履歴データの取得」と「取得したデータのエクセルファイル形式への変換」に分けられます。  
そして、ここがこの例の肝で、それら分けられた処理をレイヤードアーキテクチャの層と照らし合わせると、「取引履歴データの取得」は銀行業務に含まれるためDomain層、「取得したデータのエクセルファイル形式への変換」はApplication層に分類されます。  
「取得したデータのエクセルファイル形式への変換」はそれ自体では「ユーザーから見たアプリケーションの機能」として成立していませんが、同時に銀行業務(Domain)にも該当せず、あくまでアプリケーションが独自で行っている処理となります。    
そのため、「取得したデータのエクセルファイル形式への変換」は、それだけではアプリ機能として成立していなくとも、アプリ固有の処理としてApplication層に分類されるのです。  
このようにApplication層には最初に挙げた「ユーザーから見たアプリケーション機能」以外にも、Domainには含まれないもののアプリケーションのために定義、実装したデータ・ロジックが含まれます。  
他にも身近な例でいえば、アプリのログイン情報を表現した独自定義のデータ型もこのApplication層に属します。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/取引履歴データをエクセル形式で出力する例.png" alt="取引履歴データをエクセル形式で出力する例" width=60%　>  

#### Domain層とApplication層の関係
基本的にはApplication層ではアプリの各機能(ユースケース)毎に定義され、そこからDomain層のデータ・ロジックを利用して処理を実行していきます。  
[先の説明](#Application層)で述べた「取得したデータのエクセルファイル形式への変換」のような機能も一部存在はしますが、通常、Application層はアプリの各機能を表現しており、そこでは具体的な処理は実装されません。  
Application層に具体的な処理が実装されないとは、例えば銀行アプリにおいて現金の引き出しは1サービス機能としてApplication層に定義されますが、実際に引き出しの際の手数料を計算して預金額から引き出し額と手数料を差し引く処理はDomain層に実装され、Application層側の実装はそれらDomain層の処理の呼び出しとなるということです。       
Application層は、あくまでアプリ機能毎にDomain層の処理を統制する司令塔の役割を担っています。  
Domain層はいわばアプリケーションサービスの原理・原則を定義・実装した非常に抽象的なプログラムの集合であり、そこにはアプリケーションプロダクトのコンテクスト(実際にDomainの原理・原則がどのように使用され、プロダクトサービス機能を提供するのか)が存在していません。  
Application層は、そうしたDomainの処理を機能単位でまとめあげることで、アプリケーションのコンテクストを提供しているのです。        
これにより開発者は、実際のアプリケーションプロダクトの仕様に沿って、プログラムの開発を行うことが可能になります。    
以下の図で示した銀行アプリの例を見ると、「取引ロジック」「手数料ロジック」等Domain層の定義をApplication層が機能単位でまとめることで、プログラムの構造が理解しやすくなっているのがわかると思います。        
このようにApplication-Domainは「Application層でアプリケーションサービスとしてのコンテクストを提供し、そこからサービスの内実を示すDomain層のデータ・ロジックを再利用してコードの重複を避ける」という協調関係を築くことで、効率的で開発しやすいプログラムを実現しています。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/Application層とDomain層(銀行アプリ).png" alt="銀行アプリを例にしたApplication層とDomain層の関係" width=70%>  

ここまで読んでわかる通り、Application層とDomain層は概念的に切り離すのが難しくレイヤードアーキテクチャの他の層の組み合わせと比べても密接な関係にあります。  
しかし、それでもレイヤードアーキテクチャの目的である関心の分離はApplication層とDomain層にも当てはまり、Domain層はApplication層からどう利用されているかは意識されるべきではありませんし、Application層にサービス本来の業務に関するデータ・ロジックを含めてはいけません。  

### ビジネスロジックとは
先の[Application層](#Application層)の定義の中で「ビジネスロジック」という言葉が登場しますが、これは「ビジネス」と「ロジック」という日常的によく使う単語を組み合わせたものでなんとなく使われることが多いように思います。  
なので、ここではビジネスロジックの定義について簡単に説明していきます。      
[Wikipedia](https://ja.wikipedia.org/wiki/ビジネスロジック)にはビジネスロジックに関して明確な定義はないとしながらも、「実世界のビジネスオブジェクトをモデル化したもの」を含めた「ビジネスルール(ビジネスに関する方針を表現したもの)」と「ワークフロー(ある関係者から他の関係者へと文書やデータを渡す仕事の順序)」から構成されると説明しています。  
これらの説明でもある程度のビジネスロジックを理解することはできるでしょう。    
ただ、ビジネスロジックをもっと平易に理解するために、私は「アプリケーションに関する仕様書をデザイン/ビジネス/技術の3つに分類した場合に**ビジネス**仕様書に含まれるもの」であると捉えるのが良いと思っています。    
アプリケーションに関する仕様のうち、ビジネスチームが関わるロジックとそこで利用されるデータ型を指しているため**ビジネスロジック**なわけです。  
そして、これをレイヤードアーキテクチャに当てはめると、ちょうどApplication層とDomain層を合わせたものをビジネスロジックと表現していることになります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/アプリケーションの仕様書とレイヤードアーキテクチャの関係.png" alt="アプリケーションの仕様書とレイヤードアーキテクチャの関係" width=60%>  

AppplicationとDomainの2つの層を一括りにして表現している「ビジネスロジック」という言葉が、多くの開発の現場において頻繁に使われていることからも、これら2層の密接な関係を窺うことができます。    
ちなみにレイヤードアーキテクチャには4層ではなく3層構造で捉える見方もあるのですが、その場合はこのApplicationとDomainがまとまって一つになっています。      
ネットで調べていると3層構造のApplicationとDomainをまとめた層を"Application"、"Domain"等と表現しているケースを見かけますが、そうすると4層構造におけるApplication、Domainと混同してしまうので、私はBusiness Logic(ビジネスロジック)と表すのが良いと思っています。  
私が今回作成したサンプルプロジェクトでもApplication、Domain層をまとめてBusiness Logicと命名しており、以後、本記事でもApplication層、Domain層を一括したい場合にはBusiness Logicと表現することとします。  
### レイヤードアーキテクチャの依存関係

#### 依存は一方向のみ
レイヤードアーキテクチャは層の分割に加えて、それらの依存関係も定義しています。  
冒頭の[レイヤードアーキテクチャ概要](#レイヤードアーキテクチャの概要)に記載した図でも示しましたが、それぞれの層を**UI-Application-Domain-Infra**という順番に並べた場合、依存方向は左から右への一方向のみとなります。      

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャの依存ルール.png" alt="レイヤードアーキテクチャの依存ルール" width=60%>  

#### 反対方向への呼び出しは?
依存方向は一方向のみというルールですが、逆方向へ依存したい時はどうしたら良いのでしょうか。  
ほとんどの場合は、返り値やクロージャのパラメーター(completion handler)を利用することで逆方向への依存関係を作らずに要件を満たしますが、どうしても必要である場合はプロトコルを利用します。  
ただ、その詳細についてはレイヤードアーキテクチャの話からは逸れてしまうので、とりあえず本記事では逆方向へのデータの流れは返り値、もしくはcompletion handlerによって実現され依存は一方向のみであると考えてください。  
プロトコルを利用した依存関係については次編で説明します。  

#### 層を跨いだApplication層からInfra層への依存
一つ注意しておきたいのは、依存は一方向でも、UIからApplicationへ、 ApplicaitonからDomainへ、DomainからInfraへ、というUI->Application->Domain->Infraの依存関係が固定化されているわけではなく、ApplicationからDomainを跨いでInfraへ依存する、Application->Infraという依存はありえるということです。   
これは実際のアプリの機能を考えてみればわかります。  
例えばアプリのログイン状態はApplication層のデータですが、通常ログイン状態は次回起動時も引き続き使用したいためInfra層の永続化機能で保存する必要があります。  
そのため、ログイン状態を操作するApplication層から永続化機能を担当するInfra層へ直接依存することになります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ApplicationからInfraへ依存.png" alt="ApplicationからInfraへ依存" width=60%　>  
このように、アプリケーションの機能上、Application層のデータをInfra層を通して操作することは少なからずあり、Application->Infraという依存関係は自然と発生します。   
しかし、この場合も依存が一方向であることには変わりありません。         

#### Application層からInfra層への依存以外で層を跨いだ依存はない
ここで「Application->Infrastractureという依存関係がありえるのならば論理的にUI->Domain/Infraというケースもありえるのでは？」と疑問に思う方がいるかもしれません。  
しかし、そのような依存関係は実際の開発ではありえません。  
なぜなら既に述べた通り、Application層は「ユーザーから見たアプリケーションの機能」を定義している場所であり、このApplication層においてユーザーの要求に応えるべく複数のDomain層の処理を連携させているからです。  
そのため、UI層がApplication層を飛び越えてDomain/Infra層にアクセスした場合、Domain/Infra層の処理の連携をUI層が担う必要があり、関心の分離が破られてUI層のコードが肥大化・複雑化してしまいます。    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/UIからDomainとInfraを利用.png" alt="UIからDomain/Infraを利用した場合" width=70%>

UI層から一つのDomainメソッドのみを呼び出したい場合等、ユースケースによってはApplication層への呼び出しが冗長でUI層からDomain層を直接呼び出したくなるかもしれません。      
ただ、そこでApplication層を省略してUI->Domainの依存を許容してしまうと、[先に説明した](#Domain層とApplication層の関係)Application層の開発者にアプリ機能のコンテクストを提供するという役割が疎かになり、結果としてコストカット分以上に開発コストが増えてしまう複雑な設計となります。  
先のApplication->Infraが設計にとって問題ではなかったのは、それが技術ではなくサービス的な観点によるものであり、技術的な詳細を把握していない開発者にとっても自然に理解できるものであったからです。  
今回のケースのように、アプリケーション全体の設計に詳細な技術的仕様を反映させてしまうと、最初にその設計、実装に関わった一部のプロジェクトメンバーを除いて理解しにくい排他的なものになってしまいます。  
こうした事情を踏まえると、4層の依存関係が変則的になるのは、先に説明したApplication->Infraのみになることが理解できるのではないでしょうか。  

レイヤードアーキテクチャの基本的な説明は以上です。  
以降では、クリーンアーキテクチャへ進む前にレイヤードアーキテクチャについて何点か考えることで設計への理解を深めたいと思います。  

## レイヤードアーキテクチャの層の分割は4つが適切か？
本記事冒頭の[レイヤードアーキテクチャの導入](#クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ)において、レイヤードアーキテクチャの層は4つで良いと書きましたが、本当にそれで良いんでしょうか。  
ここでは4つの層が適切であるという私なりの根拠を、アプリケーションの層を一つ一つ分割しながら説明していきたいと思います。  

### アプリケーションをBusiness&nbsp;LogicとBusiness&nbsp;Logic以外に分ける
まずアプリケーションを「Business Logic」と「Business Logic以外」というように分割します。  
アプリケーション設計には[Presentation Domain Separation(プレゼンテーションとドメインの分離)](https://bliki-ja.github.io/PresentationDomainSeparation/)(以下PDSと表記)という考え方がありますが、これはアプリケーションをBusiness Logicとその他に分けるというものです。    
なぜ最初にビジネスロジックが抜き出されるのかというと、それはBusiness Logicがアプリケーションプログラムの核心だからです。  
UI、Infraはアプリケーションサービスの実現を支えていますが、そのアプリケーションがどのようなサービスをどのようなルールで提供するかという本質部分の定義は全てBusiness Logicにされています。 
また、その性質の技術的な側面として、Business Logicはプログラミング言語による純粋なデータとロジックによってのみ実装され、外部技術に依存していません。    
そのため、Business Logicを他と切り離すことで再利用が可能になり、プログラムのテストも行いやすくなる技術的なメリットがあります。  

#### PDS(プレゼンテーションとドメインの分離)についての補足
PDSについては2点ほどわかりづらいところがあると思うので補足します。  
##### 1.ドメイン=Business Logic
最初にPDSのドメインをBusiness Logicと置き換えていることからもわかる通り、ここでのドメインは実質的にはApplication層とDomain層を含んでいます。  
実質的にはというのは概念においてPDSのドメインはレイヤードアーキテクチャのDomainと同じく「業務領域」を意味していますが、PDSはアーキテクチャではなく設計原則であって具体的な層やコンポーネントを想定していません。    
そして、PDSのドキュメントの主要な主張はアプリケーション機能に関するロジック・データと他の部分を切り離すことにあり、それをレイヤードアーキテクチャの文脈に照らし合わせると、PDSのドメインはApplication層も含めたBusiness Logic層と捉えた方が正しいと考えています。    

##### 2.プレゼンテーションとはUIを含めたドメインと連携する全ての機構を含む
次にプレゼンテーションという言葉は一見UIを想起させますが、ここにはInfraも含まれます。   
[PDSのドキュメント(和訳)](https://bliki-ja.github.io/PresentationDomainSeparation/)には最後に補足のような形で以下の文が書かれています。  

> 人間ではなく、コンピュータ相手の Web Services だって、プレゼンテーション部分です。  
> ですから、ドメイン部分のコードと Web Services 部分のコードをごちゃまぜにしてはいけないのです。  
> 外部APIにしてもそうです。  

この引用文から推察できるように、PDSのプレゼンテーションはUIのみを指しているわけではなく、ドメインと連携する外部機構に関する全てのプログラムを指しています。  
ここからも、PDSの中心がプレゼンテーションではなくドメインにあることがわかると思います。      
PDSにおけるプレゼンテーションは、「ドメインに対する外部機構」ということしか意味しておらず具体性を持っていないからです。  
[この節](#アプリケーションをBusinessLogicとBusinessLogic以外に分ける)冒頭において、PDSの定義を「ビジネスロジックとプレゼンテーション」ではなく「ビジネスロジックと**ビジネスロジック以外**」と表現したのもそのためです。  

### Business Logic以外をUIとInfraに分ける
これは説明不要でしょう。    
PDSではUIとInfraはドメインに対する外部機構として一つにまとめられていましたが、一般的にユーザーとの接点であるUIとアプリケーションを裏で支えるInfraを区別することに異論はないと思います。  
ただUIとInfraを区別することに違和感がなくても、WebAPIやデータベースを指す永続化機構とカメラやメール等の端末機能がInfraとして一つにまとまっていることに違和感を感じる人はいるかもしれません。  
確かに、永続化機構と端末機能はアプリケーション上の役割が異なり、場合によってはそれぞれをData/Deviceと区別します。  
しかしどちらもアプリケーションの機能を技術的に裏で支えているという役割は共通しており、設計上でもBusiness Logicとの関係性はともに「Business Logic->Data/Device」となっていてBusiness Logicから呼び出されるため立ち位置が同じです。  
そのため、設計を捉える上ではこれらは一つにまとまっていた方が理解しやすく、本記事でも必要であればData/Deviceと区別しますが、そうでなければInfraとして括ることにします。  

### ビジネスロジックをApplicationとDomainに分ける
最後にビジネスロジックをApplicationとDomainに分けます。  
この2層は[既に説明した](#Domain層とApplication層)通り、非常に密接に関わっていますが、やはり責務の質が異なっています。    
  
また、設計論においてもApplication層に焦点を当てたFlux/Redux、ドメイン層に注目した開発・設計論であるドメイン駆動開発が提唱された後に普及していて、こうした状況もApplication層とDomain層がそれぞれ設計において固有の問題を抱えていることを示しています。  
こうした事情を踏まえても、アプリケーション設計を理解するためには、Application層とDomain層をそれぞれ独立した層として捉えるのが良いと思います。    

### この4層によってアプリケーションの提供元である企業から提供先であるユーザーまでしっかり捉えている
さて、アプリケーションの層をその必要性を考えながら一つ一つ分けていったのですが、私がこの4層が最適だと思う理由は、これによりアプリケーションプログラムの端から端までをしっかりと表現できているからです。  
端から端までとは、アプリケーションの提供元となる「企業、もしくは事業」から提供先であるユーザーとの接点になる「UI」までを指しています。    
ドメインとは「業務領域」であると述べましたが、これは言い換えると「企業が提供している事業のビジネスルール」です。  
つまりDomain層とは、サービスを提供している主体(企業・事業)が決めたビジネスルールを定義しています。        
そして、そのビジネスルールをアプリケーションサービスとして定義したものがApplication層、それらビジネスルールとアプリケーションサービスを技術的に支えるのがInfra層、アプリケーションサービスとユーザーとの接点として定義されているのがUI層となります。  
このように、「事業/Domain」、「サービス/Application」、「技術的インフラ/(Infra)」、「ユーザー(との接点)/UI」と4層レイヤードアーキテクチャはアプリケーションプログラムの提供元から提供先までで登場する主要な要素を明確に捉えています。   

もし、これよりも層を少なくしてしまうとアプリケーション開発における異なるレイヤーの問題を混同してしまう恐れがありますし、逆にこれ以上層を分けると詳細に立ち入りすぎてその構造を必要以上に複雑にしてしまいます。        

## 設計とは関係を構築すること
4層レイヤードアーキテクチャの概要とそれがアプリケーションプログラムの設計として適している理由を説明してきました。  
ここでは、レイヤードアーキテクチャの以上の内容を踏まえて、設計とはなんであるのか考察したいと思います。      
「設計とはなんなのか」については様々な意見があると思いますが、私は**アプリケーション設計とはアプリケーションにおける開発しやすい関係を構築すること**だと考えています。    
レイヤードアーキテクチャではアプリケーションを責務によって分割し、それらをシンプルな関係によって構築することでプログラム構造をより明確で予測しやすいものにしました。  
 
このように、設計の際アプリケーションプログラムを意味としてまとまりを持った粒度に分解してそれらを再構築するという考え方は、何もレイヤードアーキテクチャに限った話ではありません。  
MVCはアプリケーションをModel-View-Controllerに分けてそれらの関係を定義しているアーキテクチャとですし、同様のことはMVP/MVVM/Flux/Redux等他のアーキテクチャにも当てはまります。      
また、よりミクロな設計に目を向けてみても、デザインパターンはアプリケーションにおける特定機能を実現するためのパターン(関係)を提示しており、SOLID原則はそうして構築された関係が開発を行う上で適切であるのか判断する基準だといえます。  

こうして見てみてみると設計に関する種種の概念やテクニックは、アプリケーション内の関係を構築するためのものだということがわかります。  
設計とはアプリケーションのマクロからミクロレベルに至る様々な次元において、適切な関係を考えていく作業なのです。  

>補足:  
>設計の定義を「関係の構築」とする場合、レイヤードアーキテクチャの特徴として挙げた「責務による分割」と「依存関係の単一方向」のうち前者が切り捨てられたような印象を受けます。  
>しかし、実際の設計作業を考えてみればわかりますが、アプリケーション内の関係を構築する際には必ずその関係の項を見出すためアプリケーションプログラムを分割して捉える必要があり、「関係の構築」という定義の中には「分割」いう意味も含まれています。  
>ただ、設計においては間違いなく「分割」よりも「関係」の方が重要です。  
>先にレイヤードアーキテクチャが4層であることが適切である理由を述べましたが、効率の良い開発を続けるためにはアプリケーションをただ「分割」するだけでは不十分であり、その状況において適切な関係を構築するように分割されている必要があります。  
>そのため、ここでは設計を「関係の構築」という定義で集約しています。   

>補足:  
>「関係性が重要である」と言われて、「何をそんな当たり前なことを」と思っている人はいるかもしれません。  
>これはその通りだと思います。  
>私たちは、意味という概念的な次元においても周りとの関係性を考えることなくある対象について考えることはできませんし、また物質的にもダイヤモンドと黒鉛が同じ炭素の配列の違いでしかないようにその定義は究極的には関係によって決定されます。  
>何かを論じる際、そこで関係が重要でないということなんてありえません。  
>しかし、それでもあえて私がここで関係を強調するのは、ネット記事にある設計論のほとんどが「MVC」「Redux」といったパッケージ化された粒度でしか語られていないからです。  
>また、SOLID原則等より粒度の小さい設計原理においても定式化された概念の重要性ばかりが強調され、それらがアプリケーション開発の実践においてどのように適用されるべきかはあまり論じられていないように思います。(例えばSOLID原則の一つであるSingle Responsibility(単一責任原則)の「単一」とは一体何を指すのでしょうか。私たちは現実社会における常識から、ある程度は「単一の責任」というものを判断することができると思います。ただプログラミングとは概念的な操作であるため、厳密に何を「単一の責任」とするのかは周囲との関係によって変化します。)  
>設計論におけるこうした事情を踏まえ、本記事では本来は大前提として省かれている「関係」に焦点を置いてアプリケーション設計を考えることを目的としています。  
  
### アプリケーションの複雑さは関係の複雑さによって決まる
このように設計において関係が重要なのは、それがアプリケーションの複雑さを決定しているからです。[<sup>*4</sup>](#footnote4)  
個々のコンポーネントにおいては、複雑さを決めている主な要因はその大きさです。  
物事の複雑さを決定している一義的な要因はその情報量であり、その意味で個々のコンポーネントがどのような基準で作られたものであったとしてもその大きささえ適切であれば理解するのは難しくないでしょう。      
しかし、コンポーネントの集合体であるアプリケーションの開発では、その複雑さが大きさに帰因する度合いはあまり大きくないと思います。

#### 関係がアプリケーションの複雑を決定する4つの要因
関係がアプリケーションの複雑さを決定している理由として、以下4つの連続している要因にあると思います。  
##### 1.アプリケーションの一般的な大きさ
一般的なアプリケーションは、個人で開発している等一部のものを除いてどれもそれなりの大きさを持っています。    
単純な情報量で言えばほとんどのアプリケーションが開発者にとって複雑だと感じるだけの大きさを持っているはずであり、それぞれの大きさの違いは相対的にどちらがより情報量が多いか(少ないか)を意味しているにすぎません。  
##### 2.アプリケーションは責務によって分割される
そのため、実際のアプリケーションでは責務に応じてコンポーネント単位に分割します。[<sup>*5</sup>](#footnote5)  
これによりアプリケーションプログラムの情報は整理され、理解しやすくなります。  
例えば、本は情報量(文章量)だけで言えばどれもそれなりの量を持っているはずですが、それらが部・編・章・節・項と特定のまとまりを持って構成されることでとなることで大変読みやすくなります。  
アプリケーションを責務によって分割するのもそれと同じです。  
大意で言えば、本の「部・編」といった大きな構成はアプリケーションの「層」、「章」はアプリケーションの「モジュール」、「節・項」といった小さな構成はデザインパターン等コンポーネントレベルの設計に当たると思います。[<sup>*6</sup>](#footnote6)  
  
##### 3.責務の分割の際にはコンポーネント間の関係が重要
責務に応じた分割によりアプリケーションはわかりやすくなりますが、アプリケーションを理解するためには個々のコンポーネントだけでなくそれらの関係も含めて理解する必要があります。    
個々のコンポーネントがどう関わりあっているのか、それを理解して初めてアプリーション全体がどのように動いているのか見えてくるからです。  
従って、アプリケーションのコンポーネントへの分割は相互の関係も踏まえて決定していく必要があります。  
こうした関係を踏まえたコンポーネントの分割には、サービス、技術、デザインに関する専門性を含んだ総合的な知識[<sup>*7</sup>](#footnote7)、そしてそれをチームでブラッシュアップしていく組織力が必要であり、開発者とプロジェクトチームの力の見せ所となります。

##### 4.シンプルな関係を徹底することで大きさの影響を受けづらくなる
関係を踏まえてコンポーネントを構築することにより個々の処理の内容が理解しやすくなりますが、開発を効率的に行うためにはさらにアプリケーション全体でも一貫した関係を構築する必要があります。   
全体においてアプリケーションの関係が一貫してるならば、プログラムの変更、機能追加の際にもこの一定のルールのもと開発を行うため、開発者はアプリケーションプログラムの大きさの影響を受けにくくなるからです。  
開発者は常にそのルールに沿いながら機能変更/追加をすれば良く、またその影響範囲さえ把握していればプログラム全体の詳細を理解する必要はなく、該当プログラムにのみ集中できるようになります。        
この特性は主要なアーキテクチャを見てみるとわかると思います。  
例えば、本記事で主題としているレイヤードアーキテクチャではそれがどのような大きさであれ各コンポーネントは「UI->Application->Domain->Infra」の関係の中に収斂されるため、開発者は各機能やそのコードの詳細に囚われることなくプログラムの流れを理解することが可能となります。  
また、最近普及しているFluxやReduxのスケールのしやすさも「アプリケーションのデータフローは一方向」という制約によって得られています。[<sup>*8</sup>](#footnote8)[<sup>*9</sup>](#footnote9)  

>補足:  
>そもそもアプリケーションの大きさはサービスに対する需要や利便性等プログラム以外の観点によって決定されるので、通常プログラム設計者が解決できるような問題ではありません。  
>その意味でも、各コンポーネント等大きさを配慮すべき箇所はありますが、設計者が設計の際一番注力すべきはアプリケーション内の関係をどう構築するかであると言えます。  

## アプリケーションの複雑さが関係の複雑さによって決まる例
以上で説明したように、アプリケーションプログラムが一定の関係で構築されているのならば、いくらスケールしてもプログラムは一定の型の内に収ます。  
そのため一定の関係が維持されたアプリケーションの元では、開発者が開発コストにおいてプログラムサイズから受ける影響は小さくなります。  
ただ、そのメカニズムを理論的に説明されても、実際に具体例を見ないことにはしっかりイメージができないと思います。  
そのため以下では関係性がアプリケーションの複雑さを決定していることを示すいくつかの例を紹介します。  

### Fat ViewController問題
#### MVCのModelにはApplication/Domain/Infra層が含まれる
レイヤードアーキテクチャはUI-Application-Domain-Infraという構成であるということを説明しましたが、これらをMVCアーキテクチャの文脈に当てはめるとUIを除くApplication/Domain/Infraは全てModelに分類されます。

>補足:  
>iOSMVCのControllerに当たるのはViewControllerですが、ViewControllerはUIKitに含まれていることからもわかる通りViewの操作を行う役割を担いUIの仕様を把握しているのでレイヤードアーキテクチャではUI層に該当します。  

>補足:  
>ここではInfraはMVCのModelに分類されています。  
>厳密にみるとInfraがModelに分類されるという考え方は疑問がありますが、    
>少なくともネットでMVCの概要を調べるとInfraをModelに含めてる記事は散見していますし、  
>何より各コンポーネントをMVC(Model-View-Controller)のどれかに分類するならば消去法でModelしかありません。  
>そのためここではInfraもModelの一部であると仮定して話を進めます。[<sup>*9</sup>](#footnote9)  

そうするとレイヤードアーキテクチャにおいて異なる階層に属していたApplication/Domain/Infra層のコンポーネントは全てModelという一つのカテゴリーの中で並列関係となり、iOSMVCでは以下のような構成が成立するように思えます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/単純に考えたMVC.png" alt="Modelを深く考えず設計した時に起こりうるMVCの構成" width=70%> 

#### FatViewControllerとは
このような構造は一見問題ないようにみえますが、実際の開発では大きな問題を生み出します。  
俗にいうFatViewController問題です。  
FatViewControllerとはViewControllerにビジネロジックが書かれる等、ViewControllerの責務が本来あるべき以上に大きくなってしまっている状態を指していますが、上の図のMVCも構造上そうなることを避けられません。  
その原因の所在は突き詰めていくとViewControllerとModel間の関係性の複雑さにあります。(このケースでは関係の複雑さではなく関係の曖昧さといった方が正確かもしれません。)  

ここではなぜ上記の構成だとFatViewControllerに陥ってしまうのか順に説明していきます。    
#### FatViewControllerの問題はViewControllerというクラス名ではない
FatViewControllerというとViewControllerの責務が「View」なのか「Controller」なのか名前からわかりづらい等、クラス名に関する指摘をよく見聞きしますが、[Appleドキュメント](https://developer.apple.com/documentation/uikit/view_controllers)には   
>You use view controllers to manage your UIKit app’s interface.    

とViewControllerの責務はUIをmanage(管理)であると書かれていて、ここからView(UI)をcontrol(管理)するViewControllerというクラス名は決しておかしな名前とは思えません。(ドキュメントでmanageという言葉を使いながらクラス名がView"Controller"なのはiOSプログラミングを既存のMVCに寄せて親しみやすいようにしたかったからでしょうか。)  
「管理」という言葉自体が明確さに欠けているとは言えるかもしれませんが、それが問題になるのは名前そのものに原因があるわけではなくViewControllerと周辺との関係がわかりづらいからです。[<sup>*11</sup>](#footnote11)    

#### ModelとViewの責務が明確ならば、ViewControllerの責務も明確だ
その理由を説明するために、ここでいきなりスイスの話をします。  
スイスはドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの5つの国に囲まれ、4つの言語を公用語としている非常に国際色豊かな国です。  
多くの国際機関がスイスにその本部を置いているのも、世界の文化的中心といえるヨーロッパの中で多くの国に陸続きで囲まれているこうした地理的な状況が関係しているのかもしれません。  
さて、突然ですが、この5つの国に囲まれるスイスの領土を知るためには一体どうしたら良いでしょうか？  
  
答えは簡単で、スイスからみてドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土がどこから始まっているか把握すれば良いのです。  
スイスから見て隣国の領土がどこから始まっているのか、それさえわかればスイスの領土も自然とわかるようになります。  
そしてこれは逆に言えばスイスを囲んでいるドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土を知っているならば、スイスの領土も明確になるということです。    
  
MVCにおけるViewControllerの責務だって同じです。  
iOSではViewControllerはModelとViewの間に立つコンポーネントであり、この隣接しているModelとViewの責務が明確であればViewControllerの責務も自然と明確になります。  
そのためViewControllerの責務がそのクラス名から推測可能であるにもかかわらず、依然として曖昧であるのはModelとViewの責務がはっきりとしていないからだと言えます。  
そしてここで一般的に問題となるのはViewController-Modelの境界です。  

#### ViewControllerにとってのModelの役割が曖昧
先に示した通りMVCではApplication/Domain/Infraと役割の異なるコンポーネントを全てModelとしているため、各Modelコンポーネントの責務、すなわちViewControllerにとってModelがどのような役割を担っているのかが非常に曖昧になっています。    

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/Model責務の曖昧化.png" alt="Modelの責務の曖昧化" width=60%> 

そしてこのようにViewController-Model間の責務の境界が不明瞭になった結果、本来Modelの責務であるデータの操作やロジックがViewController側に漏れてしまう現象がFatViewControllerです。    
このときModel側ではなくViewController側に責務が漏れてしまうのは、一般的にModelの責務が何でないのか、つまりModelにはUI操作が含まなれないこと、は認知されているものの、何であるのかが認知されていないからだと思います。    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/FatViewController.png" alt="FatViewController" width=70%> 
  
もちろんこれはiOSMVCの理想的な形ではありません。[AppleのViewControllerに関するドキュメント](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)にも  

>you should minimize the view controller’s role in managing the actual data.

とあり、ViewControllerのデータの操作は最小限にするべきと記されています。  
  
ただそうだとしてもApplication/Domain/InfraをModelとして捉えて、それをControllerから利用するというMVCのシンプルな構図だけではFatViewControllerは必ずと言って良いほど起こってしまう問題だと思います。  

MVCは概念としてはシンプルでわかりやすいのですが、実際の開発を考えるとApplication/Domain/InfraをModelという一言で済ましてしまうのは言葉足らずな感じがします。      

>補足  
>1  
>ここで述べたFatViewControllerの問題はレイヤードアーキテクチャの依存関係のところでも書いた[UIがApplication層を跨いでDomain/Infraを利用した場合の問題](#Application層からInfra層への依存以外で層を跨いだ依存はない)と外面的には同じです。  
>ただレイヤードアーキテクチャの場合ではModelの責務をしっかりとApplication/Domain/Infraに区別した上でその依存関係の誤りによって問題を起こしてしまったのに対し、MVCのFatViewControllerではそもそもApplication/Domain/Infraの区別ができていません。  
>そのためFatViewControllerの方が状況としてはより深刻であると思います。    
>  
>2  
>ここではFatViewControllerを取り上げたので問題の力点がViewController-Modelに置かれていますが、Modelの責務が曖昧になっているということはViewController-Model間だけでなくModel内部でも問題を引き起こしまう危険性があります。      
>Model内の各コンポーネント間で適切な関係性が構築されていない場合には各責務が小さすぎてコードが冗長になる、また逆に責務が大きすぎて作業しづらいFatModelが発生する等の問題が発生するでしょう。  


#### レイヤードアーキテクチャを取り入れたMVC
レイヤードアーキテクチャはクリーンアーキテクチャと同様に設計思想に近いため、他のアーキテクチャと併用することが可能です。  
そのため、ここでは先のMVCにレイヤードアーキテクチャを取り入れることで、Modelの設計の解像度を高くしてみます。    
MVCにレイヤードアーキテクチャを取り入れた場合の構造は、図にすると以下のような感じです。[<sup>*11</sup>](#footnote11)   

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャを取り入れたMVC.png" alt="レイヤードアーキテクチャを取り入れたMVC" width=70%>  

これを見ただけで、先ほどの単純なMVCよりもわかりやすくなったのがわかるのではないでしょうか？  
まずレイヤードアーキテクチャを採用することでModelが整理されてわかりやすくなりました。    
図の中では責務の性質によりコンポーネントの色を分けているのですが、それを踏まえて先程のMVCの図と比べると今回のModel内の構成が以前より理路整然としているのが見て取れると思います。  
そして、ViewControllerから利用するModelはレイヤードアーキテクチャでいうApplication層Modelのみになっているので、ViewController-Model間の関係もより明瞭になりました。            
Application層ModelがViewControllerへ渡すデータはユーザーの要求に直接対応しているはずなので、これによりViewControllerのデータ操作は必要最低限のものになり複雑なロジックを抱えることはなくなります。   
>補足  
>ここでいうViewControllerの必要最低限のデータ操作とは、Modelから渡されたログインしているかどうかというBool型を"ログイン中"というString型に変換する等です。  
>Model(Application)はViewの仕様を知っているべきではありません。  
>そのためModel(Application)からのデータがユーザーの要求に直接対応していたとしても例に出したようにコンピュータにとって都合の良いデータ形式を人間に都合の良いデータ形式に変換する作業はViewControllerで行う必要があります。　　

このようにMVCのModelをレイヤードアーキテクチャによって再考することによって、ViewController-Modelの関係がシンプルでわかりやすくなり、ViewControllerでModelデータ操作により責務が肥大化する恐れがなくなりました。    

#### MVCとMVC+レイヤードアーキテクチャの比較
単純なMVCとレイヤードアーキテクチャを採用したMVCを比較すると、レイヤードアーキテクチャを採用しているMVCの方が責務をより細かく分ける傾向にあるためコードやコンポーネントの量は多くなる可能性が高いです。    
しかしそれでもレイヤードアーキテクチャを採用している方が各コンポーネントの責務やそれらの関係性がはっきりするため、コーディングやチーム開発での作業がしやすくなると思います。     
そしてこうした責務・関係のわかりやすい設計が開発へ与えるポジティブな効果はプロジェクトの規模が大きくなればなるほど高くなっていくでしょう。          

### ネスト構造によるコンテクストの複雑化
関係がアプリケーションの複雑さを左右するケースについて、もう少しミクロなレベルの例を一つ紹介します。  
プログラミングをやっていると「ネスト構造を深くすることは避けろ」ということをよく耳にするのではないでしょうか。[<sup>*12</sup>](#footnote12)      
このようにネスト構造が否定的に捉えられている理由は分岐が入り組むことによりコードの流れを追うのが難しくなること、また一つ一つのブロックがコンテクストを提供しているのでそれらが入れ子になった結果全体のコンテクストが複雑になってしまうことにあると思います。  
そうした複雑なコンテクスト内では内側のブロックを読む際にその外側のブロックのコンテクストも把握していなければならず、開発者は常に目の前のコード以外の事にも注意を払う必要があるため、認知負荷がとても高くなってしまいます。  
そしてコンテクストが複雑になるということは関係が複雑になっているということです。

#### 手数料計算処理をネスト構造を用いて実装する
以下ではネスト構造による複雑さを示すために、ある銀行の取引手数料を計算するロジックを、特に工夫することなくif文のネスト構造を用いて実装したプログラムを記しています。[<sup>*13</sup>](#footnote13)   
```

//サービス提供方法
enum ServiceProvisionStyle { 
  case online
  case inperson
}
//取引タイプ
enum TransactionType {
  case withdraw
  case deposite
  case transfer
}

//手数料の計算ロジック
func calculateTransactionCommission(style: ServiceProvisionStyle, transaction: TransactionType, date: Date) -> Int {
    var fee: Int = 0
    let calendar: Calendar = Calendar(identifier: .gregorian)
    
    guard let hour: Int = calendar.dateComponents([.hour], from: date).hour else {
        //時間は必ず取得されなければならない
        fatalError("must be able to get "hour"")
    }
    
    if style == .inperson { //対面サービスの場合
        fee += 300
        if transaction == .withdraw {
            fee += 100
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        } else if transaction == .deposite {
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        } else { //振り込みの場合
            fee += 200
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        }
    } else { //オンラインの場合
        fee += 100
        if transaction == .withdraw {
            fee += 100
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        } else if transaction == .deposite {
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        } else { //振り込みの場合
            fee += 200
            if calendar.isDateInWeekend(date) { //週末の場合
                fee += 200
            } else { //平日の場合
                if 9 < hour && hour < 17 {
                    return fee
                } else {
                    return fee + 100
                }
            }
        }
    }
}

```
    
上記のコードの目的を理解するだけなら、「calculateTransactionCommission」というメソッド名から簡単に銀行の取引手数料の計算であることがわかると思います。      
しかし、挙動の不具合等で実装の詳細を理解しなければいけなくなった場合には、いくつものif文による分岐とそこで行っている処理を頭の中でまとめあげながら読み解いていく必要があり、ロジックとしては複雑ではないにも拘らず読み解くのが難しいプログラムになってしまっています。  

#### 手数料計算処理をネスト構造を避け、関係を整理して実装する
先のネスト構造を用いた取引手数料計算処理の実装を、関係を整理してリファクタリングしてみましょう。  
具体的には手数料計算処理「基本取引手数料(サービス提供形式と取引内容に関する手数料)」「時間外取引手数料()」に分け、それぞれをcalculateTransactionCommissionメソッドの内部メソッドとして定義・実装します。  


## アプリケーション内の関係を考えることで適切な設計を見つける
関係がアプリケーションの複雑さを決めているということを2つのケースを例に説明しましたが、それは言い換えれば関係こそが私たちが良い設計を考える上での手がかりになるということです。  
コードの設計について考えるときにとりうるアプローチは数多くあり、その中には互いに矛盾した方向性を持ったものもあります。  
あるケースではコードの重複を減らすために複数のコンポーネントに分けて考えていた責務をまとめて一つにした方が良いかもしれません。  
また別のケースでは反対に一つのコンポーネントの持つ責務の複雑性を回避するため、そこから特定の責務を取り出して別コンポーネントとした方がわかりやすくなるかもしれません。  
私たちは設計を考えていく上でこうしたさまざまな解決方法の中から適切なものを選んでいく必要がありますが、その際には該当のコンポーネントの背後・周辺にある関係を考えることが大きな助けとなります。  

## 関係を考えなかった結果失敗したViewModelの設計
ここでは私が関係を考えずに設計を行った結果失敗した経験を紹介することで、アプリケーション設計において関係を考えることがいかに開発の指針になるか示します。    
私はこのあとの記事で紹介するサンプルプロジェクトを作る際、ViewModelの設計を画面機能ごとにまとめようと考えました。  
画面機能毎にProtocolとその既定実装を書くことでコードを再利用できるように考えたのです。  
しかしその結果ViewModelはとんでもなく複雑で、開発しづらいものになりました。  
その理由は今から考えればとても馬鹿馬鹿しいと思うのですが、ViewModelが「ViewのModel」だからです。  
ViewModelの中心にあるのはあくまで「View」であって「Model(Viewの機能)」ではありません。  
ViewModelの設計の根幹に「View」ではなく「Model」を据えてしまったことにより以下のような問題が発生しました。
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ViewModelの設計(失敗例).png" alt="ViewModelの設計(失敗例)" width=70%>
- 理解しづらい・・・責務を理解するためにはいくつものProtocolを参照しながらそれらを頭の中でまとめあげ、さらにそこにViewModelクラス自身の責務を加える必要があったが、いくつもファイルを跨いでるうちに始めに読んだコードを忘れがちで仕様の把握が大変
- 変更しづらい・・・各責務はViewModelに書かれたコードとViewModelが適応するいくつものProtocolに散在することになり、責務の全体像が把握しづらくコード変更時にどのような影響が出るのかよくわからなくなってしまった
- 設計がいつ崩壊してもおかしくない・・・Protocolの既定実装では格納プロパティを持てないため、仕様の追加・変更によっていつ設計が崩壊してもおかしくない


今回のケースではどんなにコードの重複を減らせたとしても、View毎に責務をまとめる必要がありました。  
これはアプリケーションにおけるViewModelの立ち位置を考えず、コードの重複を減らすことだけに目がいってしまったがための失敗です。  

設計においては、殊更プログラミングの世界では、何が実現(運用)可能で何が机上の空論なのかという判断が非常に難しいです。

そのため設計を行う際はコンポーネントのアプリケーションにおける立ち位置や関連するコンポーネントとの関係を考えることがとても重要になります。  
そうすることで数あるアプローチの中からその開発により適切なものを選び出すことができるようになるからです。  

## この一連の記事で書かれていることも全て関係についてである

設計を考える際に関係を考えなくてはいけないということはいかなる設計論の背後には関係が提示されているということでもあります。    
設計論ではマクロからミクロに至るまでさまざまな技術やパターンそして概念が登場し、それら全てを別個に理解していてはそのあまりの情報量が多く目が眩んでしまいます。  
しかしそういう時、それらの全ての背後にある関係が肝であることを理解していればその詳細に圧倒されることなく、設計を理解する助けになるはずです。  
この一連の記事でもこのあとアプリケーションのさまざまな事柄についてさまざまな視点からスケールしやすい設計を考えていきますが、それらは全てアプリケーション開発にとって最適な関係を見つけていく作業であると言えます。      
>補足  
>コンポーネントが先にあってそれから関係を構築するのか、関係を構築するためにコンポーネントを作るのかというのはケースバイケースだと思うのですが、これまでのプログラミングの歴史におけるアーキテクチャの探究の中でアプリケーションにとって大事なコンポーネントはほとんど出揃っていると考えています。  
>また既存で普及しているコンポーネントから考えた方が私も作業しやすいし、読者の方も理解しやすいと思います。  
>そのため基本的にこの記事では既存のコンポーネントを利用しながら、それらの関係を考えていくというスタイルで話を進めます。  

## 準備の準備編(本記事)のまとめ
- クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想である
- レイヤードアーキテクチャはクリーンアーキテクチャの原型であり、その主な目的はアプリケーションをUI/Application/Domain/Infraという責務の集まりと捉えることによって開発時にそれぞれの責務の関心を分離することである。
- 設計とはアプリケーションにおいて開発しやすい関係を構築することである


## 補論1&#58;アプリケーション設計における関係とは
本記事内で設計においては関係を考えることが重要であると書きました。  
ここではもう少し具体的にアプリケーション設計における関係とはなんであるかを考えていきたいと思います。  
### 関係はどこで発生する？
まずアプリケーション開発(主にコーディング)において関係はどこで生まれるのでしょうか。  
私は大きくいって関係が発生する箇所は3つあると思います。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/アプリケーションにおいて関係が発生する場所.png" alt="アプリケーションにおける関係性" width=70%>  
1. コンポーネント内部・・・コンポーネント内部の変数・メソッド間の関係。さらに処理内部の中のローカルと計算の連携。    
2. コンポーネント間・・・コンポーネント同士の繋がり。  
3. アプリ全体とコンポーネント、また開発者とコンポーネントの間・・・アプリケーション、開発者に対してのコンポーネントの役割。  
  
1と2はそのままなので、3についてだけ説明します。  
「アプリケーションに対してのコンポーネントの役割」とは本記事内[ViewModelでの設計失敗談](#関係を考えなかった結果失敗したViewModelの設計)で見たように、アプリケーション全体においてコンポーネントが担う役割のことですが、これに加えて開発者に対しての役割を考えることも含まれています。        
例えばViewControllerはプログラミング的には画面機能を統括する責務を持っていますが、同時に開発時の作業の基点としての役割も担っています。     
実際のプロダクトであるiOSアプリの画面に対応するViewControllerの存在のおかげで、開発者はアプリケーションプロダクトとアプリケーションコードとの間に親和性を感じることができます。          
ほとんどのiOSアプリ開発者にとってViewControllerはそのアプリケーションコードを理解するための足掛かりとなっているのではないでしょうか。  
  
設計とは関係を構築することだと言いましたが、その目的は
- (開発者にとって)コードが読みやすい　　
- (開発者にとって)コードを書きやすい　　
- (開発チーム・開発者にとって)作業に取り掛かりやすい　　

等、開発者の作業をしやすくすることです。    
そのため設計をする際には各コンポーネントが開発者に対してどのような役割を担っているか考えることも重要になります。 

### 関係によりアプリケーションが複雑化する原因
次に関係によってどのようにアプリケーションが複雑になるか考えていきます。    
私は関係によってアプリケーションが複雑になるとは具体的に以下2つの現象を指していると思います。  
1. データフローの複雑化
2. コンテクストの複雑化

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/関係によるアプリケーションの複雑化.png" alt="関係性によるアプリケーションの複雑化" width=70%>
    
それぞれの詳細はここでは省略しますが、1と2互いに排他的ではなく関係が複雑になることにより同時に起こる現象です。  
まだしっかりと検討できていないのですが、コンテクストの複雑化は依存関係の複雑化といっても良いかもしれません。[<sup>*14</sup>](#footnote14)    
コンテクストの複雑化は記事内では[ネスト構造](#ネスト構造によるコンテクストの複雑化)と関連させて紹介しましたがネスト構造に限った話ではなく、コンポーネント内、またコンポーネント間など関係が発生するあらゆるところで発生します。  
図の2でも、都合上省略しましたが繋がりを示すコンテクストはコンテクストEだけではなく、コンテクストA->コンテクストB等他の箇所でも発生しています。  
  
簡単にアプリケーション設計における関係を説明してみました。  
本来これだけで記事が書けるくらい大きなテーマだと思うので、もう少し煮詰めることができたら別記事で取り上げたいと思います。　　    

## 補論2&#58;Modelとはなにか
記事内の[Fat ViewControllerに関する箇所](#MVCのModelにはApplication/Domain/Infra層が含まれる)でMVCのModelにはInfraも含まれると仮定しながらも、厳密にModelにInfraを含めることには違和感があると記しました。  
ここではそれらの問題を踏まえながらModelについて考えたいと思います。  
### MVCにおけるModel
最初にMVCの提案者である[Trygve Reenskaug氏のModelの定義](https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf)を見ていきます。    

>Models represent knowledge.   
>(中略)  
>There should be a one-to-one correspondence between the model and its parts on the one hand, and the represented world as perceived by the owner of the model on the other hand.   
>The nodes of a model should therefore represent an identifiable part of the problem.  
>  
>意訳:  
>モデルは知識を表している。  
>(中略)  
>モデルとそのパーツはその設計者のメンタルモデルと対応していなければならず、そのためモデルの各要素はその問題の特定箇所を示している。    


後半はだいぶ意訳です。
定義内の
>the represented world as perceived by the owner  

をどう解釈するのかが定義の鍵となるのですが、私はメンタルモデルと訳すのが一番良いと思います。  
モデルの話にメンタルモデルと似た用語が出てきてわかりづらいのですが、メンタルモデルは「ある対象に対しての人が抱くイメージ」を指しています。    
上の箇所を[日本語訳している記事](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448)を読んでみると
>その所有者によって知覚された世界の表象  

と少し難解な説明となっているのですが、      
要は「感覚的な認識に基づいて示される世界観」という意味で、それを簡潔に表すとメンタルモデルになると思います。  

### 改めて、Modelとは
さて話をModelの定義に戻すと、上の定義に沿ってModelを「メンタルモデルがプログラム化されたもの」と捉えた場合、そこにInfraは含まれないと思います。  
Infraは文字通り「基盤/下部構造」という意味であり、私たちの普段の活動の中でインフラに対して何かイメージを抱くほど強く意識することは滅多にありません。(ただインフラ開発・運営を生業としている場合は例外です。)   
もちろんハンドルを捻れば水道蛇口が水が出てくる等、私たちがインフラを利用できるのはそれらに対するイメージをしっかり持っているからと言えるわけですが、こうしたインフラに対する意識はあまりにも当たり前のものとして私たちの中に内在しており、実際に日常の活動を行っている際にはほとんど意識されていないでしょう。       
例えば料理の写真を見て実際に自分で作ってみようとした時に、食材やその調理方法についていろいろとイメージしながら作りますが、その際水道やガスシステムに対してまであれこれ思いを巡らす人はいないと思います。  
このようにインフラは日常の活動を下支えする存在であり、それはアプリケーションにおいても同じです。    
アプリケーションは現実の活動における何らかの問題に対して解決策を提供するサービスあり、その解決のために使われるモノ(データ)や振る舞いはメンタルモデルの対象となりますが、それらの技術的基盤にあたるInfraについてはメンタルモデルの対象外であると思います。    
また先ほどのMVCのModelの定義は[GUIアーキテクチャ](https://martinfowler.com/eaaDev/uiArchs.html)におけるDomainオブジェクトの定義と同じといっても差し支えなく、   
>domain objects that model our perception of the real world  
>
>意訳  
>現実世界に対する認識を型どったドメインオブジェクト  

こうした定義をみてもModelに該当するのはDomain/Applicationオブジェクトであると考えられます。[<sup>*15</sup>](#footnote15)    

### InfraがModelとして扱われがちな理由
しかしそれにも拘らずInfraがModelとして扱われがちな原因には既に本記事内で述べた通りMVCの構成があります。    
MVCアーキテクチャではアプリケーションはModel-View-Controllerで構成されており、そうなると消去法によってInfraもModelに分類されるしかありません。    

ただこれには1点留意点があり、補論冒頭で紹介したMVCの論文が発表されたのはWeb誕生以前の1979年です。    
そのため当時のアプリケーションにおけるInfraの存在は現在のように大きくなく、当初のMVCアーキテクチャの想定にはInfraは含まれていなかったのではないかと思われます。  
そう考えると、InfraがModelとして扱われがちな原因はMVCアーキテクチャの構成そのものというよりも、Webの普及によってアプリケーション環境が大きく変わったにも拘らず、未だにWeb以前から存在するMVCアーキテクチャを採用している状況にあると言えるかもしれません。    

### Infraも独立して捉えたアーキテクチャの必要性
とにかく、現代的なアプリケーションの性質を考えるとMVCの構成は初学者のInfraを踏まえたアプリケーション設計の理解を妨げており、ModelとInfraを混同させないようなアーキテクチャがあっても良いのではないかと思います。  
単純ですが、例えばMVCI(Model-View-Controler-Infra)アーキテクチャがあれば一つ構成要素が増えることになりますが、ModelとInfraのはっきりと分かれているのでプログラミングを始めたばかりの人でもModelが何であるのか、またInfraとModelがどのような関係であるのか混乱することなく理解できるのではないでしょうか。  


## 参考文献
  
書籍  
- [iOSアプリ設計パターン入門](https://peaks.cc/books/iOS_architecture)
- [ドメイン駆動設計](https://www.amazon.co.jp/エリック・エヴァンスのドメイン駆動設計-Architects’Archive-ソフトウェア開発の実践-エリック・エヴァンス/dp/4798121967/ref=asc_df_4798121967/?tag=jpgo-22&linkCode=df0&hvadid=295719984664&hvpos=&hvnetw=g&hvrand=3926308388276309968&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=1009283&hvtargid=pla-525481409888&psc=1&th=1&psc=1)  
  
Web  
- [MVCモデルについて](https://qiita.com/riku-shiru/items/2bed096e106e72e0b58a)
- [レイヤードアーキテクチャの視点](https://qiita.com/kichion/items/aca19765cb16e7e65946)
- [レイヤードアーキテクチャを振り返る](https://buildersbox.corp-sansan.com/entry/2019/04/21/000000_1)
- [MVCのモデルの誤解を解くためにフレームワークを例に挙げようとしたら誤解してもしゃーないなって思った](https://qiita.com/khsk/items/a8cd3adf1e22c9eb209e)
- [wiki(ビジネスロジック)](https://ja.wikipedia.org/wiki/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF)
- [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)([日本語訳](https://blog.tai2.net/the_clean_architecture.html))
- [Appleドキュメント(ViewController)](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)
- [GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)
- [Presentation Domain Separation](https://martinfowler.com/bliki/PresentationDomainSeparation.html)([日本語訳](https://bliki-ja.github.io/PresentationDomainSeparation/))
- [MODELS - VIEWS - CONTROLLERS](https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf)([日本語訳](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448))


## 注釈 
<a name="footnote1">*1</a>: ここでいうコンポーネントとは、アーキテクチャにおいてClass/Struct/Enumで定義されるような具体的な構成要素を指しています。MVCでいうところのModel/View/Controller、FluxでいうところのView/Action/Dispatcher/Store等です。「構成要素」と記すと他の集合体の要素と混同してしまう恐れがあるため、コンポーネントと表記しています。  
  
<a name="footnote2">*2</a>: GUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」にあると述べましたが、少し正確さに欠ける表現かもしれません。なぜならGUIアーキテクチャの根底には本記事でも紹介している[Presentation Domain Separation](#アプリケーションをビジネスロジックとビジネスロジック以外に分ける)があり、そのPDSの中心には「アプリケーションのUIとその他を分離すること」ではなく、「ドメイン(ビジネスロジック)とその他を分離すること」という考えがあるからです。とはいえ大意で合っているのは確かですし、本記事の内容には影響はありません。    
そしてレイヤードアーキテクチャは「責務による分割」に加えて、「分割されたグループ間の依存は一方向のみ」というルールも有しています。  
  
<a name="footnote3">*3</a>: [設計を理解するためのクリーンアーキテクチャ](#設計を理解するためのクリーンアーキテクチャ)では概念的な特徴に留めて説明がなされているため省略されていますが、実際にはクリーンアーキテクチャも「一方向のみの依存」の特徴を有しています。クリーンアーキテクチャの特徴の詳細は次編「設計を理解するためのレイヤードアーキテクチャ」で説明します。  

<a name="footnote4">*4</a>: ここでいう「アプリケーションの複雑さ」とは別の言葉でいうと「アプリケーション開発のしやすさ」です。    
  
<a name="footnote5">*5</a>: 正確にはレイヤー、モジュールとより大きな単位でも分割は起こっていますが、論旨とは関係ないためここではコンポーネントのみ取り上げています

<a name="footnote6">*6</a>: 本は部・編・章・節・項と分割していくことで読みやすくはなるけど、結局その複雑さは文章量によるのでは?」という疑問もあるかもしれませんが、ここで指しているのはあくまで「情報は整理したらわかりやすくなる」という一般的性質であり、その一例として本を挙げています。  

<a name="footnote7">*7</a>: アプリ全体から見ればサービス、技術、デザインに関する総合的的知識が必要なのは間違いありません。ただ実際のプログラムでは責務による分割が正しく行われていれば、サービスとデザインの専門知識が求められるコードは互いに切り離されているはずなので、それらの知識が同時に必要になることはありません。    

<a name="footnote8">*8</a>: プログラムを理解するためにはその処理の流れを追っていく必要があり、その意味で依存関係が一方向である制約を持つレイヤードアーキテクチャよりもデータフローが一方向であるFlux/Reduxの方がより具体的な関係の制約を定めていると言えます。

<a name="footnote9">*9</a>: 関係については補論[アプリケーション設計における関係性とは](#補論1アプリケーション設計における関係とは)でも取り上げています。

<a name="footnote9">*9</a>: Modelについては補論[Modelとはなにか](#補論2Modelとはなにか)でも考察しています。

<a name="footnote9">*9</a>:  一般的に管理者を意味する「Manager」は抽象的でコンポーネント名の一部として使用するのは避けるべきだと言われており、それは「Controller」でも同様だと思いますが、私は事ViewControllerに関しては致し方ないと思います。[Appleのドキュメント](https://developer.apple.com/documentation/uikit/uiviewcontroller)にはViewControllerの責務として「Viewの更新」「インタラクションへの対応」「レイアウトの変更」「他のオブジェクトとの連携」等が挙げられていることからもわかるとおり、ViewControllerはアプリケーションプログラムの基点でありここで様々な処理を担当せざるを得ない実情があります。そのため、これらを様々な責務を表現する表現として「manage/control(管理)」といった単語を使用することは問題ではないと考えています。  

<a name="footnote11">*11</a>:  
実際の開発ではDomain・Infraクラスは複数箇所から利用される場合が多いためこの図のようにケース毎に定義されることはないと思います。


<a name="footnote12">*12</a>:
ちなみに私はコンテクストが複雑にならない限りにおいて、ネスト構造をするのはありだと思います。  

<a name="footnote13">*13</a>: 実際には規定時間外で銀行の対面サービスは行われていない点等を含め、この例のサービス仕様は現実的ではありません。ここでの目的はコンテクスト(関係)が複雑になることでプログラムが開発しづらくなることを示すことであり、サービス仕様は仮想的で単純化されています。その意味でこの例は、サービス仕様がとても単純なものであっても関係に配慮しなければプログラムが煩雑になることを示しています。  

<a name="footnote13">*13</a>: この例ではネスト構造による複雑化を強調するため明らかにわかりづらいコードを意図的に書いており、このような煩雑なコードは現実的とは思えないかもしれません。しかしネスト構造によって複雑化してしまう場合の多くは、開発者が無意識のうちにどこかで誤った理解をしているはずであり、いささか誇張気味ではありますがこの例のようなケースが実際の開発で起こることもあながちあり得ないとは言い切れません。  

<a name="footnote14">*14</a>:
「コンテクスト」の複雑化は「依存関係」の複雑化と言いましたが、「コンテクスト」と「データフロー」の差はなんであるか等ここら辺の関係は現状では明確に区別できていません。とりあえずここでは「依存関係」はアプリケーション内の意味(コンテクスト)の一部とみなしてコンテクスト(データフロー)として、「データフロー」は「依存関係」よりも直接的に設計に影響するため独立して扱っています。  

<a name="footnote15">*15</a>:
[PDSのドメイン](#アプリケーションをビジネスロジックとビジネスロジック以外に分ける)と同様、GUIアーキテクチャのドメインにもレイヤードアーキテクチャのDomain層とApplication層が含まれていると思います。        
 
