
# iOSアプリでスケールしやすい設計を考えてみた①-設計を理解するためのレイヤードアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。   
(1)**設計を理解するためのレイヤードアーキテクチャ編←本記事**  
(2)設計を理解するためのクリーンアーキテクチャ編  
(3)アーキテクチャ概要編  
(4)ViewController編(準備中)  
(5)View/Alert/Data Source編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel(Controller/Presenter)編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への(準備の)準備編として設計の概観を理解するためレイヤードアーキテクチャを説明しますので、  
「レイヤードアーキテクチャはもう知ってるよ」という人は次のクリーンアーキテクチャ編へ🚅、  
「レイヤードアーキテクチャもクリーンアーキテクチャもわかってるし」という方は概要編から読んでもらった方が良いと思います。✈️  

## 前提
- 本記事の設計に関する内容はアプリケーション開発を前提としており、ライブラリ等の開発は想定されていません。    
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容は基本的にどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

## 始めに  
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるもの  
明確にするとは言っても「アーキテクチャ」は「設計」なので、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっている場合が多いと思うのでこの記事では上のように区別することとします。  


## 目的(記事で書かれていること)
現在、モバイルアプリの開発ではMVCを始めMVP・Flux・クリーンアーキテクチャ、その他様々なアーキテクチャが採用されています。  
これらのアーキテクチャは開発の際にとても有効で、作業をする上で大きな指針を開発者に示してくれますし、コミュニケーション時の共通言語としても役立ちます。  
ただ、こうしたアーキテクチャはアプリケーション構造の概観を提示してくれてはいますが、その詳細についてまでは言及していません。  
そのためアプリケーションの最終的な品質は個々の設計者・開発者に大きく左右されるようになり、本来問題解決のために利用されているはずのアーキテクチャの中で別の問題を引き起こしてしまう恐れがあります。  
巷でよくいうFatViewController、FatViewModelといった問題ですね。  
またそれぞれのアーキテクチャはいずれも特定の問題領域に注目して作られているためそこには少なからず視点の偏りがあります。  
このような状況もあり、私は個々のアーキテクチャを学んでもアプリケーション設計について理解できている感じがしませんでした。  
それぞれのアーキテクチャの形式やメリットは理解できても、それらが設計全体において何を意味しているのかイマイチ良くわからなかったのです。    
こうした曖昧な理解は、先ほどのFatViewControllerのようにアーキテクチャの中でまた新しい問題を作ってしまう原因になりえます。  
なので今回、設計を俯瞰的に理解するために様々なアーキテクチャを参考にしながらそこで得られたエッセンスだと思う要素とiOSアプリの構成を照らし合わせ、私的に保守・変更しやすいと思えるアプリケーション開発における雛形を考えてみました。  
本記事を含めた一連の記事で書かれている内容はその最終成果物である設計とそこに至るまでに得られた知見をまとめたものです。  


## 設計を理解するためのクリーンアーキテクチャ

設計を俯瞰することを最初の目的として記事を進めていこうと思いますが、なんの手がかりもなしに理解するのは難しいです。  
なのでまずクリーンアーキテクチャを通して設計を理解していきたいと思います。  
既存のアーキテクチャの中からクリーンアーキテクチャを選んだのは、クリーンアーキテクチャの以下の特徴が理由です。     
1. 具体的なコンポーネント<sup>[*1](#footnote1)</sup>に依存しておらず、設計思想を提唱している  
2. アプリケーション全体を主要な関心の対象としている  
3. 1と2の特徴を持ったアーキテクチャを総括した立ち位置にある  

それぞれを簡単に説明すると、  
1: クリーンアーキテクチャにはMVPのPresenterやFluxのStoreのようにアプリーケーションに必ず含めなければいけないコンポーネントは存在しません。  
クリーンアーキテクチャはそのような具体的なコンポーネントには依存せず、アプリケーションを責務や性質により複数のグループに分割し、それらがどのように連携するのかという考えを提示しています。  
2: MVC・MVP・MVVM等のアーキテクチャは一般的にGUIアーキテクチャ<sup>[*2](#footnote2)</sup>と言われ、主にアプリケーションのUIとその他を分離することに注目していますが、クリーンアーキテクチャはアプリケーションの特定領域には注力しておらずアプリケーションシステム全体を主要な関心対象としています。  
3: 1と2の特徴を持っているのは他にもレイヤードアーキテクチャ・ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等がありますが、クリーンアーキテクチャはこれらのアーキテクチャを総括した立ち位置にあるアーキテクチャです。  

これらの特徴が設計を考える上で何を意味しているのかということは後ほど説明しますが、以上をまとめると「クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想」であるということです。  
これは「設計を俯瞰して理解する」という私たちの目標と完全に合致しています。  
そのためまず最初にクリーンアーキテクチャを通してアプリケーション設計への理解を深め、私たちの設計に関する共通認識を作っていきたいと思います。  

## クリーンアーキテクチャへの障壁
ただクリーンアーキテクチャと言えばこの円図が有名ですが、これが非常にとっつきづらいです。　　
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%>
 
<sup>引用元: [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)</sup>  

図が丸いのでどこからどう読んでいけばよいかわかりませんし、そもそもなぜ円なのかもよくわかりません。  
クリーンアーキテクチャを理解するためにはまず内容以前にその背景にあるコンテクストを理解する必要があります。  
そのため本記事ではクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャについて学んでいきます。  
  
## クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ
レイヤードアーキテクチャはアプリケーションを責務によって複数のグループに分割します。  
これは先ほどクリーンアーキテクチャの特徴として紹介しましたが、レイヤードアーキテクチャも同様です。  
そして、レイヤードアーキテクチャにはそれに加えて「分割されたグループ間の依存は一方向にのみ」というルールがあります。      
これら2つの特徴を図で表すとアプリケーションがまるで複数のグループが積み重ねられた層によって構成されているように見えるためレイヤードアーキテクチャ(layered architecture)なわけです、そのままですね。  
レイヤードアーキテクチャの目的はこの責務による分割と単一方向の依存関係により、それぞれの層毎に開発の関心を分離することです。    
これによって開発者は開発時、常にアプリケーション全体に注意を向ける必要がなくなり、自分が担当している責務の層に集中できるようになります。  
何層に分けるかについてはいくつか考え方があるのですが、私はアプリケーション設計を理解するという目的においては4つの層に分けるのが良いと考えているので本記事ではそれを紹介します。  

## レイヤードアーキテクチャの概要
レイヤードアーキテクチャの構成は以下の通りです

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャの概要.png" alt="レイヤードアーキテクチャの概要" width=60%　>


>補足  
>レイヤードアーキテクチャの層を指すUI/Application/Domain/Infrastractureという言葉は記事の中で他の用法でも利用されます。  
>なので混同を避けるため、以後アーキテクチャにおける層を指す場合は英字で、より一般的な文脈で使われる場合はカタカナで表記することとします。  
>例:  
>Application(層) -> アーキテクチャにおけるアプリケーション層  
>アプリケーション -> プロダクト、アプリケーションプログラム等 
> 
>またInfrastructureはInfraと省略して表記します。  


### Domain層とApplication層
各層の内容はだいたい上の図に書かれている通りですが、Domain層とApplication層は少しわかりづらく、また両者の区別もしづらいと思うので説明します。


#### Domain層
ここでのドメインとはアプリケーションが現実で従事する**業務領域**を指し、Domain層にはその業務に関する知識やルールを表現したデータやメソッドが含まれます。    
例えば銀行アプリのドメインは銀行業務全般であり、Domain層には取引の際のルール、顧客の口座等を表現するプログラムが定義・実装されます。  

#### Application層
こちらアプリケーションのApplication層ということで聞き馴染みのない人は混乱しやすいと思います。  
一般的にApplication層は「アプリケーション固有のデータ・ロジック」等と定義されていますが、もう少し平たくすると「ユーザーから見たアプリケーションの機能、またビジネスロジックの内ドメインとは関係しないデータ・ロジックを定義・実装する場所」だと言えます。  
ただこれでも依然として具体性にかけると思うので補足していきます。    

まず「ユーザーから見たアプリケーションの機能」というのは銀行アプリで言えば「お金の預入/引き出し/振り込み」等が当たります。  
「ユーザーから見たアプリケーションの機能」と定義が長い理由は、「アプリケーションの機能」だけでは先ほどの「お金の預入/引き出し/振り込み」というような機能を抽象化して「口座のお金の操作」とまとめてしまう可能性があると思ったからです。  
Application層の主な役割はそのアプリケーションで何ができるのかを**具体的**に示すことです。  
そのため具体性を保つためにユーザー目線で機能の定義をするのが重要で、それによって開発者は機能単位で作業がしやすくなります。    


次に後半の「ビジネスロジックの内ドメインとは関係しないデータ・ロジック」についてですが、こちらも婉曲的でわかりにくい定義だと思うので具体例を用いて説明します。  
再び銀行アプリを例に出すと、ある銀行アプリに「取引履歴をエクセル形式で出力する」という機能があるとします。    
その場合この「取引履歴をエクセル形式で出力する」という機能は先ほど述べた「ユーザーから見たアプリケーションの機能」に当てはまるためApplication層に定義されますが、その処理の詳細は大きく「取引履歴データの取得」と「取得したデータのエクセルファイル形式への変換」に分けられます。  

そして、ここで重要なのはこれらの処理のうち「取引履歴データの取得」は銀行業務に含まれるためDomain層に含まれるのに対して、「取得したデータのエクセルファイル形式への変換」はApplication層に分類される点です。  
「取得したデータのエクセルファイル形式への変換」はそれ自体では「ユーザーから見たアプリケーションの機能」として成立していませんが、同時に銀行業務(Domain)にも該当せずあくまでアプリケーションが独自で行っている処理の一部です。  
そのためそれだけではアプリ機能として成立していなくとも、アプリ固有の処理としてApplication層に分類されます。  
他にもログイン情報を表したデータ型等、その業務領域には含まれずアプリケーションのために独自に定義、実装したデータ・ロジックはApplication層に含まれます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/取引履歴データをエクセル形式で出力する例.png" alt="取引履歴データをエクセル形式で出力する例" width=60%　>  

#### Domain層とApplication層の関係
基本的にはApplication層ではアプリの各機能(ユースケース)毎に定義され、Application層からDomain層のデータ・ロジックを利用して処理を実行していきます。  
[先の説明](#Application層)で書いた「取得したデータのエクセルファイル形式への変換」機能のように一部例外はありますが、通常、実際の処理はApplication層には実装されません。  
Application層はあくまで目的達成のためにDomain層の処理を統制する司令塔の役割を担っています。  
そうすると、一見Application層は冗長な存在のように思える人がいるかもしれません。    
しかし、Domain層は言わばそのアプリケーションサービスの原理・原則が定義・実装された非常に抽象的なプログラムの集合であり、ここには実際のアプリケーションプロダクトのコンテクスト(実際にDomainの原理・原則を利用しながらプロダクトとしてどのような機能を実現するのか)は存在していません。  
開発者はこのコンテクストをApplication層から提供されることによって、アプリプロダクトの機能に沿いながら親近感を持って内部システムのプログラムを読み、各機能単位で作業をすることができるのです。  
以下の銀行アプリの例ではDomain層にあるサービスの原理・原則である「取引ロジック」だけ見ても抽象的ですが、Application層にある「お金を預け入れる/振り込む/引き出す」というプログラムの存在により、開発者は具体的に「取引ロジック」を利用してどのようなサービスが提供されているのか把握でき、各機能毎の開発もしやすくなっています。      
このようにApplication-Domain間は「Application層で内部システムのアプリプロダクトにおけるコンテクストを提供し、そこからDomain層のデータ・ロジックを再利用することでコードの重複を避ける」という協調関係で効率的に開発しやすいプログラムを実現しています。

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/Application層とDomain層(銀行アプリ).png" alt="銀行アプリを例にしたApplication層とDomain層の関係" width=70%>  

ここまで見てきてわかる通り、Application層とDomain層は概念的に切り離すのが難しくレイヤードアーキテクチャの他の層の組み合わせと比べても密接な関係にあります。  
しかしそれでもレイヤードアーキテクチャの目的である関心の分離はApplication層とDomain層の関係にも当てはまり、そのアプリの現実世界の業務に関するデータ・ロジックはApplication層に含めてはいけませんし、Domain層がApplication層からどう利用されているかは意識されるべきではありません。  

### ビジネスロジックとは
先ほどの[Application層](#Application層)の説明の中で「ビジネスロジック」という言葉がありますが、これは「ビジネス」と「ロジック」という日常的によく使う単語を組み合わせたものでなんとなく使われることが多いと思うので簡単に説明します。  
[wikipedia](https://ja.wikipedia.org/wiki/ビジネスロジック)にはビジネスロジックに関して明確な定義はないとしながらも、「実世界のビジネスオブジェクトをモデル化したもの」、「そのようなビジネスオブジェクト間の相互作用を示したもの」等と説明されています。    
これらの説明でもなんとなくわかると思いますが、もう少し身近な形で表現すると「アプリケーションに関する仕様書をデザイン/ビジネス/技術の3つにカテゴライズした場合にビジネス仕様書に含まれるもの」であると言えると思います。  
アプリケーションに関する仕様のうちビジネスチームが関わるロジックとそこで利用されるデータを指しているため**ビジネスロジック**なわけです。  
これをレイヤードアーキテクチャに当てはめるとちょうどApplication層とDomain層を合わせたものをビジネスロジックと表現していることになります。<sup>[*3](#footnote3)</sup>  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/アプリケーションの仕様書とレイヤードアーキテクチャの関係.png" alt="アプリケーションの仕様書とレイヤードアーキテクチャの関係" width=60%>  

AppplicationとDomainの2つの層を一括りにして表現している「ビジネスロジック」という言葉が開発において頻繁に使われていることからもこの2層が密接に関係していることが伺えます。    
ちなみにレイヤードアーキテクチャには4層ではなく3層構造で捉える見方もあるのですが、その場合はこのApplicationとDomainがまとまって一つになっています。      
ネットで調べているとこの3層構造のApplicationとDomainをまとめた層を"Application"、"Domain"等と表現しているケースを見かけますが、そうすると4層構造におけるApplicationとDomainと混同してしまうので私はBusiness Logic(ビジネスロジック)と表すのが良いと思っています。  
のちに紹介する私が作成したサンプルプロジェクトでもディレクトリ名としてこのBusiness Logicを使っており、以後この記事でもDomainとApplication層をまとめたい場合はBusiness Logicと表現することとします。  

### レイヤードアーキテクチャの依存関係

#### 依存は一方向のみ
レイヤードアーキテクチャは層の分割に加えてそれぞれの層の関係も定義しています。  
最初のレイヤードアーキテクチャの図でも示しましたが、それぞれの層を**UI-Application-Domain-Infra**という順番に並べた場合、依存方向は左から右への一方向のみというルールを持っています。    
    

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャの依存ルール.png" alt="レイヤードアーキテクチャの依存ルール" width=60%>  

#### 反対方向への呼び出しは?
依存方向は一方向のみというルールですが、逆方向へ依存したい時はどうしたら良いのでしょうか?  
ほとんどの場合は返り値やクロージャのパラメーター(completion handler)を利用することで逆方向へ依存せずとも要件を満たせると思いますが、どうしても必要である場合はプロトコルを利用した依存によって解決します。  
しかしその詳細についてはレイヤードアーキテクチャの話からは逸れてしまうので次の記事で説明する予定です。  
とりあえず本記事では逆方向へのデータの流れは返り値によって実現されるため依存は一方向のみと考えてください。  

#### 層を跨いだApplication層からInfra層への依存
依存方向は一方向なのですが、一つ注意しておきたいのはDomainを跨いだApplication->Infraという依存はありえるということです。   
これは実際のアプリの機能を考えてみればわかります。  
例えばアプリのログイン状態はApplication層のデータですが、ログイン状態は通常、次回起動時も引き続き利用したいためInfra層の永続化機能で保存する必要があります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ApplicationからInfraへ依存.png" alt="ApplicationからInfraへ依存" width=60%　>

このようにアプリケーションの機能上Application層のデータをInfra層を通して操作することは少なからずあり、Application->Infraという依存関係は自然と発生します。   
しかしこの場合も依存が一方向であるのは同じです。       

#### Application層からInfra層への依存以外で層を跨いだ依存はない
ここで一つ疑問に思うのが、「Application->Infrastractureという依存関係がありえるのならば論理的にUI->Domain/Infraというケースもありえるのでは？」ということです。  
しかしそのような依存関係は実際の開発ではありえません。  
なぜなら既に述べた通りApplication層は「ユーザーから見たアプリケーションの機能」を定義している場所であり、それは言い換えるとこのApplication層においてユーザーの要求に応えるべく複数のDomain層の処理を連携させているからです。  
そのためUI層がApplication層を飛び越えてDomain/Infra層にアクセスした場合、Domain/Infra層の処理の連携をUI層が担う必要があり、関心の分離が破られUI層のコードが肥大化・複雑化してしまいます。    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/UIからDomainとInfraを利用.png" alt="UIからDomain/Infraを利用した場合" width=70%>

ケースによってはApplication層への呼び出しが冗長でUI層からDomain層を直接呼び出したくなるかもしれません。      
ただそこでApplication層を省略してUI->Domainの依存を許してしまうとアプリケーション全体でUI->ApplicationとUI->Domainの二つのフローを持つようになるため設計が複雑化してしまい、結果としてApplication層の省略によるコストカット以上に開発コストが増えてしまうことになります。  

このようにApplication層があるにも関わらずUI->Domain/Infraという依存関係を構築しても設計が複雑になってしまうだけです。   
なのでこれら4層の依存関係で変則的な依存関係が発生するのは先に説明したApplication->Infraのみとなります。    

以上でレイヤードアーキテクチャの基本的な説明は終わりですが、クリーンアーキテクチャへ進む前にレイヤードアーキテクチャについて何点か考えることで設計への理解を深めたいと思います。  

## レイヤードアーキテクチャの層の分割は4つが適切か？

レイヤードアーキテクチャの説明の冒頭で分ける層は4つで良いと書きましたが、本当にそれで良いんでしょうか？  
ここでは4つの層が適切であるという私なりの根拠をアプリケーションの層を一つ一つ分割しながら説明していきたいと思います。  

### アプリケーションをビジネスロジックとビジネスロジック以外に分ける

まずアプリケーションを「Business Logic」と「Business Logic以外」というように分割します。  
アプリケーション設計には[Presentation Domain Separation(プレゼンテーションとドメインの分離)](https://bliki-ja.github.io/PresentationDomainSeparation/)(以下PDSと表記)という考え方がありますが、これはアプリケーションをビジネスロジックとその他に分けるというものです。    
なぜ最初にビジネスロジックが抜き出されるのかというと、先に述べたようにビジネスロジックは実世界におけるビジネスルールを記述したアプリケーションプログラムの機能的中心であり、またその実装がプログラミング言語によるデータ宣言とロジックによってのみ構成されているからだと思います。  
そのように外部技術に依存せず純粋なデータとロジックの集合であるビジネスロジックを他と切り離すことで再利用が可能になり、テストもしやすくなります。   

#### プレゼンテーションとドメインの分離(Presentation Domain Separation)についての補足
PDSについては2点ほどわかりづらいところがあると思うので補足します。  
##### 1.ドメイン=ビジネスロジック
最初にPDSのドメインをビジネスロジックと置き換えていることからもわかる通り、ここでのドメインは実質的にはApplication層とDomain層を含んでいます。  
実質的にはというのは概念においてPDSのドメインはレイヤードアーキテクチャのDomainと同じく「業務領域」を意味していますが、PDSはアーキテクチャではなく設計原則であって具体的な層やコンポーネントを想定していません。    
そしてPDSのドキュメントを読むにその第一の主張はアプリケーション機能に関するロジックと他の部分を切り離すことにあると考えられ、ここでのドメインをレイヤードアーキテクチャの文脈に照らし合わせるとApplication層も含めたBusiness Logic層と捉えた方が正しいと思います。  

##### 2.プレゼンテーションとはUIを含めたドメインと連携する全ての機構を含む
次にプレゼンテーションという言葉は一見UIを想起させますが、ここにはInfraも含まれます。   
[PDSのドキュメント](https://bliki-ja.github.io/PresentationDomainSeparation/)には最後に補足のような形で以下の文が書かれています。  

>人間ではなく、コンピュータ相手の Web Services だって、プレゼンテーション部分です。  
>ですから、ドメイン部分のコードと Web Services 部分のコードをごちゃまぜにしてはいけないのです。  
>外部APIにしてもそうです。  

上の引用文から推察するに、どうやらここでいうプレゼンテーションはUIのみを指しているわけではなくドメインと連携する外部機構全てを指していると捉えた方が良さそうです。  
この意味でPDSという概念の中心はプレゼンテーションではなくドメインであるように思います。  
PDSにおけるプレゼンテーションは「ドメインに対する外部機構」ということしか意味しておらず具体性を持っていないからです。  
最初のPDSの定義を「ビジネスロジックとプレゼンテーション」ではなく「ビジネスロジックと**ビジネスロジック以外**」と表現したのもそのためです。  

### Business Logic以外をUIとInfraに分ける
これは特に説明不要でしょう。  
UIとInfraはPDSではドメインに対する外部機構として一つにまとめられていましたが、一般的にユーザーとの接点であるUIとアプリケーションを裏で支えるInfraを区別することに異論はないと思います。  
ただUIとInfraを区別することに違和感がなくても、WebAPIやデータベースを指す永続化機構とカメラやメール等の端末機能をInfraと一つにまとめるのに違和感がある人はいるかもしれません。  
確かに永続化機構と端末機能はアプリケーション上の役割が異なり、場合によってはそれぞれをData、Deviceと区別します。  
しかしどちらもアプリケーションの機能を技術的に裏で支えているという役割は共通しており、設計上でもBusiness Logicとの関係性はともに「Business Logic->Data/Device」となっていてBusiness Logicから呼び出されるため立ち位置が同じです。  
そのため設計の概観を捉える上ではこれらは一つにまとめた方がわかりやすく、この記事でも必要であればData/Deviceと区別しますが、そうでなければInfraとして括ることとします。  

### ビジネスロジックをApplicationとDomainに分ける
最後にビジネスロジックをApplicationとDomainに分けます。  
この2層は[既に説明した](#Domain層とApplication層)通り非常に密接に関わっていますが、やはり責務の質が異なります。  
  
また設計論においてもApplication層に焦点を当てたFlux/Redux、ドメイン層に注目した開発・設計論であるドメイン駆動開発が提唱され支持を得るなどApplication層とDomain層はそれぞれが設計において固有の問題を抱えていることを示しています。  
このような事情を考えてもアプリケーション設計を理解するためにはApplication層とDomain層は独立した2つの層として捉えた方が良いと思います。    

### この4層によってアプリケーションの提供元である企業から提供先であるユーザーまでしっかり捉えている
さて、アプリケーションの層をその必要性を考えながら一つ一つ分けていったのですが、私がこの4層が最適だと思う理由はこれによってアプリケーションの端から端までをしっかりと表現できているからです。  
端から端までとはアプリケーションの提供元となる「企業もしくは事業&#40;Domain&#41;」から提供先であるユーザーとの接点になる「UI」を指しています。    

もしこれより少ない層にしてしまうとアプリケーション開発における複数の問題を混同してしまい、逆にこれ以上層を分けていくと詳細に立ち入りすぎてその構造は必要以上に複雑になりすぎてしまう可能性があります。  
  
ちなみに先でドメイン=企業(事業)と述べていますが、ドメインの「業務領域」を別の言い方をするとその企業がアプリケーションを通して行っている事業の知識・ルールを記述している層と言えます。            

## 設計とは関係を構築すること
最後に本記事の内容を踏まえて設計とはなんであるのか私なりの考えを説明します。    
これに関して色々と意見はあると思いますが、私は**アプリケーション設計とはアプリケーションにおける開発しやすい関係を構築すること**だと考えています。    
レイヤードアーキテクチャではアプリケーションを責務によって分割しそれらをシンプルな関係によって構築することでプログラム構造をより明確で予測しやすいものにしました。  
 
そしてこうしてプログラムを具体的で小さな粒度に分解して組み立てるという考え方は何もレイヤードアーキテクチャに限った話ではありません。  
MVCはアプリケーションをModel-View-Controllerに分けてそれらの関係を定義しているということができますし、他のアーキテクチャも同様です。  
また、よりミクロな設計に目を向けてみてもデザインパターンはアプリケーションにおける特定機能を実現するためのパターン(関係)を、SOLID原則はそれらの関係が適切に保たれているか判断する基準を提示していると言えます。  

このようにアプリケーション設計のマクロからミクロレベルに至る全ての概念やテクニックはアプリケーション内の関係を定義しているといっても過言ではありませんが、なぜ設計においてここまで関係が重要なのでしょうか。  
  
### アプリケーションの複雑さは関係の複雑さによって決まる
その理由は関係性こそがアプリケーションの複雑さを決定しているからです。  
個々のコンポーネントにおいて複雑さを決めている主な要因はその大きさです。  
物事の複雑さを決定している一義的な要因はその情報量であり、その意味で個々のコンポーネントがどのような基準で作られたものであったとしてもその大きささえ適切であれば理解するのは難しくないと思います。  
しかしコンポーネントの集合体であるアプリケーションの開発では、その複雑さが大きさに帰因する度合いはあまり大きくありません。<sup>[*4](#footnote4)</sup>   

#### 関係がアプリケーションの複雑を決定する4つの要因  
その理由には以下4つの連続している要因にあると思います。    
1. **アプリケーションの一般的な大きさ**  
  一般的なアプリケーションは、個人で開発している等、一部のものを除いてどれもそれなりの大きさを持っています。  
  単純な情報量で言えばほとんどのアプリケーションが開発者にとって複雑だと感じるだけの大きさを持っているはずであり、それぞれの大きさの違いは相対的にどちらがより情報量が多いか(少ないか)を意味しているにすぎません。  
2. **アプリケーションは責務によって分割される**  
  そのため実際のアプリケーションでは責務に応じてコンポーネント単位に分割します。<sup>[*5](#footnote5)</sup>  
  これによりアプリケーションプログラムの情報は整理され理解しやすくなります。  
  文章でも編・章・節・項と分割していくことで一つ一つがまとまりのある小さな情報の塊となることで読みやすくなりますが、それと同様です。<sup>[*6](#footnote6)</sup>    
  
3. **責務の分割の際にはコンポーネント間の関係が重要**  
  責務に応じた分割によりアプリケーションは非常にわかりやすくなりますが、アプリケーションを理解するためには個々のコンポーネントを理解するだけでなくそれらの関係も理解する必要があります。    
  個々のコンポーネントがどう関わりあっているのか、それを理解して初めてアプリーション全体がどのように動いているのか見えてくるからです。  
  従ってアプリケーションのコンポーネントへの分割は相互の関係も踏まえて決定していく必要があります。  
  
4. **シンプルな関係を徹底することで大きさの影響を受けづらくなる**  
  このようにアプリケーションを責務に応じて分割する際には「関係」が肝となり、この関係を全体で一貫させることによりアプリケーションは大きさの影響を受けづらくなります。  
  アプリケーション内の各コンポーネントの関係がシンプルで一定ならば、プログラムサイズが変わってもそのコンテクストが変わることはないからです。    
  この特性は主要なアーキテクチャを見てみるとわかると思います。  
  例えば、本記事で主題としているレイヤードアーキテクチャではそれがどのような大きさであれ各コンポーネントは「UI->Application->Domain->Infra」の関係の中に収斂されるため、開発者は各機能やそのコードの詳細に囚われることなくプログラムの流れを理解することが可能となります。  
  また最近普及しているFluxやReduxのスケールのしやすさも「アプリケーションのデータフローは一方向」という制約によって得られています。<sup>[*7](#footnote7)</sup>  

アプリケーションプログラムにおける関係がシンプルかつ一貫性を持っていると、プログラム開発は一定のコンテクストに沿って発展していくためサイズが大きくなっていってもコストを抑えながら開発をすることが可能になります。  
またそもそもアプリケーションの大きさはサービスに対する需要や利便性等プログラム以外の観点によって決定されるので、通常はプログラム設計者が解決できるような問題ではありません。  
そのためアプリケーション設計においては、大きさではなく、その関係を考慮しながらコンポーネントを構築することが重要です。(しかし各コンポーネントの大きさは関係を考慮する上で気を配る必要があります)<sup>[*8](#footnote8)</sup>  
```
補足：
「関係性が重要である」と言われて、何をそんな当たり前なことを、と思っている人はいるかもしれません。  
これは実際にその通りで意味論的に言っても意味は主体と対象との関係において定義づけられますし、　　
また物質的な定義もダイヤモンドと黒煙が同じ炭素の関係の違いでしかなかったり究極的には関係の定義であり、　　
何かを論じる時に関係が重要でないということなんてありえません。  
しかしそれでもあえて私がここで関係を強調する理由は、ネット記事にあるほとんど設計論が「MVC」「Redux」といったパッケージ化された粒度でしか語られていないからです。
(またSOLID原則、等より粒度の小さい設計原理においても概念の重要性ばかりが強調され、実践における探求がされている記事はあまり見かけません。  
言い換えるならば「単一責任原則」は重要ですが、何を「単一の責任」と見なすべきかは該当のアプリケーションプログラムの箇所や個々の具体的な状況によって変わり、  
そうした実践の中で単一の責任を探求しているネット記事は少ないように思います。)   
そのため本記事では本来当たり前である「関係」を踏まえてiOSアプリケーションにおける設計を1から考えることを目的としています。  
```

## アプリケーションの複雑さが関係の複雑さによって決まる例
アプリケーションの複雑さが関係の複雑さによって決定される理由を説明しました。  
しかし実際に具体例を見ないことにはいまいち理解しづらい部分があると思います。    
そのため以下では関係性がアプリケーションの複雑さに影響を与えているいくつかの例を紹介します。  

### Fat ViewController問題

#### MVCのModelにはApplication/Domain/Infra層が含まれる
レイヤードアーキテクチャはUI-Application-Domain-Infraという構成であるということを説明しましたが、これらをMVCアーキテクチャの文脈に当てはめるとUIを除くApplication/Domain/Infraは全てModelに分類されます。

>補足  
>・iOSMVCのControllerに当たるのはViewControllerですが、ViewControllerはUIKitに含まれていることからもわかる通りViewの操作を行う役割を担いUIの仕様を把握しているのでレイヤードアーキテクチャではUI層に該当します。
>   
>・MVCにおいて厳密にInfraがModelに分類されるのかは個人的に疑問なのですが、  
>　少なくともネットでMVCの概要を調べるとInfraをModelに含めてる記事は散見していますし、  
>　何より各コンポーネントをMVC(Model-View-Controller)のどれかに分類するならば消去法でModelしかありません。  
>　そのためここではInfraもModelの一部であると仮定して話を進めます。<sup>[*9](#footnote9)</sup>  

そうするとレイヤードアーキテクチャにおいて異なる階層に属していたApplication/Domain/Infra層のコンポーネントは全てModelという一つのカテゴリーの中で並列関係となり、iOSMVCでは以下のような構成が成立するように思えます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/単純に考えたMVC.png" alt="Modelを深く考えず設計した時に起こりうるMVCの構成" width=70%> 

#### FatViewControllerとは
このような構成は図でみると一見問題ないようにみえますが、実際の開発では大きな問題を生み出します。  
俗にいうFatViewController問題です。  
FatViewControllerとはViewControllerにビジネロジックが書かれる等、ViewControllerの責務が本来あるべき以上に大きくなってしまっている状態を指していますが、上の図のMVCも構成上そうなってしまうことは避けられません。  
その原因は突き詰めていくとViewControllerとModel間の関係性の複雑さにあります。(このケースでは関係の複雑さではなく関係の曖昧さといった方が正確かもしれません。)  

ここではなぜ上記の構成だとFatViewControllerに陥ってしまうのか順に説明していきます。    
#### FatViewControllerの問題はViewControllerというクラス名ではない
FatViewControllerというとViewControllerの責務が「View」なのか「Controller」なのか名前からわかりづらい等、クラス名に関する指摘をよく見聞きしますが、[Appleドキュメント](https://developer.apple.com/documentation/uikit/view_controllers)には   
>You use view controllers to manage your UIKit app’s interface.    

とViewControllerの責務はUIをmanage(管理)であると書かれていて、ここからView(UI)をcontrol(管理)するViewControllerというクラス名は決しておかしな名前とは思えません。(ドキュメントでmanageという言葉を使いながらクラス名がViewControllerなのはiOSプログラミングを既存のMVCに寄せて親しみやすいようにしたかったからでしょうか。)  
「管理」という言葉自体が明確さに欠けているとは言えるかもしれませんが、それが問題になるのは名前そのものに原因があるわけではなくViewControllerと周辺との関係がわかりづらいからです。<sup>[*10](#footnote10)</sup>  

#### ModelとViewの責務が明確ならば、ViewControllerの責務も明確だ
その理由を説明するために、ここでいきなりスイスの話をします。  
スイスはドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの5つの国に囲まれ、4つの言語を公用語としている非常に国際色豊かな国です。  
多くの国際機関がスイスにその本部を置いているのも、世界の文化的中心といえるヨーロッパの中で多くの国に陸続きで囲まれているこうした地理的な状況が関係しているのかもしれません。  
さて、前置きはここら辺にしていきなり質問しますが、この5つの国に囲まれるスイスの領土を知るためには一体どうしたら良いでしょうか？  
  
答えは簡単で、スイスからみてドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土がどこから始まっているか把握すれば良いのです。  
スイスから見て隣国が領土がどこから始まっているのか、それさえわかればスイスの領土も自然とわかるようになります。  
そしてこれは逆に言えばスイスを囲んでいるドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土を知っているならば、スイスの領土も自然と明確になるということです。    
  
MVCにおけるViewControllerの責務だって同じです。  
iOSではViewControllerはModelとViewの間に立つコンポーネントであり、この隣接しているModelとViewの責務が明確であればViewControllerの責務も自然と明確になります。  
そのためViewControllerの責務がそのクラス名から推測可能であるにもかかわらず依然として曖昧であるのはModelとViewの責務がはっきりとしていないからだと言えます。  
そしてここで一般的に問題となるのはそのModel側です。

#### ViewControllerにとってのModelの役割が曖昧
先に示した通りMVCではApplication/Domain/Infraと役割の異なるコンポーネントを全てModelとしているため、各Modelコンポーネントの責務、すなわちViewControllerにとってModelがどのような役割を担っているのかが非常に曖昧になっています。    

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ViewController-Modelの関係性.png" alt="Modelの責務の曖昧化" width=60%> 

そしてこのようにViewController-Model間の責務の境界が不明瞭になった結果、本来Modelの責務であるデータの操作やロジックがViewController側に漏れてしまう現象がFatViewControllerです。    
このときModel側ではなくViewController側に責務が漏れてしまうのは、一般的にModelの責務が何でないのか(UI操作は含まない)は認知されているものの、具体的に何であるのかまでは認知されていないからだと思います。    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/FatViewController.png" alt="FatViewController" width=70%> 
  
もちろんこれはiOSMVCの理想的な形ではありません。[AppleのViewControllerに関するドキュメント](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)にも  

>you should minimize the view controller’s role in managing the actual data.

とあり、ViewControllerのデータの操作は最小限にするべきと記されています。  
  
ただそうだとしてもApplication/Domain/InfraをModelとして捉えて、それをControllerから利用するというMVCのシンプルな構図だけではFatViewControllerは必ずと言って良いほど起こってしまう問題だと思います。  

MVCは概念としてはシンプルでわかりやすいのですが、実際の開発を考えるとApplication/Domain/InfraをModelという一言で済ましてしまうのは言葉足らずな感じがします。      

>補足  
>1  
>ここで述べたFatViewControllerの問題はレイヤードアーキテクチャの依存関係のところでも書いた[UIがApplication層を跨いでDomain/Infraを利用した場合の問題](#Application層からInfra層への依存以外で層を跨いだ依存はない)と外面的には同じです。  
>ただレイヤードアーキテクチャの場合ではModelの責務をしっかりとApplication/Domain/Infraに区別した上でその依存関係の誤りによって問題を起こしてしまったのに対し、MVCのFatViewControllerではそもそもApplication/Domain/Infraの区別ができていません。  
>そのためFatViewControllerの方が状況としてはより深刻であると思います。    
>  
>2  
>ここではFatViewControllerを取り上げたので問題の力点がViewController-Modelに置かれていますが、Modelの責務が曖昧になっているということはViewController-Model間だけでなくModel内部でも問題を引き起こしまう危険性があります。      
>Model内の各コンポーネント間で適切な関係性が構築されていない場合には各責務が小さすぎてコードが冗長になる、また逆に責務が大きすぎて作業しづらいFatModelが発生する等の問題が発生するでしょう。  


#### レイヤードアーキテクチャを取り入れたMVC

レイヤードアーキテクチャはクリーンアーキテクチャと同様に設計思想に近いため、他のアーキテクチャと併用することが可能です。  
MVCにレイヤードアーキテクチャを取り入れた場合の構成は、図にすると以下のような感じです。<sup>[*11](#footnote11)</sup>   

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャを取り入れたMVC.png" alt="レイヤードアーキテクチャを取り入れたMVC" width=70%>  

この図をみただけで、先ほどの単純なMVCよりもわかりやすくなったのがわかるのではないでしょうか？  
まずレイヤードアーキテクチャを採用することでModelが整理されてわかりやすくなりました。    
図の中では責務の性質によりコンポーネントの色を分けているのですが、それを踏まえて先程のMVCの図と比べると今回のModel内の構成が以前より理路整然としているのが見て取れると思います。  
そしてViewControllerから利用するModelはレイヤードアーキテクチャでいうApplication層Modelのみになっているので、ViewController-Model間の関係もより明瞭になりました。            
Application層ModelがViewControllerへ渡すデータはユーザーの要求に直接対応しているはずなので、これによりViewControllerのデータ操作は必要最低限のものになり複雑なロジックを抱えることはなくなります。   
>補足  
>ここでいうViewControllerの必要最低限のデータ操作とは、Modelから渡されたログインしているかどうかというBool型を"ログイン中"というString型に変換する等です。  
>Model(Application)はViewの仕様を知っているべきではありません。  
>そのためModel(Application)からのデータがユーザーの要求に直接対応していたとしても例に出したようにコンピュータにとって都合の良いデータ形式を人間に都合の良いデータ形式に変換する作業はViewControllerで行う必要があります。　　

このようにMVCのModelをレイヤードアーキテクチャによって再考することによって、ViewController-Modelの関係がシンプルでわかりやすくなり、ViewControllerでModelデータ操作により責務が肥大化する恐れがなくなりました。    

#### MVCとMVC+レイヤードアーキテクチャの比較
単純なMVCとレイヤードアーキテクチャを採用したMVCを比較すると、レイヤードアーキテクチャを採用しているMVCの方が責務をより細かく分ける傾向にあるためコードやコンポーネントの量は多くなる可能性が高いです。    
しかしそれでもレイヤードアーキテクチャを採用している方が各コンポーネントの責務やそれらの関係性がはっきりするため、コーディングやチーム開発での作業がしやすくなると思います。     
そしてこうした責務・関係のわかりやすい設計が開発へ与えるポジティブな効果はプロジェクトの規模が大きくなればなるほど高くなっていくでしょう。          

### ネスト構造によるコンテクストの複雑化
関係がアプリケーションの複雑さを左右する例についてもう一例紹介します。  
プログラミングをやっていると「ネスト構造を深くすることは避けろ」ということをよく耳にするのではないでしょうか。<sup>[*12](#footnote12)</sup>    
ネスト構造が否定的に捉えられている理由は分岐が入り組むことによりコードの流れを追うのが難しくなること、また一つ一つのブロックがコンテクストを提供しているのでそれらが入れ子になった結果全体のコンテクストが複雑になってしまうことにあると思います。  
そのような複雑なコンテクスト内では内側のブロックを読む際にその外側のブロックのコンテクストも把握していなければならず、開発者は常に目の前のコード以外の事にも注意を払う必要があるため、認知負荷がとても高くなってしまいます。  
そしてコンテクストが複雑になるということは関係が複雑になっているということです。

ネスト構造が深くなってしまった例<sup>[*13](#footnote13)</sup>  
```
//手数料の計算ロジック

func calculateBankingCommission() -> Int {
    var fee: Int = 0
    if 会員の場合　{
         if 引き出しの場合 {
            fee += 50
            if 平日の場合 {
                 if 9~17時の場合 {
                    return fee
                 } else {
                    return fee + 50
                 }
            } else {
                fee += 50
                if 9~17時の場合 {
                    return fee
                } else {
                    return fee + 50
                }
            }
        } else if 預入の場合 {
             ...
        } else if 振り込みの場合 {
             fee += 300
            ...
        }

    } else {
        ...
    }
}


```
上記のコードの意味を理解するだけなら、「calculateBankingCommission」というメソッド名から簡単に銀行の取引手数料の計算であることがわかると思います。      
しかしもし挙動の不具合等コードの詳細を理解しなければいけなくなった場合、いくつもの「~場合」というif文による分岐とそこで行っている処理を頭の中でまとめあげながら読み解いていく必要があるため、全体として複雑なことはしていないにもかかわらず読み解くのが難しいプログラムになってしまっています。  

## アプリケーション内の関係を考えることで適切な設計を見つける
関係がアプリケーションの複雑さを決めているということを2つのケースを例に説明しましたが、それは別の言い方をすれば関係こそが私たちが良い設計を考える上での手がかりになるということです。  
コードの設計について考えるときにとりうるアプローチは数多くあり、その中には互いに正反対の方向性を持ったものもあります。  
あるケースではコードの重複を減らすために複数のコンポーネントに分けて考えていた責務をまとめて一つにした方が良いかもしれません。  
また別のケースでは反対に一つのコンポーネントの持つ責務の複雑性を回避するため、そこから特定の責務を取り出して別コンポーネントとした方がわかりやすくなるかもしれません。  
私たちは設計を考えていく上でこうしたさまざまな解決方法の中から適切なものを選んでいく必要がありますが、その際には該当のコンポーネントの背後・周辺にある関係を考えることが大きな助けとなります。  

## 関係を考えなかった結果失敗したViewModelの設計
ここでは私が関係を考えずに設計を行った結果失敗した経験を紹介することで、アプリケーション設計において関係を考えることの重要性を示したいと思います。  
私はこのあとの記事で紹介するサンプルプロジェクトを作る際、ViewModelの設計を画面機能ごとにまとめようと考えました。  
画面機能毎にProtocolとその既定実装を書くことでコードを再利用できるように考えたのです。  
しかしその結果ViewModelはとんでもなく複雑で、開発しづらいものになりました。  
その理由は今から考えればとても馬鹿馬鹿しいと思うのですが、ViewModelが「ViewのModel」だからです。  
ViewModelの中心にあるのはあくまで「View」であって「Model(Viewの機能)」ではありません。  
ViewModelの設計の根幹に「View」ではなく「Model」を据えてしまったことにより以下のような問題が発生しました。
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ViewModelの設計(失敗例).png" alt="ViewModelの設計(失敗例)" width=70%>
- 理解しづらい・・・責務を理解するためにはいくつものProtocolを参照しながらそれらを頭の中でまとめあげ、さらにそこにViewModelクラス自身の責務を加える必要があったが、いくつもファイルを跨いでるうちに始めに読んだコードを忘れがちで仕様の把握が大変
- 変更しづらい・・・各責務はViewModelに書かれたコードとViewModelが適応するいくつものProtocolに散在することになり、責務の全体像が把握しづらくコード変更時にどのような影響が出るのかよくわからなくなってしまった
- 設計がいつ崩壊してもおかしくない・・・Protocolの既定実装では格納プロパティを持てないため、仕様の追加・変更によっていつ設計が崩壊してもおかしくない


今回のケースではどんなにコードの重複を減らせたとしても、View毎に責務をまとめる必要がありました。  
これはアプリケーションにおけるViewModelの立ち位置を考えず、コードの重複を減らすことだけに目がいってしまったがための失敗です。  

設計においては、殊更プログラミングの世界では、何が実現(運用)可能で何が机上の空論なのかという判断が非常に難しいです。

そのため設計を行う際はコンポーネントのアプリケーションにおける立ち位置や関連するコンポーネントとの関係を考えることがとても重要になります。  
そうすることで数あるアプローチの中からその開発により適切なものを選び出すことができるようになるからです。  

## この一連の記事で書かれていることも全て関係についてである

設計を考える際に関係を考えなくてはいけないということはいかなる設計論の背後には関係が提示されているということでもあります。    
設計論ではマクロからミクロに至るまでさまざまな技術やパターンそして概念が登場し、それら全てを別個に理解していてはそのあまりの情報量が多く目が眩んでしまいます。  
しかしそういう時、それらの全ての背後にある関係が肝であることを理解していればその詳細に圧倒されることなく、設計を理解する助けになるはずです。  
この一連の記事でもこのあとアプリケーションのさまざまな事柄についてさまざまな視点からスケールしやすい設計を考えていきますが、それらは全てアプリケーション開発にとって最適な関係を見つけていく作業であると言えます。      
>補足  
>コンポーネントが先にあってそれから関係を構築するのか、関係を構築するためにコンポーネントを作るのかというのはケースバイケースだと思うのですが、これまでのプログラミングの歴史におけるアーキテクチャの探究の中でアプリケーションにとって大事なコンポーネントはほとんど出揃っていると考えています。  
>また既存で普及しているコンポーネントから考えた方が私も作業しやすいし、読者の方も理解しやすいと思います。  
>そのため基本的にこの記事では既存のコンポーネントを利用しながら、それらの関係を考えていくというスタイルで話を進めます。  

## 準備の準備編(本記事)のまとめ
- クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想である
- レイヤードアーキテクチャはクリーンアーキテクチャの原型であり、その主な目的はアプリケーションをUI/Application/Domain/Infraという責務の集まりと捉えることによって開発時にそれぞれの責務の関心を分離することである。
- 設計とはアプリケーションにおいて開発しやすい関係を構築することである


## 補論1&#58;アプリケーション設計における関係とは
本記事内で設計においては関係を考えることが重要であると書きました。  
ここではもう少し具体的にアプリケーション設計における関係とはなんであるかを考えていきたいと思います。  
### 関係はどこで発生する？
まずアプリケーション開発(主にコーディング)において関係はどこで生まれるのでしょうか。  
私は大きくいって関係が発生する箇所は3つあると思います。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/アプリケーションにおいて関係が発生する場所.png" alt="アプリケーションにおける関係性" width=70%>  
1. コンポーネント内部・・・コンポーネント内部の変数・メソッド間の関係。さらには処理内部の中のローカルと計算の連携  
2. コンポーネント間・・・コンポーネント同士の繋がり  
3. アプリ全体とコンポーネント、また開発者とコンポーネントの間・・・アプリケーション、開発者に対してのコンポーネントの役割  
  
1と2はそのままなので、3について説明します。  
「アプリケーションに対してのコンポーネントの役割」とは本記事内[ViewModelでの設計失敗談](#関係を考えなかった結果失敗したViewModelの設計)で見たように、アプリケーション全体においてコンポーネントが担う役割のことですが、これに加えて開発者に対しての役割を考えることも重要です。      
例えばViewControllerはプログラミング的には画面機能を統括する責務を持っていますが、同時に開発時の作業の基点としての役割も担っています。     
実際のプロダクトであるiOSアプリの画面に対応するViewControllerの存在のおかげで、開発者はアプリケーションプロダクトとアプリケーションコードとの間に親和性を感じることができます。          
ほとんどのiOSアプリ開発者にとってViewControllerはそのアプリケーションコードを理解するための足掛かりとなっているのではないでしょうか。  
  
設計とは関係を構築することだと言いましたが、その目的は
- (開発者にとって)コードが読みやすい　　
- (開発者にとって)コードを書きやすい　　
- (開発チーム・開発者にとって)作業に取り掛かりやすい　　

等、開発者の作業をしやすくすることです。    
そのため設計をする際には各コンポーネントが開発者に対してどのような役割を担っているか考えることも重要になります。 

### 関係によりアプリケーションが複雑化する原因
次に関係によってどのようにアプリケーションが複雑になるか考えたいと思います。  
私は関係によってアプリケーションが複雑になるとは具体的に以下2つの現象を指していると思います。  
1. データフローの複雑化
2. コンテクストの複雑化

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/関係によるアプリケーションの複雑化.png" alt="関係性によるアプリケーションの複雑化" width=70%>
    
それぞれの詳細はここでは省略しますが、1と2互いに排他的ではなく関係が複雑になることにより同時に起こる現象です。  
またしっかりと検討できていないのですが、コンテクストの複雑化は依存関係の複雑化といっても良いかもしれません。  
コンテクストの複雑化は記事内では[ネスト構造](#ネスト構造によるコンテクストの複雑化)と関連させて紹介しましたがネスト構造に限った話ではなく、コンポーネント内、またコンポーネント間など関係が発生するあらゆるところで発生します。  
図の2でも、都合上省略しましたが繋がりを示すコンテクストはコンテクストEだけではなく、コンテクストA->コンテクストB等他の箇所でも発生しています。  
  
簡単にアプリケーション設計における関係を説明してみました。  
本来これだけで記事が書けるくらい大きなテーマだと思うので、もう少し煮詰めることができたら別記事で取り上げたいと思います。　　    

## 補論2&#58;Modelとはなにか
記事内の[Fat ViewControllerに関する箇所](#MVCのModelにはApplication/Domain/Infra層が含まれる)でMVCのModelにはInfraも含まれると仮定しながらも、厳密にModelにInfraを含めることには違和感があると記しました。  
ここではそれらの問題を踏まえながらModelについて考えたいと思います。  
### MVCにおけるModel
最初にMVCの提案者である[Trygve Reenskaug氏のModelの定義](https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf)を見ていきます。    

>Models represent knowledge.   
>(中略)  
>There should be a one-to-one correspondence between the model and its parts on the one hand, and the represented world as perceived by the owner of the model on the other hand.   
>The nodes of a model should therefore represent an identifiable part of the problem.  
>  
>意訳:  
>モデルは知識を表している。  
>(中略)  
>モデルとそのパーツはその設計者のメンタルモデルと対応していなければならず、そのためモデルの各要素はその問題の特定箇所を示している。    


後半はだいぶ意訳です。
定義内の
>the represented world as perceived by the owner  

をどう解釈するのかが定義の鍵となるのですが、私はメンタルモデルと訳すのが一番良いと思います。  
モデルの話にメンタルモデルと似た用語が出てきてわかりづらいのですが、メンタルモデルは「ある対象に対しての人が抱くイメージ」を指しています。    
上の箇所を[日本語訳している記事](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448)を読んでみると
>その所有者によって知覚された世界の表象  

と少し難解な説明となっているのですが、      
要は「感覚的な認識に基づいて示される世界観」というような意味で、それをさらに簡潔に表すとメンタルモデルになると思います。  

### 改めて、Modelとは
さて話をModelの定義に戻すと、上の定義に沿ってModelをメンタルモデルをプログラム化したものと捉えた場合、そこにInfraは含まれないと思います。  
Infraは文字通り「基盤/下部構造」という意味であり、私たちの普段の活動の中でインフラに対して何かイメージを抱くほど強く意識することは滅多にありません。(ただインフラ開発・運営を生業としている等、インフラ自体が活動目的となっている場合、話は異なってきます。)  
もちろんハンドルを捻れば水道蛇口が水が出てくる等、私たちがインフラを利用できるのはそれらに対するイメージをしっかり持っているからと言えるわけですが、こうしたインフラに対する理解は当たり前のものとして私たちの中に内在しており、実際に日常の活動を行っている際にはほとんど意識されていないでしょう。      
例えば料理の写真を見て実際に自分で作ってみようとした時に、食材やその調理方法についていろいろとイメージしながら作りますが、その際水道やガスシステムに対してまであれこれ思いを巡らす人はいないと思います。  
このようにインフラは日常の活動を下支えする存在であり、それはアプリケーションにおいても同じであるはずです。    
アプリケーションは料理等、現実の活動における何らかの問題に対して解決策を提供するサービスです。  
そのような目的を持ったプログラムの開発においては対象となる活動やそれに対する解決方法に関してはメンタルモデルの対象ですが、それらの技術的基盤にあたるInfraについてはメンタルモデルの対象とはならないのではないでしょうか。  
また先ほどのMVCのModelの定義は[GUIアーキテクチャ](https://martinfowler.com/eaaDev/uiArchs.html)におけるDomainオブジェクトの定義と同じといっても差し支えなく、   
>domain objects that model our perception of the real world  
>
>意訳  
>現実世界に対する認識を型どったドメインオブジェクト  

こうした例をとってもModelに該当するのはDomain/Applicationオブジェクトであると考えられます。<sup>[*9](#footnote9)</sup>  


### InfraがModelとして扱われがちな理由
しかしそれにも関わらずInfraがModelとして扱われがちな原因としては既に本記事内で述べた通りMVCの構成が挙げられます。  
MVCアーキテクチャではアプリケーションはModel-View-Controllerで構成されていると認識されていますし、そうなると消去法によってInfraもModelに分類されるからです。  

ただこれには1点留意点があり、補論冒頭で紹介したMVCの論文が発表されたのはWeb誕生以前の1979年です。  
そのため当時のアプリケーションにおけるInfraの存在は現在のように大きくなく、当初のMVCアーキテクチャの想定にはInfraは含まれていなかったのではないかと思われます。  
そうして考えると、InfraがModelとして扱われがちな原因としてはMVCの構成以前にWeb普及後アプリケーション環境が大きく変わったにも関わらず、未だにWebフレームワークを中心にWeb以前から存在するMVCアーキテクチャが採用されている状況があると言えるでしょう。  
MVCはシンプルであり、Webフレームワーク等、間口の広くしたい場合有効なアーキテクチャであることはわかります。  
しかし現代的なアプリケーションにおいてInfraは非常に重要な役割担っていることを考えると、Model-Infraの区別を明確に示すアーキテクチャの普及が必要であると思います。  
例えばMVCI(Model-View-Controler-Infra)アーキテクチャであれば一つ構成要素が増えることになりますが、ModelとInfraのはっきりと分かれているのでプログラミングを始めたばかりの人でもModelが何で
あるのか、またInfraとModelがどのような関係であるのか混乱することなく理解できるのではないでしょうか。  


## 参考文献
  
書籍  
- [iOSアプリ設計パターン入門](https://peaks.cc/books/iOS_architecture)
- [ドメイン駆動設計](https://www.amazon.co.jp/エリック・エヴァンスのドメイン駆動設計-Architects’Archive-ソフトウェア開発の実践-エリック・エヴァンス/dp/4798121967/ref=asc_df_4798121967/?tag=jpgo-22&linkCode=df0&hvadid=295719984664&hvpos=&hvnetw=g&hvrand=3926308388276309968&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=1009283&hvtargid=pla-525481409888&psc=1&th=1&psc=1)  
  
Web  
- [MVCモデルについて](https://qiita.com/riku-shiru/items/2bed096e106e72e0b58a)
- [レイヤードアーキテクチャの視点](https://qiita.com/kichion/items/aca19765cb16e7e65946)
- [レイヤードアーキテクチャを振り返る](https://buildersbox.corp-sansan.com/entry/2019/04/21/000000_1)
- [MVCのモデルの誤解を解くためにフレームワークを例に挙げようとしたら誤解してもしゃーないなって思った](https://qiita.com/khsk/items/a8cd3adf1e22c9eb209e)
- [wiki(ビジネスロジック)](https://ja.wikipedia.org/wiki/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF)
- [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)([日本語訳](https://blog.tai2.net/the_clean_architecture.html))
- [Appleドキュメント(ViewController)](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)
- [GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)
- [Presentation Domain Separation](https://martinfowler.com/bliki/PresentationDomainSeparation.html)([日本語訳](https://bliki-ja.github.io/PresentationDomainSeparation/))
- [MODELS - VIEWS - CONTROLLERS](https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf)([日本語訳](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448))



<a name="footnote1">*1</a>:  
ここでいうコンポーネントとはアプリケーションのオブジェクトに該当するような構成要素のことを指しており特に特別な意味はありません。MVPでいうところのModel/View/Presenter、FluxでいうところのView/Action/Dispatcher/Store等です。   
「構成要素」と書いても良いのですが、それだとのちに登場するアーキテクチャの層と混同してしまうためコンポーネントと表記します。  
<a name="footnote2">*2</a>:  
GUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」にあるとしましたが、少し正確さに欠ける表現かもしれません。  
なぜならGUIアーキテクチャの根底には本記事でも紹介している[Presentation Domain Separation](#アプリケーションをビジネスロジックとビジネスロジック以外に分ける)があり、そのPDSの考えは「アプリケーションのUIとその他を分離すること」ではなく、「ドメイン(ビジネスロジック)とその他を分離すること」にあるからです。  
とはいえ大筋で合っているのは確かですし、記事の内容には影響はありません。    

<a name="footnote3">*3</a>: 本文内で述べた通りビジネスロジックを「実世界のビジネスオブジェクトをモデル化したもの」と定義づけるならば、[Application層](#Application層)で挙げた「取得したデータのエクセルファイル形式への変換」処理等は実世界のビジネスとは関係ないためビジネスロジックには含まれないと言えるかもしれません。しかしアーキテクチャの文脈においては柔軟に解釈してApplication層全体をビジネスロジックに含んで良いと思います。現に[wikipedia](https://ja.wikipedia.org/wiki/ビジネスロジック)ではビジネスロジックを「3層アーキテクチャでは、ビジネスロジックは中間層を形成する」とも述べていて、こちらの定義ではApplication層全体がビジネスロジックに含まれています。

<a name="footnote4">*4</a>: ここでいうアプリケーションの複雑さとは別の言葉でいうとアプリケーション開発のしやすさと言い換えることができると思います。  

<a name="footnote5">*5</a>: 正確にはレイヤー、モジュールとより大きな単位でも分割は起こっていますが、論旨とは関係ないためここではコンポーネントのみ取り上げています

<a name="footnote6">*6</a>:  
「文章は編・章・節・項と分割していくことで読みやすくはなるけど、結局その複雑さは文章量によるのでは?」と思う方がいるかもしれませんが、あくまでここで言っているのは「情報は整理したらわかりやすくなる」という一般的性質であり、「文章」と「プログラム」があらゆる点で同じであると言っているわけではありません。実際「文章」と「プログラム」、もしくは「文章を読む」と「プログラムを開発する」というのはいくつかの点で異なり、特に一般的にプログラムの開発においてはプログラムを全て読む必要はなく、必要な情報はプログラム全体に関する概念的、技術的概要と自分が取り組もうとするタスクに関する詳細です。そして、後に説明するように「プログラム開発」のこうした特徴のためプログラム内の関係がシンプルであるならば、プログラム拡大の際のコストを軽減することができます。(文章を読むという行為は用途にもよりますが、人間的言語にある機微により基本的に詳細にまで目を通す必要があります。)


<a name="footnote7">*7</a>:  
プログラムを理解するためにはその流れを順に追っていく必要があり、その意味で依存関係が一方向である制約を持つレイヤードアーキテクチャよりもデータフローが一方向であるFlux/Reduxの方がより具体的な関係の制約を定めていると言えます。

<a name="footnote8">*8</a>:  
関係については補論[アプリケーション設計における関係性とは](#補論1アプリケーション設計における関係とは)でも取り上げています。


<a name="footnote9">*9</a>:  
Modelについては補論[Modelとはなにか](#補論2Modelとはなにか)でも考察しています。

<a name="footnote10">*10</a>:  一般的に管理者を意味する「Manager」は抽象的でコンポーネント名の一部として使用するのは避けるべきだと言われており、それは「Controller」でも同様だと思いますが、私は事ViewControllerに関しては致し方ないと思います。[Appleのドキュメント](https://developer.apple.com/documentation/uikit/uiviewcontroller)にはViewControllerの責務として「Viewの更新」「インタラクションへの対応」「レイアウトの変更」「他のオブジェクトとの連携」等が挙げられていることからもわかるとおり、ViewControllerはアプリケーションプログラムの基点でありここで様々な処理を担当せざるを得ない実情があります。そのため、これらを様々な責務を表現する表現として「manage/control(管理)」を使用することは問題ではないと考えています。  

<a name="footnote11">*11</a>:  
実際の開発ではDomain・Infraクラスは複数箇所から利用される場合が多いためこの図のようにケース毎に定義されることはないと思います。


<a name="footnote12">*12</a>:
ちなみに私は全体が複雑にならなければ一度のネスト構造くらいはありだと思っています。

<a name="footnote13">*13</a>:
この例ではネスト構造によるコードの複雑化を強調するため明らかにわかりづらいコードをあえて書いています。  
しかしネスト構造によって複雑化してしまう場合は知らず知らずのうちにどこかで誤った理解、コーディングをしているはずなのでこの例のようなケースが実際の開発で起こることもあながちあり得ないとは言い切れません。
 
<a name="footnote9">*9</a>:
[PDSのドメイン](#アプリケーションをビジネスロジックとビジネスロジック以外に分ける)と同様、GUIアーキテクチャのドメインもレイヤードアーキテクチャでいうDomain層とApplication層が含まれています。      
 
