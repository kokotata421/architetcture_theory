
# iOSアプリでスケールしやすいアーキテクチャを考えてみた①-設計を理解するためのレイヤードアーキテクチャ-

この一連の記事では私的に考えたスケールしやすいアーキテクチャを紹介します。  
記事全体の構成(予定)は以下の通りです。(全部書いてから一気にあげようと思ったけど予想以上の大変で無理でした。😅)  
(1)**設計を理解するためのレイヤードアーキテクチャ編←本記事** 
(2)設計を理解するためのクリーンアーキテクチャ編  
(3)アーキテクチャ概要編  
(4)ViewController編(準備中)  
(5)View/Alert編(準備中)  
(6)画面遷移編(準備中)  
(7)ViewModel(Controller/Presenter)編(準備中)  
(8)UseCaseとエラー編(準備中)  
(9)UseCaseとアプリケーションの状態管理編(準備中)  
(10)Repository編(準備中)  
(11)Domain編(準備中)  
(12)Web API/データベース編(準備中)  
(13)その他(準備中)  

本記事では本編への(準備の)準備編として設計の概観を理解するためレイヤードアーキテクチャを説明しますので、  
「レイヤードアーキテクチャはもう知ってるよ」という人は次のクリーンアーキテクチャ編へ🚅、  
「レイヤードアーキテクチャもクリーンアーキテクチャもわかってるし」という方は概要編から読んでいただいた方が良いと思います。✈️  

## 前提
- 本記事の設計に関する内容はアプリケーション開発を前提としており、ライブラリ等の開発は想定されていません。    
- SwiftUIは扱いません。  
- 作成したサンプルプロジェクトはMVVMをベースに考えていますが、記事内容は基本的にどんなアーキテクチャでも共通する考えとなっているはずです。  
- FluxやReduxのアーキテクチャは概念としては触れる予定ですが、サンプルプロジェクトでは採用されていません。  

## 始めに  
この記事の中で「設計」「アーキテクチャ」と似た言葉が何度も出てくるので記事内でのそれぞれの定義を明確にしておきます。  
設計・・・アプリケーションの構造を作成する作業、またその成果物  
アーキテクチャ・・・アプリケーション設計の際利用されるパターン。MVC/MVVM/Flux/クリーンアーキテクチャ等、またそれらと同列に語られるもの  
明確にするとは言っても「アーキテクチャ」は「設計」なわけで、厳密に両者を区別することは難しいです。  
ただプログラミングについて話す時に両者のニュアンスは異なっている場合が多いと思うのでこの記事では上のように区別することとします。  


## 目的(記事で書かれていること)
現在、モバイルアプリの開発ではMVCを始めMVP・Flux・クリーンアーキテクチャ、その他様々なアーキテクチャが採用されています。  
これらのアーキテクチャは開発の際にとても有効で、作業をする上で大きな指針を開発者に示してくれますし、コミュニケーション時の共通言語としても役立ちます。  
ただこうしたアーキテクチャはアプリケーション構造の概観を提示してくれてはいますが、その詳細についてまでは言及していません。  
そのためアプリケーションの最終的な品質は個々の設計者・開発者に大きく左右されるようになり、本来問題解決のために利用されているはずのアーキテクチャの中で別の問題を引き起こしてしまう恐れがあります。  
巷でよくいうFatViewController、FatViewModelといった問題ですね。  
またそれぞれのアーキテクチャはいずれも特定の問題領域に注目して作られているためそこには少なからず視点の偏りがあります。  
このような状況もあり、私は個々のアーキテクチャを学んでもアプリケーション設計について理解できている感じがしませんでした。  
それぞれのアーキテクチャの形式やメリットは理解できても、それらが設計全体において何を意味しているのかイマイチ良くわからなかったのです。  
このような曖昧な理解は、先ほどのFatViewControllerのようにアーキテクチャの中でまた新しい問題を作ってしまう原因になりえます。  
なので今回、設計を俯瞰的に理解するために様々なアーキテクチャを参考にしながらそこで得られたエッセンスだと思う要素とiOSアプリの構成を照らし合わせて、私的に保守・変更しやすいと思えるアプリケーション開発における雛形を考えてみました。  
本記事を含めた一連の記事で書かれている内容はそのアーキテクチャの説明とそこに至るまでに得られた知見をまとめたものです。  


## 設計を理解するためのクリーンアーキテクチャ

設計を俯瞰することを最初の目的として記事を進めていこうと思いますが、なんの手がかりもなしに理解することは難しいです。  
なのでまずクリーンアーキテクチャを通して設計を理解していきたいと思います。  
既存のアーキテクチャの中からクリーンアーキテクチャを選んだのは、クリーンアーキテクチャの以下の特徴のためです。    
1. 具体的なコンポーネント<sup>[*1](#footnote1)</sup>に依存しておらず、設計思想を提唱している  
2. アプリケーション全体を主要な関心の対象としている  
3. 1と2の特徴を持ったアーキテクチャを総括した立ち位置にある  

簡単にそれぞれの特徴を説明すると、  
1: クリーンアーキテクチャにはMVPのPresenterやFluxのStoreのようにアプリーケーションに必ず含めなければいけないコンポーネントは存在しません。  
クリーンアーキテクチャはそのような具体的なコンポーネントには依存せず、アプリケーションを責務や性質により複数のグループに分割し、それらがどのように連携するのかという考えを提示しています。  
2: MVC・MVP・MVVM等のアーキテクチャは一般的にGUIアーキテクチャ<sup>[*2](#footnote2)</sup>と言われ、主にアプリケーションのUIとその他を分離することに注目していますが、クリーンアーキテクチャはそのようにアプリケーション内部の特定領域に注力しておらずアプリケーションシステム全体を主要な関心対象としています。  
3: 1と2の特徴を持っているのは他にもレイヤードアーキテクチャ・ヘキサゴナルアーキテクチャ・オニオンアーキテクチャ等がありますが、クリーンアーキテクチャはこれらのアーキテクチャを総括した立ち位置にあるアーキテクチャです。  

これらの特徴が設計を考える上で何を意味しているのかということは後ほど説明しますが、以上をまとめると「クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想」であるということです。  
これは「設計を俯瞰して理解する」という私たちの目標と完全に合致しています。  
そのためまず最初の目標としてクリーンアーキテクチャを通してアプリケーション設計への理解を深め、私たちの設計に関する共通認識を作っていきたいと思います。  

## クリーンアーキテクチャへの障壁
ただクリーンアーキテクチャと言えばこの円図が有名ですが、これが非常にとっつきづらいです。　　
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="クリーンアーキテクチャ円図" width=60%　>
 
<sup>参考: [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)</sup>  

図が丸いのでどこからどう読んでいけばよいかわかりませんし、そもそもなぜ円なのかもよくわかりません。  
クリーンアーキテクチャを理解するためにはまず内容以前にその背景にあるコンテクストを理解する必要があります。  
そのため本記事ではクリーンアーキテクチャの原型とも言えるレイヤードアーキテクチャについて学んでいきます。  
  
  
## クリーンアーキテクチャを理解するためのレイヤードアーキテクチャ

レイヤードアーキテクチャはアプリケーションを責務によって複数のグループに分割します。  
これは先ほどクリーンアーキテクチャの特徴として紹介しましたが、レイヤードアーキテクチャも同様です。  
そして分割された複数のグループは単一方向にのみ依存しています。  
こうした特徴を図で表すとまるで複数のグループが積み重ねられ層を成すことでアプリケーションが構成されているようにみえるためレイヤードアーキテクチャ(layered architecture)なわけです、そのままですね。  
レイヤードアーキテクチャの目的はこの責務による分割と単一方向の依存関係により、それぞれの層毎に開発の関心を分離することにあります。  
これによって開発者は開発時、常にアプリケーション全体に注意を向ける必要がなくなり、自分が担当している責務の層に集中できるようになるのです。    
何層に分けるかについてはいくつか考え方があるのですが、私はアプリケーション設計を理解するという目的においては4つの層に分けるのが良いと考えているので今回はそれを紹介します。  

## レイヤードアーキテクチャの概要
レイヤードアーキテクチャの概要は以下の通りです

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャの概要.png" alt="レイヤードアーキテクチャの概要" width=60%　>


>補足  
>レイヤードアーキテクチャの層を指すUI/Application/Domain/Infrastractureという言葉は記事の中で他の用法でも利用されます。  
>なので以後アーキテクチャにおける層を指す場合は英字で、より一般的な文脈で使われる場合はカタカナで表記することとします。  
>例:  
>Application(層) -> アーキテクチャにおけるアプリケーション層  
>アプリケーション -> プロダクト、アプリケーションプログラム等 
> 
>またInfrastructureはInfraと省略して表記します。  


### Domain層とApplication層
各層の内容はだいたい上の図に書かれている通りですが、Domain層とApplication層については少しわかりづらく、また両者の区別もしづらいと思うので説明します。


#### Domain層
ここでのドメインとはアプリケーションが現実で従事する**業務領域**を指し、Domain層にはその業務に関する知識やルールを表現したデータやメソッドが含まれます。    
例えば銀行アプリのドメインは銀行業務全般であり、Domain層には取引の際のルール、顧客の口座等を表現するプログラムが定義・実装されます。  

#### Application層
一般的にはApplication層は「アプリケーション固有のデータ・ロジック」等と定義されていますが、もう少し平たくすると「ユーザーから見たアプリケーションの機能、またビジネスロジックの内ドメインとは関係しないデータ・ロジックを定義・実装する場所」だと言えます。  
ただこれでも依然として具体性にかけると思うので補足していきます。    

まず「ユーザーから見たアプリケーションの機能」というのは銀行アプリで言えば「お金の預入/引き出し/振り込み」等が当たります。  
「ユーザーから見たアプリケーションの機能」と定義が長い理由は、「アプリケーションの機能」だけでは先ほどの「お金の預入/引き出し/振り込み」というような機能を抽象化して「口座のお金の操作」とまとめてしまう可能性があると思ったからです。  
Application層の主な役割はそのアプリケーションで何ができるのかを**具体的**に示すことです。  
そのため具体性を保つためにユーザー目線で機能の定義をするのが重要で、それによって開発者は機能単位で作業がしやすくなります。    


次に後半の「ビジネスロジックの内ドメインとは関係しないデータ・ロジック」についてですが、こちらも婉曲的でわかりにくい定義だと思うので具体例を用いて説明します。  
再び銀行アプリを例に出すと、ある銀行アプリに「取引履歴をエクセル形式で出力する」という機能があるとします。    
その場合この「取引履歴をエクセル形式で出力する」という機能は先ほど述べた「ユーザーから見たアプリケーションの機能」に当てはまるためApplication層に定義されますが、その処理の詳細は大きく「取引履歴データの取得」と「取得したデータのエクセルファイル形式への変換」に分けられます。  

そしてここで重要なのはこれらの処理のうち「取引履歴データの取得」は銀行業務に含まれるためDomain層に含まれるのに対して、「取得したデータのエクセルファイル形式への変換」はApplication層に分類される点です。  
「取得したデータのエクセルファイル形式への変換」はそれ自体では「ユーザーから見たアプリケーションの機能」として成立していませんが、同時に銀行業務(Domain)にも該当せずあくまでアプリケーションが独自で行っている処理の一部です。  
そのためそれだけではアプリ機能として成立していなくとも、アプリ固有の処理としてApplication層に分類されます。  
他にも独自定義したログイン情報を表したデータ型等、そのアプリのデータ・ロジックと呼べるものはApplication層に含まれます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/取引履歴データをエクセル形式で出力する例.png" alt="取引履歴データをエクセル形式で出力する例" width=60%　>  

#### Domain層とApplication層の関係
上の[Application層](#Application層)の説明で書いたように例外もありますが、基本的にはApplication層でアプリケーションの個々の機能を定義してDomain層でApplication層の内部で利用されるデータ・ロジックを定義するという関係と捉えるのがわかりやすいと思います。  
それにより開発者は機能単位で作業を行うことができ、また各機能からDomain層のクラス・メソッドを再利用できるためコードの重複も減らせます。  
  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/Application層とDomain層(銀行アプリ).png" alt="銀行アプリを例にしたApplication層とDomain層の関係" width=70%>  

ここでみてきたことからわかる通り、Application層とDomain層は概念的に切り離すのが難しくレイヤードアーキテクチャの他の層の組み合わせと比べても密接な関係にあります。  
しかしそれでもレイヤードアーキテクチャの目的である関心の分離はApplication層とDomain層の関係にも当てはまり、そのアプリの現実世界の業務に関するデータ・ロジックはApplication層に含めてはいけませんし、Domain層がApplication層からどう利用されているかは意識されるべきではありません。  

### ビジネスロジックとは
先ほどの[Application層](#Application層)の説明の中で「ビジネスロジック」という言葉が使われていますが、「ビジネス」と「ロジック」という日常的によく使う単語を組み合わせた言葉でなんとなく使われることが多いと思うので念のため説明します。  
[wikipedia](https://ja.wikipedia.org/wiki/ビジネスロジック)にはビジネスロジックに関して明確な定義はないとしながらも、「実世界のビジネスオブジェクトをモデル化したもの」、「そのようなビジネスオブジェクト間の相互作用を示したもの」等と説明されています。    
これらの説明でもなんとなくわかると思いますが、もう少し身近な形で表現すると「アプリケーションに関する仕様書をデザイン/ビジネス/技術の3つにカテゴライズした場合にビジネス仕様書に含まれるもの」であると言えるでしょう。        
アプリケーションに関する仕様のうちビジネスチームが関わるロジックとそこで利用されるデータを指しているため**ビジネスロジック**なわけです。  
これをレイヤードアーキテクチャに当てはめるとちょうどApplication層とDomain層を合わせたものをビジネスロジックと表現していることになります  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/アプリケーションの仕様書とレイヤードアーキテクチャの関係.png" alt="アプリケーションの仕様書とレイヤードアーキテクチャの関係" width=60%>  

AppplicationとDomainの2つの層を一括りにして表現している「ビジネスロジック」という言葉が開発において頻繁に使われていることからもこの2層が密接に関係していることが伺えます。    
レイヤードアーキテクチャには4層ではなく3層構造で捉える見方もあるのですが、その場合はこのApplicationとDomainがまとまって一つになっています。      
ネットで調べていると、この3層構造のApplicationとDomainをまとめた表現として"Application"だったり"Domain"等が使われているケースもあるのですが、そうすると4層構造におけるApplicationとDomainと混同してしまうので私はBusiness Logic(ビジネスロジック)とするのが良いと思っています。    
のちに紹介する私が作成したサンプルプロジェクトでもディレクトリ名としてこのBusiness Logicを使っています。  
以後、この記事でもDomainとApplication層をまとめてBusiness Logicと表現することとします。  

### レイヤードアーキテクチャの依存関係

#### 依存は一方向のみ
レイヤードアーキテクチャは層の分割に加えてそれぞれの層の関係も定義しています。  
最初のレイヤードアーキテクチャの図でも示しましたが、それぞれの層を  
UI-Application-Domain-Infra  
という順番に並べた場合、依存方向は左から右への一方向のみであるというルールがあります。    

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャの依存ルール.png" alt="レイヤードアーキテクチャの依存ルール" width=60%>  

#### 反対方向への呼び出しは?
依存方向は一方向のみであるというルールですが、もし上の図でいう右から左へ呼び出しを行いたい時はどうしたら良いのでしょうか?  
大体の場合は**返り値**や**クロージャのパラメーター**を利用することで右から左への呼び出すことなく要件を満たすことができると思いますが、どうしても必要である場合はプロトコルを利用した依存によって解決します。  
ただその詳細についてはレイヤードアーキテクチャの話からは逸れてしまうので次の記事で説明する予定です。  
とりあえず本記事では右から左へデータの流れは返り値によって実現されるため依存は一方向のみであると考えてください。  

#### 層を跨いだApplication層からInfra層への依存
依存方向は一方向なのですが、一つ注意しておきたいのはDomainを跨いだApplication->Infraという依存はありえるということです。   
これは実際のアプリの機能を考えてみればわかります。  
例えばアプリのログイン状態はApplication層のデータですが、このログイン状態は通常、次回起動時も引き続き利用したいデータなのでInfra層の永続化機能で保存する必要があります。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ApplicationからInfraへ依存.png" alt="ApplicationからInfraへ依存" width=60%　>

このようにアプリケーションの機能上Application層のデータをInfra層を通して操作することは少なからずあり、Application->Infraという依存関係は自然と発生します。   
しかしこの場合も依存が一方向であるのは同じです。       

#### Application層からInfra層への依存以外で層を跨いだ依存はない
ここで一つ疑問に思うのが、「Application->Infrastractureという依存関係がありえるのならば論理的にUI->Domain/Infraというケースもありえるのでは？」ということです。  
しかしそのような依存関係は実際の開発ではありえません。  
なぜなら既に述べた通りApplication層は「ユーザーから見たアプリケーションの機能」を定義している場所であり、言い換えるとこのApplication層はユーザーの要求に応えるべく複数のDomain層の処理を連携させています。  
そのためUI層がApplication層を飛び越えてDomain/Infra層にアクセスする場合、Domain/Infra層の処理の連携をUI層が担う必要があり、関心の分離が破られUI層のコードが肥大化・複雑化していきます。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/UIからDomainとInfraを利用.png" alt="UIからDomain/Infraを利用した場合" width=70%>

ケースによってはApplication層への呼び出しが冗長でUI層からDomain層を直接呼び出したくなるかもしれません。      
ただそこでApplication層を省略してUI->Domainの依存を許してしまうとアプリケーション全体でUI->ApplicationとUI->Domainの二つのフローを持つようになり設計が複雑化してしまい、結果としてApplication層の省略によるコストカット以上に開発コストが増加することになります。  

このようにApplication層があるにも関わらずUI->Domain/Infraという依存関係を構築しても設計が複雑になってしまうだけであるため、実際の開発ではありえません。  
これら4層の依存関係で少し変わったケースがあるのは先に説明したApplication->Infraのみです。  

以上でレイヤードアーキテクチャの基本的な説明は終わりですが、クリーンアーキテクチャへ進む前にレイヤードアーキテクチャについて何点か考えることで設計への理解を深めたいと思います。  

## レイヤードアーキテクチャの層の分割は4つが適切か？

レイヤードアーキテクチャの説明の冒頭で分ける層は4つで良いと書きましたが、本当にそれで良いんでしょうか？  
ここでは4つの層が適切であるという私なりの根拠をアプリケーションの層を一つ一つ分割しながら説明していきたいと思います。  

### アプリケーションをビジネスロジックとビジネスロジック以外に分ける

まずアプリケーションを「Business Logic」と「Business Logic以外」というように分割します。  
アプリケーション設計には[Presentation Domain Separation(プレゼンテーションとドメインの分離)](https://bliki-ja.github.io/PresentationDomainSeparation/)(以下PDSと表記)という考え方がありますが、これはアプリケーションをビジネスロジックとその他に分けるものです。  
なぜ最初にビジネスロジックが抜き出されるのかというと、やはりここがアプリケーションプログラムの機能的中心であり、またプログラミング言語による純粋なデータ宣言とロジックによって構成されているからだと思います。    
そのような純粋なデータとロジックの集合であるビジネスロジックを他と切り離すことで再利用が可能になり、テストもしやすくなります。   


#### プレゼンテーションとドメインの分離(Presentation Domain Separation)についての補足
PDSについては2点ほどわかりづらいところがあると思うので補足します。  
##### 1 ドメイン=ビジネスロジック
最初にPDSのドメインをビジネスロジックと置き換えていることからもわかる通り、ここでのドメインは実質的にはApplication層とDomain層を含んでいます。  
実質的にはというのは概念的な意味としてはこのドメインはレイヤードアーキテクチャでのドメインと同じ「業務領域」を指していますが、そもそもPDSはアーキテクチャではなく設計原則であって具体的な層やコンポーネントを指しているわけではありません。  
そしてPDSのドキュメントを読むにその第一の主張はアプリケーションの機能に関するロジックと他の部分を切り離すことにあると考えられるので、ここでのドメインをレイヤードアーキテクチャの文脈に照らし合わせるとApplication層も含めたBusiness Logic層と捉えた方が正しいと思います。  

##### 2 プレゼンテーションとはUIを含めたドメインと連携する全ての機構を含む
次にプレゼンテーションという言葉は一見UIを想起させますが、ここにはInfraも含まれます。   
[PDSのドキュメント](https://bliki-ja.github.io/PresentationDomainSeparation/)には最後に補足のような形で以下の文が書かれています。  

>人間ではなく、コンピュータ相手の Web Services だって、プレゼンテーション部分です。  
>ですから、ドメイン部分のコードと Web Services 部分のコードをごちゃまぜにしてはいけないのです。  
>外部APIにしてもそうです。  

上の引用文から推察するに、どうやらここでいうプレゼンテーションはUIのみを指しているわけではなくドメインと連携する外部機構全てを指していると捉えた方が良さそうです。  
この意味でPDSという概念の中心はプレゼンテーションではなくドメインであるように思います。  
最初のPDSの定義を「ビジネスロジックとプレゼンテーション」ではなく「ビジネスロジックと**ビジネスロジック以外**」と表現したのもそのためです。  

### Business Logic以外をUIとInfraに分ける
これは特に説明不要でしょう。  
UIとInfraはPDSではドメインに対する外部機構として一つにまとめられていましたが、一般的にユーザーとの接点であるUIとアプリケーションを裏で支えているInfraを区別することに異論はないと思います。  
ただUIとInfraを区別することに違和感がなくても、永続化機構や端末機能をInfraと一つにまとめるのに違和感がある人はいるかもしれません。  
確かに永続化機構と端末機能はアプリケーション上の役割は異なり、場合によってはそれぞれをData、Deviceと区別します。  
しかしどちらもアプリケーションの機能を技術的に裏で支えているという役割は共通しており、設計上でもUIとBusiness Logicの関係性は「UI->Business Logicn」とUIからBusiness Logicを呼び出すのに対して、Data/Deviceはともに「Business Logic->Data/Device」となっていてBusiness Logicから呼び出されるため立ち位置が同じです。  
そのため設計の概観を捉える上ではこれらは一つにまとめた方がわかりやすいと思います。  
なのでこの記事でも必要であればData/Deviceと区別しますが、そうでなければInfraとして括ることとします。  

### ビジネスロジックをApplicationとDomainに分ける
最後にビジネスロジックをApplicationとDomainに分けます。  
この2層は[既に説明した](#Domain層とApplication層)通り非常に密接に関わっていますが、やはり責務の質が異なります。  
  
また設計論においてもFlux/Reduxを筆頭に近年Application層の状態を管理することを目的としたアーキテクチャが注目されており、  
そしてドメイン層に注目した開発・設計論であるドメイン駆動開発はその提唱以来多くの人に支持されています。  
このようにApplication層とDomain層の設計論はそれぞれが注目を集めており、それは各層が設計において固有の問題を抱えていることを意味しています。    
こうした事情を考えてもアプリケーション設計を理解するためにはApplication層とDomain層は独立した2つの層として捉えた方が良いと思います。    

### この4層によってアプリケーションの提供元である企業から提供先であるユーザーまでしっかり捉えている
さて、アプリケーションの層をその必要性を考えながら一つ一つ分けていったのですが、私がこの4層が最適だと思う理由はこれによってアプリケーションの端から端までをしっかりと表現できているからです。  
端から端までとはアプリケーションの提供先であるユーザーとの接点となるUIと提供元となる企業もしくは事業のことです。  
UIに関しては説明するまでもないと思いますが、企業(事業)について説明するとドメインとは業務領域を意味していると書きましたが別の言い方をするとその企業がアプリケーションを通して行っている事業の知識・ルールを記述している層だということができます。  

もしこれより少ない層にしてしまうとアプリケーション開発における複数の問題を混同してしまう可能性がありますし、逆にこれ以上層を分けていったとしても詳細に立ち入りすぎてその構造は必要以上に複雑になりすぎてしまうように思います。    


## 設計とは関係を構築すること
最後に本記事の内容を踏まえて設計とはなんであるのか私なりの考えを説明します。    
これに関しては色々と意見があると思いますが、ここで私が述べたいのは**アプリケーション設計とはアプリケーションにおける開発しやすい関係を構築すること**であるという点です。  
レイヤードアーキテクチャではアプリケーションを責務によって分割しそれらをシンプルな関係によって構築することでプログラムをより明確で予測しやすいものにしました。  
 
このようにプログラムを具体的で小さな粒度に分解して組み立てるというのは何もレイヤードアーキテクチャに限った話ではありません。  
MVCはアプリケーションをModel-View-Controllerに分けてそれらの関係を定義しているということができますし、他のアーキテクチャも同様です。  
また、よりミクロな設計に目を向けてみてもデザインパターンはアプリケーションにおける特定機能を実現するためのパターン(関係)を提示しており、SOLID原則はそれらの関係が適切に保たれているか判断する基準であると言えます。<sup>[*3](#footnote3)</sup>  

こうして見てみるとアプリケーション設計のマクロからミクロレベルに至る全ての概念やテクニックは関係を定義しているといっても過言ではありませんが、なぜ設計においてここまで関係が重要なのでしょうか。  
  
  
### アプリケーションの複雑さは関係の複雑さによって決まる
その理由はこの関係こそがアプリケーションの複雑さを決定しているからです。  
個々のコンポーネントにおいて複雑さを決めている主な要因はその大きさです。  
物事の複雑さを決定している一義的な要因はその情報量であり、その意味で個々のコンポーネントがどのような基準で作られたものであったとしてもその大きささえ適切であれば理解するのは難しくないと思います。  
しかしコンポーネントの集合体であるアプリケーションでは、その複雑さが大きさに帰因する度合いはあまり大きくありません。  

#### 関係がアプリケーションの複雑を決定する3つの要因  
その理由は以下3つの連続している要因にあります。  
1. **アプリケーションの一般的な大きさ**  
  一般的なアプリケーションは、個人で開発している等一部のものを除いてどれもそれなりの大きさを持っています。  
  そのため単純な情報量で言えばほとんどのアプリケーションが開発者にとって複雑だと感じるだけの大きさを持っているはずであり、それぞれの大きさの違いは相対的にどちらがより情報量が多いか(少ないか)を意味しているにすぎません。  
2. **アプリケーションは責務によって分割される**  
  そのような大きさのため、実際のアプリケーションでは責務に応じてコンポーネント単位に分割します。  
  それによってアプリケーションの持つ情報はわかりやすい形式に整えられます。  
  そうした責務の分割が与える影響を考えると、アプリケーションの分かりやすさを測る上ではその全体の大きさ以上に個々のコンポーネントのわかりやすさが重要であると言えます。  
  
3. **アプリケーションを理解するためには各コンポーネントに加え、コンポーネント間の関係を把握する必要がある**  
  責務による分割によりアプリケーションは非常にわかりやすくなりますが、アプリケーションを理解するためには個々のコンポーネントを理解するだけでなくコンポーネント間の関係も理解する必要があります。    
  個々のコンポーネントだけでなくそれらがどう関わりあっているのか、それらを理解して初めて個々のコンポーネントが一つのプロダクトとしてどのように動いているのか見えてくるからです。      
  一般的にこうしたコンポーネント間の関係を把握することは個々のコンポーネントを理解すること以上に難しい作業となると思います。    
  歴史などでも個々の事件を覚えることよりもそれらを繋ぎ合わせそこから時代を読み解いていく方が熟慮が必要であったり、アプリケーションに限らず日常で行う様々な作業からも個々の情報を理解するよりもそれらを体系的に理解する方が難しいというのは想像できるのではないでしょうか。  
  
そしてこれら3つの要因に加え、アプリケーションの大きさに関してはそもそもサービスに対する需要や利便性等プログラム以外の側面によって決定されることが多いため、通常は設計者が解決できるような問題ではありません。  
そのためアプリケーション設計においては、大きさではなく、その関係を考慮しながらコンポーネントを構築することが重要になってきます。(ただ各コンポーネントの大きさは関係を考慮する上で気を配る必要があります)　　

#### 一貫性のある関係を構築することでアプリケーションの大きさによる影響を最小限に留める
一貫性を持った関係を構築することで、その大きさに関わらずアプリケーションは理解しやすくなります。  
それはこの記事の主題にもなっているレイヤードアーキテクチャがよく示していると思います。  
レイヤードアーキテクチャを採用したアプリケーションでは、それがどのような大きさであれ「UI->Application->Domain->Infra」(矢印は依存方向)の関係に沿って定義・実装されますが、このようにアプリケーション内のすべての機能が一定のルールに基づいて構築されていることで、開発者は各機能やそのコードの詳細に囚われることなくプログラムの流れを理解することができます。  

もちろん具体的なコードに目を向ければその量に影響を受ける箇所も出てくると思います。          
しかしそのような場合にもアプリケーションの細部に至るまで関係が考慮されているならば、各コンポーネントの責務が明瞭であり、また関心の分離も働くため、その影響はあまり大きくないはずです。  

### アプリケーションの複雑さが関係の複雑さによって決まる例
アプリケーションの複雑さが関係の複雑さによって決まる理由を説明しました。
しかし実際に具体例を見ないことにはいまいち理解しづらい部分があるかもしれません。  
そのため以下では関係がアプリケーションの複雑さに影響を与えているいくつかの例を紹介します。  

## Fat ViewController問題

### MVCのModelにはApplication/Domain/Infra層が含まれる
レイヤードアーキテクチャはUI-Application-Domain-Infraという構成であるということを説明しましたが、これらをMVCアーキテクチャの文脈に当てはめるとUIを除くApplication/Domain/Infraは全てModelに分類されます。

>補足  
>・iOSMVCのControllerに当たるのはViewControllerですが、UIKitに含まれていることからもわかる通りViewの操作を行う役割を担いUIの仕様を把握しているのでレイヤードアーキテクチャではUI層に該当します。
>   
>・MVCにおいて厳密にInfraがModelに分類されるのかは個人的に疑問なのですが、  
>　少なくともネットでMVCの概要を調べるとInfraをModelに含めてる記事は散見していますし、  
>　何より各コンポーネントをMVC(Model-View-Controller)のどれかに分類するならば消去法でModelしかありません。  
>　そのためここではInfraもModelの一部であると仮定して話を進めます。<sup>[*4](#footnote4)</sup>  

そうするとレイヤードアーキテクチャにおいて異なる階層に属していたApplication/Domain/Infra層のコンポーネントは全てModelという一つのカテゴリーの中で並列関係となり、iOSMVCでは以下のような構成が成立するように思えます。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/単純に考えたMVC.png" alt="Modelを深く考えず設計した時に起こりうるMVCの構成" width=70%> 

### FatViewControllerとは
このような構成は図でみると一見問題ないようにみえますが、実際の開発では大きな問題を生み出します。  
俗にいうFatViewController問題です。  
FatViewControllerとはViewControllerにビジネロジックが書かれる等、ViewControllerの責務が本来あるべき以上に大きくなってしまっている状態を指していますが、上の図のMVCもその構成上そうなってしまうことは避けられません。  
その原因は突き詰めていくとViewControllerとModel間の関係性の複雑さにあります。(このケースでは関係の複雑さではなく関係の曖昧さといった方が正確かもしれません。)   

ここではなぜ上のような構成だとFatViewControllerになってしまうのか順に説明していきます。    
### FatViewControllerの問題はViewControllerというクラス名ではない
FatViewControllerというとViewControllerの責務がその名前からわかりづらい等、クラス名に関する指摘をよく見聞きしますが、[Appleドキュメント](https://developer.apple.com/documentation/uikit/view_controllers)には   
>You use view controllers to manage your UIKit app’s interface.    

とViewControllerの責務はUIをmanage(管理)であると書かれていて、View(UI)をcontrol(管理)するというViewControllerは決しておかしなクラス名とは思いません。(ドキュメントでmanageという言葉を使いながらクラス名がViewControllerなのはiOSプログラミングを既存のMVCに寄せて親しみやすいようにしたからでしょうか。)  
「管理」という言葉自体が明確さに欠けているとは言えるかもしれませんが、それが問題になるのは名前そのものに原因があるわけではなくViewControllerと周辺との関係がわかりづらいからです。

### ModelとViewの責務が明確ならば、ViewControllerの責務も明確だ
ここでいきなりスイスの話をします。  
スイスはドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの5つの国に囲まれ、4つの言語を公用語としている非常に国際色豊かな国です。  
多くの国際機関がスイスにその本部を置いているのも、世界の文化的中心といえるヨーロッパの中で多くの国に陸続きで囲まれているこうした地理的な状況が関係しているのかもしれません。  
さて、前置きはここら辺にしていきなり質問しますが、この5つの国に囲まれるスイスの領土を知るためには一体どうしたら良いでしょうか？  
  
  
答えは簡単で、スイスからみてドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土がどこから始まっているか把握すれば良いのです。  
スイスから見て隣国が領土がどこから始まっているのか、それさえわかればスイスの領土も自然とわかるようになります。  
そしてそれは言い換えればスイスを囲んでいるドイツ、フランス、オーストリア、イタリア、リヒテンシュタインの領土を知っているならば、スイスの領土も自然と明確になるということです。    
  
MVCにおけるViewControllerの責務だって同じです。  
iOSではViewControllerはModelとViewの間に立つコンポーネントであり、この隣接しているModelとViewの責務が明確であればViewControllerの責務も自然と明確になります。  
そのためViewControllerの責務がそのクラス名から推測可能であるにもかかわらず依然として曖昧であるのはModelとViewの責務がはっきりとしていないからだと言えます。  
そしてここで一般的に問題となるのはそのModel側です。

### ViewControllerにとってのModelの役割が曖昧
上の図で示した通りMVCではApplication/Domain/Infraと役割の異なるコンポーネントを全てModelとしているため、各Modelコンポーネントの責務、すなわちViewControllerにとってModelがどのような役割を担っているのかが非常に曖昧になっています。    

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ViewController-Modelの関係性.png" alt="Modelの責務の曖昧化" width=60%> 

そしてこうしてViewController-Model間の責務の境界が不明瞭になった結果、本来Modelの責務であるデータの操作やロジックがViewController側に漏れてしまう現象がFatViewControllerです。    
このときModel側ではなくViewController側に責務が漏れてしまうのは、一般的にModelの責務にUI操作が含まれていないことは認知されているものの、Model自身の責務がなんであるのかまでは認知されていないからだと思われます。    
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/FatViewController.png" alt="FatViewController" width=70%> 
  
もちろんこれはiOSMVCの理想的な形ではありません。[AppleのViewControllerに関するドキュメント](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)にも  

>you should minimize the view controller’s role in managing the actual data.

とあり、ViewControllerのデータの操作は最小限にするべきと記されています。  
  
ただそうだとしてもApplication/Domain/InfraをModelとして捉えて、それをControllerから利用するというMVCのシンプルな構図だけではFatViewControllerは必ずと言って良いほど起こってしまう問題だ
と思います。  

MVCは概念としてはシンプルでわかりやすいのですが、実際の開発を考えるとApplication/Domain/InfraをModelという一言で済ましてしまうのは言葉足らずに感じます。    

>補足  
>1  
>ここで述べたFatViewControllerの問題はレイヤードアーキテクチャの依存関係のところでも書いた[UIがApplication層を跨いでDomain/Infraを利用した場合の問題](#Application層からInfra層への依存以外で層を跨いだ依存はない)と外面的には同じです。  
>ただレイヤードアーキテクチャの場合ではModelの責務をしっかりとApplication/Domain/Infraに区別した上でその依存関係の誤りによって問題を起こしてしまったのに対し、MVCのFatViewControllerではそもそもApplication/Domain/Infraの区別ができていません。  
>そのためFatViewControllerの原因の方がより複雑であり状況としてはより深刻であると思います。    
>  
>2  
>ここではFatViewControllerを取り上げたので問題の力点がViewController-Modelに置かれていますが、Modelの責務が曖昧になっているということはViewController-Model間だけでなくModel内部でも問題を引き起こしまう危険性があります。      
>Model内の各コンポーネント間で適切な関係性が構築されていない場合には各責務が小さすぎてコードが冗長になる、また逆に責務が大きすぎて作業しづらいFatModelが発生する等の問題が発生するでしょう。  


### レイヤードアーキテクチャを取り入れたMVC

レイヤードアーキテクチャはクリーンアーキテクチャと同様に設計思想に近いため、他のアーキテクチャと併用することが可能です。  
MVCにレイヤードアーキテクチャを取り入れた場合の構成は、図<sup>[*5](#footnote5)</sup> にすると以下のような感じです。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/レイヤードアーキテクチャを取り入れたMVC.png" alt="レイヤードアーキテクチャを取り入れたMVC" width=70%>  

この図をみただけで、先ほどの単純なMVCよりもわかりやすくなったのがわかるのではないでしょうか？  
まずレイヤードアーキテクチャを採用することでModelが整理されてわかりやすくなりました。    
図の中では責務の性質によりコンポーネントの色を分けているのですが、それを踏まえて先程のMVCの図と比べると今回のModelの構成が以前より理路整然としているのが見て取れると思います。  
そしてViewControllerから利用するModelはレイヤードアーキテクチャでいうApplication層Modelのみになっているので、ViewController-Model間の関係もより明瞭になりました。            
Application層ModelがViewControllerへ渡すデータはユーザーの要求に直接対応しているはずなので、これでViewControllerのデータ操作は必要最低限のものになり複雑なロジックを抱えることはなくなります。   
>補足  
>ここでいうViewControllerの必要最低限のデータ操作とは、Modelから渡されたログインしているかどうかというBool型を"ログイン中"というString型に変換する等です。  
>Model(Application)はViewの仕様を知っているべきではありません。  
>そのためModel(Application)からのデータがユーザーの要求に直接対応していたとしても例に出したようにコンピュータにとって都合の良いデータ形式を人間に都合の良いデータ形式に変換する作業はViewControllerで行う必要があります。　　

このようにMVCのModelをレイヤードアーキテクチャによって再考することによって、ViewController-Modelの関係がシンプルでわかりやすくなり、責務が肥大化することがなくなりました。  

### MVCとMVC+レイヤードアーキテクチャの比較
単純なMVCとレイヤードアーキテクチャを採用したMVCを比較すると、レイヤードアーキテクチャを採用しているMVCの方が責務をより細かく分ける傾向にあるためコードやコンポーネントの量は多くなる可能性は高いです。    
しかしそれでもレイヤードアーキテクチャを採用している方が各コンポーネントの責務やそれらの関係性がはっきりするため、コーディングやチーム開発での作業がしやすくなると思います。     
そしてこうした責務・関係のわかりやすい設計が開発へ与えるポジティブな効果はプロジェクトの規模が大きくなればなるほど高くなっていくでしょう。          

## ネスト構造によるコンテクストの複雑化
関係がアプリケーションの複雑さを左右する例についてもう一例紹介します。  
プログラミングをやっていると「ネスト構造を深くすることは避けろ」ということをよく耳にすると思います。  
ネスト構造が否定的に捉えられている理由は分岐が入り組むことによりコードの流れを追うのが難しくなること、また一つ一つのブロックがコンテクストを提供しているのでそれらが入れ子になった結果全体のコンテクストが複雑になってしまうことにあると思います。  
そのような複雑なコンテクスト内では内側のブロックを読む際にその外側のブロックのコンテクストも把握していなければならず、開発者は常に目の前のコード以外の事にも注意を払う必要があるため、認知負荷がとても高くなってしまいます。  
そしてコンテクストが複雑になるということは関係が複雑になっているということでもあります。

ネスト構造が深くなってしまった例<sup>[*6](#footnote6)</sup>
```
//手数料の計算ロジック

func calculateBankingCommission() -> Int {
    var fee: Int = 0
    if 会員の場合　{
         if 引き出しの場合 {
            fee += 50
            if 平日の場合 {
                 if 9~17時の場合 {
                    return fee
                 } else {
                    return fee + 50
                 }
            } else {
                fee += 50
                if 9~17時の場合 {
                    return fee
                } else {
                    return fee + 50
                }
            }
        } else if 預入の場合 {
             ...
        } else if 振り込みの場合 {
             fee += 300
            ...
        }

    } else {
        ...
    }
}


```
上記のコードの意味を理解するだけなら、「calculateBankingCommission」というメソッド名から簡単に銀行の取引手数料の計算であることがわかると思います。      
しかしもし挙動の不具合等コードの詳細を理解しなければいけなくなった場合、いくつもの「~場合」というif文による分岐とそこで行っている処理を頭の中でまとめあげながら読み解いていく必要があるため、全体として複雑なことはしていないにもかかわらず読み解くのが難しいプログラムになってしまっています。  

## アプリケーション内の関係を考えることで適切な設計を見つける

関係がアプリケーションの複雑さを決めているということを2つのケースを例に説明しました。  
他にも該当するケースはいくつもあり挙げていけばキリがないので省略しますが、ここで私が関係について言及したのはそれが設計を考えていく上で軸となると考えているからです。    
私たちがコードの設計について考えるときにとりうるアプローチは数多くあり、その中には互いに正反対の方向性を持ったものもあります。  
あるケースではコードの重複を減らすために複数のコンポーネントに分けて考えていた責務をまとめて一つにした方が良いかもしれません。  
また別のケースでは反対に一つのコンポーネントの持つ責務の複雑性を回避するため、そこから特定の責務を取り出して別コンポーネントとした方がわかりやすくなるかもしれません。  
私たちは設計を考えていく上でこうしたさまざまな解決方法の中から適切なものを選んでいく必要がありますが、その際にはコンポーネントの背後・周辺にある関係を考えることが大きな助けとなります。  

## 関係を考えなかった結果、失敗したViewModelの設計

ここでは私が関係を考えずに設計を行った結果失敗した経験を紹介することで、アプリケーション設計において関係を考えることの重要性を示したい思います。  
私はこのあとの記事で紹介するサンプルプロジェクトを作る際、ViewModelの設計を画面機能ごとにまとめようと考えました。  
画面機能毎にProtocolとその既定実装を書くことでコードを再利用できるように考えたのです。  
しかしその結果ViewModelはとんでもなく複雑で、開発しづらいものになりました。  
その理由は今から考えればとても馬鹿馬鹿しいと思うのですが、ViewModelが「ViewのModel」だからです。  
ViewModelの中心にあるのはあくまで「View」であって「Model(Viewの機能)」ではありません。  
ViewModelの設計の根幹に「View」ではなく「Model」を据えてしまったことにより以下のような問題が発生しました。
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/ViewModelの設計(失敗例).png" alt="ViewModelの設計(失敗例)" width=70%>
- 変更しづらい・・・各責務はViewModelに書かれたコードとViewModelが適応するいくつものProtocolに散在することになり、責務の全体像が把握しづらくコード変更時にどのような影響が出るのかよくわからなくなってしまった
- 理解しづらい・・・責務を理解するためにはいくつものProtocolを参照しながらそれらを頭の中でまとめあげ、さらにそこにViewModelクラス自身の責務を加える必要があったが、いくつもファイルを跨いでるうちに始めに読んだコードを忘れがちで仕様の把握が大変
- 設計がいつ崩壊してもおかしくない・・・Protocolの既定実装では格納プロパティを持てないため、仕様の追加・変更によっていつ設計が崩壊してもおかしくない


今回のケースではどんなにコードの重複を減らせたとしても、ViewのModelであるViewModelはView毎に責務をまとめる必要がありました。  
これはアプリケーションにおけるViewModelの立ち位置を考えず、コードの重複を減らすことだけに目がいってしまったがための失敗です。  

設計においては、殊更プログラミングの世界では、何が実現(運用)可能で何が机上の空論なのかという判断が非常に難しいです。

そのため設計を行う際はコンポーネントのアプリケーションにおける立ち位置や関連するコンポーネントとの関係を考えることがとても重要になります。  
そうすることで数あるアプローチの中からその開発により適切なものを選び出すことができるようになるからです。  

## この一連の記事で書かれていることも全て関係についてである

設計を考える際に関係を考えなくてはいけないということはいかなる設計論の背後には関係が提示されているということでもあります。    
設計論ではマクロからミクロに至るまでさまざまな技術やパターンそして概念が登場し、それら全てを別個に理解していてはそのあまりの情報量が多く目が眩んでしまいます。  
しかしそういう時、それらの全ての背後にある関係が肝であることを理解していればその詳細に圧倒されることなく、設計を理解する助けになるはずです。  
この一連の記事でもこのあとアプリケーションのさまざまな事柄についてさまざまな視点からスケールしやすい設計を考えていきますが、それらは全てアプリケーション開発にとって最適な関係を見つけていく作業であると言うことができます。    
>補足  
>コンポーネントが先にあってそれから関係を構築するのか、関係を構築するためにコンポーネントを作るのかというのはケースバイケースだと思うのですが、これまでのプログラミングの歴史におけるアーキテクチャの探究の中でアプリケーションにとって大事なコンポーネントはほとんど出揃っていると考えています。  
>また既存で普及しているコンポーネントから考えた方が私も作業しやすいし、読者の方も理解しやすいと思います。  
>そのため基本的にこの記事では既存のコンポーネントを利用しながら、それらの関係を考えていくというスタイルで話を進めます。  

## 準備の準備編(本記事)のまとめ
- クリーンアーキテクチャはアプリケーション全体を考慮して提案された設計思想である
- レイヤードアーキテクチャはクリーンアーキテクチャの原型であり、その主な目的はアプリケーションをUI/Application/Domain/Infraという責務の集まりと捉えることによって開発時にそれぞれの責務の関心を分離することである。
- 設計とはアプリケーションにおいて開発しやすい関係を構築することである


## 補論1 アプリケーション設計における関係性とは
本記事内で設計においては関係性を考えることが重要であると書きました。  
ここではもう少し具体的にアプリケーション設計における関係性とはなんであるかを考えていきたいと思います。  
### 関係性はどこで発生する？
まずアプリケーション開発(主にコーディング)において関係性はどこで生まれるのでしょうか。  
私は大きくいって関係性が発生する箇所は3つあると思います。  
<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/アプリケーションにおける関係性.png" alt="アプリケーションにおける関係性" width=70%>  
1. コンポーネント内部・・・コンポーネント内部の変数・メソッド間の関係性。さらには処理内部の中のローカル変数と計算の連携  
2. コンポーネント間・・・コンポーネント同士の繋がり  
3. アプリ全体とコンポーネント、また開発者とコンポーネントの間・・・アプリケーション、開発者に対してのコンポーネントの役割  
  
1と2はそのままなので、3について説明します。  
「アプリケーションに対してのコンポーネントの役割」とは本記事内[ViewModelでの設計失敗談](#関係性を考えなかった結果、失敗したViewModelの設計)で見たように、アプリケーション全体においてコンポーネントが担うべき責務のことですが、これに加えて開発者に対しての役割を考えることも重要です。      
例えばViewControllerはプログラミング的には画面機能を統括する責務を持っていますが、同時に開発時の作業の基点としての役割も担っています。     
実際のiOSアプリの画面に対応するViewControllerがあるおかげで、開発者はアプリケーションプロダクトとアプリケーションコードとの親和を感じることができます。          
ほとんどのiOSアプリ開発者にとってViewControllerはそのアプリケーションコードを理解するための入り口となっているのではないでしょうか。    
  
設計とは関係を構築することだと言いましたが、その目的は
- (開発者にとって)コードが読みやすい　　
- (開発者にとって)コードを書きやすい　　
- (開発チーム・開発者にとって)作業に取り掛かりやすい　　

など開発者の作業をしやすくすることです。    
そのため設計をする際には各コンポーネントが開発者に対してどのような役割を担っているか考えることも重要になります。 

### 関係性によりアプリケーションが複雑化する原因
次に関係性によってどのようにアプリケーションが複雑になるか考えたいと思います。  
私が今のところ思い浮かんだのは以下の2点です。  

<img src="https://github.com/kokotata421/architetcture_theory/blob/main/Chapter1(レイヤードアーキテクチャ)/Images/関係性によるアプリケーションの複雑化.png" alt="関係性によるアプリケーションの複雑化" width=70%>
    
1と2は互いに排他的ではなく、関係性が複雑になることにより同時に起こってしまう現象です。      
コンテクストの複雑化は記事内では[ネスト構造](#ネスト構造によるコンテクストの複雑化)と関連づけて紹介しましたがネスト構造に限った話ではなく、コンポーネント内、またコンポーネント間など関係性が発生するあらゆるところで発生します。     
図の2でも、都合上省略しましたが繋がりによるコンテストはコンテクストEだけではなく、コンテクストA->コンテクストB等でも発生しています。  
  
簡単にアプリケーション設計における関係性を具体化してみました。  
本来これだけで記事が書けるくらい大きなトピックだと思うので、もう少し煮詰めることができたら別記事で取り上げたいと思います。　　    

## 補論2 Modelとはなにか？
記事内のFat ViewControllerに関する内容でMVCのModelにはInfraも含まれるとしながらも、厳密にModelにInfraを含めることには違和感があると記しました。  
ここではそれらの問題を踏まえながらModelとは何かということについて考えたいと思います。  
最初にMVCの提案者であるTrygve Reenskaug氏のModelの定義を確認してみます。  

>Models represent knowledge.   
>(中略)  
>There should be a one-to-one correspondence between the model and its parts on the one hand, and the represented world as perceived by the owner of the model on the other hand.   
>The nodes of a model should therefore represent an identifiable part of the problem.  
>  
>意訳:  
>モデルは知識を表している。  
>(中略)  
>モデルとそのパーツはその設計者のメンタルモデルと対応していなければならない。  
>*「owner」を設計者と意訳しましたが、そのソフトウェアの発案者やアイディアを考えた人といっても良さそうです。  


後半はだいぶ意訳です。
定義内の
>the represented world as perceived by the owner  

をどう解釈するのかが定義の鍵となるのですが、私はメンタルモデルと訳すのが一番良いと思います。  
モデルの話にメンタルモデルと似た用語が出てきてわかりづらいのですが、メンタルモデルは「ある対象に対してのイメージ」です。  
上の箇所の[日本語訳](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448)をみると
>その所有者によって知覚された世界の表象  

とわかるようでわからない日本語なのですが、      
要は「感覚的な認識によって示された世界観」みたいな意味でさらに簡潔にいうとメンタルモデルと言って良いと思います。  

さて話を日本語訳からModelの定義に戻すと、上で説明した通りModelをメンタルモデルをプログラム化したものとした場合にはそこにInfraは含まれないと思います。  
Infraは文字通り「基盤」であって、私たちは普段の活動の中でそれについて考えることは滅多にありません。(インフラ開発・運営自体を生業としている等の場合話は別ですが。)  
料理の写真を見て実際に自分で作ってみようとなった時、食材やその調理方法をいろいろイメージしながら作ると思いますがその時に水道やガスシステムの構造までイメージする人はいませんよね。  

この論文が発表された1979年にはまだWebは誕生しておらずネットワークを利用したアプリケーションは一般的ではないためデータベースやWeb APIはアーキテクチャの想定に入っていないと思いますが、それを踏まえて解釈してもここでのModel定義とデータベースやWeb APIクライアントの性質を照らし合わせるとこれらはModelに含まれてるとはいえないでしょう。    

そしてTrygve Reenskaug氏のこのModelの定義はGUIアーキテクチャのドメインオブジェクトの定義と全く同じです。  
>domain objects that model our perception of the real world  
>  
>意訳  
>現実世界に対する認識を型どったドメインオブジェクト  

こうしたModelとドメインオブジェクトの定義を照らし合わせてみても、Modelに該当するのはDomain、Application層のオブジェクトだと思います。(記事内でPDSのドメインにはレイヤードアーキテクチャでいうDomainだけでなくApplicationも含むと述べましたが、ここでも同様です。)  

そもそもModelとは「模型」という意味であり、アーキテクチャの文脈に限定しないモデルは実現したいサービスをプログラミング言語化するために言葉や図を使って具体化したものであるはずです。  
そこでInfraも手段として登場することはあっても、Infra自体がモデリングの対象にはならないと思います。  

しかしWebが登場し、さらにWebフレームワークでMVCアーキテクチャが普及したことでModelとWebAPI/データベースなどのInfaは切っても切り離せない関係になりました。  
そして今ではWebAPI/データベースはアプリケーション開発で欠かせないほど重要な存在であり、そのような重要な役割を持つInfraをModelの補佐としてMVCの外側に補助役として置くのではなくModelそのものとして捉えてしまうのは致し方ないことだと思います。(少なくとも私は言葉の意味として違和感は持ちつつもそうしてしまっていました。)  

ただModelという言葉の意味とその定義から考えるにModelにInfraを含めてしまうことは誤りであり、開発におけるModelの重要性を考えると問題の原因になってもおかしくないと思います。

## 補論3 GUIアーキテクチャとPDS
本記事の初めにGUIアーキテクチャとは「アプリケーションのUIとその他を分離すること」と記し、その[脚注(*2)](#footnote2)で「少し正確さに欠ける表現かもしれない」と補足しました。  
ここではそれについて書きたいと思います。  
私はGUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」ではなく、Presentation Domain Separation(PDS)と同様に「ビジネスロジック(ドメイン)とその他を分離すること」とした方が正確なのではと考えています。

このように考える理由をGUIアーキテクチャとPDSを参考にしながら説明します。  
まずMartin Flower氏の「GUI Architectures」と題された記事の中では以下の一節があります。  

>At the heart of MVC, and the idea that was the most influential to later frameworks, is what I call Separated Presentation.  
>The idea behind Separated Presentation is to make a clear division between domain objects that model our perception of the real world, and presentation objects that are the GUI elements we see on the screen.  
>Domain objects should be completely self contained and work without reference to the presentation, they should also be able to support multiple presentations, possibly simultaneously.  
>  
>意訳  
>MVCの核心、また後に登場するアーキテクチャにもっとも影響を与えた考えは私が「Separated Presentation」と呼んでいるものである。  
>この考えの目的は私たちの現実世界に対するメンタルモデルを表したドメインオブジェクトと私たちが画面上でみるGUIに関する要素を分離する事にある。    
>ドメインオブジェクトは単独で動作可能であり、複数のGUIモデルにたいてい同時に対応することが可能である。  
  
ここで述べられている「Separated Presentation」は「MVCの核心」と書かれていますが、「その後に登場するアーキテクチャにもっとも影響を与えた考え」とも書かれていること、またこの記事のタイトルが「GUI Architectures」であることを踏まえると「GUI Architecturesの核心」とも言えるはずです。  
そしてその内容はGUIに関する要素とドメインオブジェクトの分離であり、この定義からみてもGUIアーキテクチャの特徴を「アプリケーションのUIとその他を分離すること」と表現するのは誤りではないと思います。(記事のこの段階では「ドメイン」も「ビジネスロジック」も説明する前だったので、記事の構成上ドメインを「その他」と表現しました。)  
  
ただここからが本題で私はこの「Separated Presentation」という考えは、そのままPDSに言い換えられるのではないかと考えています。    
  
PDSの原則も同じMartin Flower氏により提案されたもので、PDSのドキュメントにもそのように解釈できる一節があります。  
>This principle is the most prominent part of Model View Controller (MVC), indeed for many people MVC is how they describe this separation.
>  
>意訳  
>この原則はMVCにおいて最も重要なものであり、実際多くの人にとってMVCとはPDSを表現するための一つの形式である。  
  
[iOSアプリ設計パターン入門](https://peaks.cc/books/iOS_architecture)という本でもGUIアーキテクチャの根底にあるのはPDSだと書かれていますし、その認識はこの本に限らずプログラマの世界では一般的なのではないでしょうか。  
  
そして本記事内でPDSのPresentationとはUIのみならずビジネスロジックに対する外部機構全てを指しているということはすでに述べました。  
再度引用することになりますが、PDSでは
>web services are also presentations  
>(中略)  
>don't intermix domain code with ... any other external API  
>  
>意訳  
>Webサービスもプレゼンテーションである  
>ドメインのコードと他のいかなる外部APIを混ぜないこと  
とプレゼンテーションがUIのみならずWebサービスのことも指し、それらとドメインを混ぜないことを強調しています。  

このようにGUIアーキテクチャはその名前からはUIを中心としているように感じますが、同じ意味を持つと考えられるPDSと照らし合わせるとその中心にある概念はUIではなくドメインであるように思います。  

なにはともあれGUIアーキテクチャが「UIとビジネスロジック(ドメイン)の分離」を目的としていることは間違いありません。  
ただその背景にある考えはその名前のイメージとは異なっているかも知れません。



参考：  
  
書籍  
- [iOSアプリ設計パターン入門](https://peaks.cc/books/iOS_architecture)
- [ドメイン駆動設計](https://www.amazon.co.jp/エリック・エヴァンスのドメイン駆動設計-Architects’Archive-ソフトウェア開発の実践-エリック・エヴァンス/dp/4798121967/ref=asc_df_4798121967/?tag=jpgo-22&linkCode=df0&hvadid=295719984664&hvpos=&hvnetw=g&hvrand=3926308388276309968&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=1009283&hvtargid=pla-525481409888&psc=1&th=1&psc=1)  
  
Web  
- [MVCモデルについて](https://qiita.com/riku-shiru/items/2bed096e106e72e0b58a)
- [レイヤードアーキテクチャの視点](https://qiita.com/kichion/items/aca19765cb16e7e65946)
- [レイヤードアーキテクチャを振り返る](https://buildersbox.corp-sansan.com/entry/2019/04/21/000000_1)
- [MVCのモデルの誤解を解くためにフレームワークを例に挙げようとしたら誤解してもしゃーないなって思った](https://qiita.com/khsk/items/a8cd3adf1e22c9eb209e)
- [wiki(ビジネスロジック)](https://ja.wikipedia.org/wiki/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF)
- [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)([日本語訳](https://blog.tai2.net/the_clean_architecture.html))
- [Appleドキュメント(ViewController)](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)
- [GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)
- [Presentation Domain Separation](https://martinfowler.com/bliki/PresentationDomainSeparation.html)([日本語訳](https://bliki-ja.github.io/PresentationDomainSeparation/))
- [MODELS - VIEWS - CONTROLLERS](https://folk.universitetetioslo.no/trygver/1979/mvc-2/1979-12-MVC.pdf)([日本語訳](https://digitalsoul.hatenadiary.org/entry/20100913/1284330448))



<a name="footnote1">*1</a>:  
ここでいうコンポーネントとはアプリケーションの構成要素のことを指しており特に特別な意味はありません。MVPでいうところのModel/View/Presenter、FluxでいうところのView/Action/Dispatcher/Store等です。   
「構成要素」と書いても良いのですが、漢字だと画数が多く記事内での頻出単語でもあるため文章がガチャガチャした感じになるので「コンポーネント」と表現します。

<a name="footnote2">*2</a>:  
GUIアーキテクチャの特徴は「アプリケーションのUIとその他を分離すること」にあるとしましたが、GUIアーキテクチャと関連する概念であるPresentation Domain Separationと照らし合わせると自分の理解に少しはっきりしない点があるのでもしかしたら少し正確さに欠ける表現かもしれません。  
とはいえ大筋で合っているのは確かですし、記事の内容には影響はありません。  
詳細は補論[GUIアーキテクチャとPresentation Domain Separation](#補論3-GUIアーキテクチャとPDS)に記しました。  

<a name="footnote3">*3</a>:  
関係性については補論[アプリケーション設計における関係性とは](#補論1-アプリケーション設計における関係性とは)でも取り上げています。

<a name="footnote4">*4</a>:  
Modelについては補論[Modelとはなにか？](#補論2-Modelとはなにか？)でも考察しています。

<a name="footnote5">*5</a>:  
実際の開発ではDomain・Infraクラスは複数箇所から利用される場合が多いためこの図のようにケース毎に定義されることは少ないです。  
ただ複数箇所からの再利用を図で示そうとすると矢印が複雑で見づらくなってしまい、またこの図が意図している内容とは関係ないため単純化して表しています。    

<a name="footnote6">*6</a>:  
この例ではネスト構造によるコードの複雑化を強調するため、明らかに誤った方法でコードを書いています。  
しかし実際の開発で明らかにわかりづらいしなくともネスト構造によって複雑化した場合は知らず知らずのうちにどこかで誤った理解、コーディングをしているはずなのでこの例のようなケースが実際の開発で起こることもあながちあり得ないとは言い切れません。ちなみに私は全体が複雑にならなければ一度のネスト構造くらいはありだと思っています。
  
(正確にはレイヤー、モジュールとより大きな単位でも分割は
起こっていますが、論旨とは関係ないためここではコンポーネントのみ取り上げています)  
